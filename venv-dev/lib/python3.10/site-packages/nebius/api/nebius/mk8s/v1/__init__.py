# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.mk8s.v1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.duration_pb2 as duration_pb2
import google.protobuf.empty_pb2 as empty_pb2
import google.protobuf.message as message_1
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.aio.request_kwargs as request_kwargs
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1.operation_pb2 as operation_pb2
import nebius.api.nebius.mk8s.v1.cluster_pb2 as cluster_pb2
import nebius.api.nebius.mk8s.v1.cluster_service_pb2 as cluster_service_pb2
import nebius.api.nebius.mk8s.v1.instance_template_pb2 as instance_template_pb2
import nebius.api.nebius.mk8s.v1.node_group_pb2 as node_group_pb2
import nebius.api.nebius.mk8s.v1.node_group_service_pb2 as node_group_service_pb2
import nebius.api.nebius.mk8s.v1.progress_data_pb2 as progress_data_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
import typing_extensions as typing_extensions
#@ local imports here @#

# file: nebius/mk8s/v1/cluster.proto
class Cluster(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.Cluster
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.Cluster",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
        status: "ClusterStatus|cluster_pb2.ClusterStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ClusterStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ClusterStatus,
        )
    @status.setter
    def status(self, value: "ClusterStatus|cluster_pb2.ClusterStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ClusterSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        control_plane: "ControlPlaneSpec|cluster_pb2.ControlPlaneSpec|None|unset.UnsetType" = unset.Unset,
        kube_network: "KubeNetworkSpec|cluster_pb2.KubeNetworkSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(control_plane, unset.UnsetType):
            self.control_plane = control_plane
        if not isinstance(kube_network, unset.UnsetType):
            self.kube_network = kube_network
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "control_plane",
            "kube_network",
        ]
    
    @builtins.property
    def control_plane(self) -> "ControlPlaneSpec":
        return super()._get_field("control_plane", explicit_presence=False,
        wrap=ControlPlaneSpec,
        )
    @control_plane.setter
    def control_plane(self, value: "ControlPlaneSpec|cluster_pb2.ControlPlaneSpec|None") -> None:
        return super()._set_field("control_plane",value,explicit_presence=False,
        )
    
    @builtins.property
    def kube_network(self) -> "KubeNetworkSpec":
        """
        Defines kubernetes network configuration, like IP allocation.
        """
        
        return super()._get_field("kube_network", explicit_presence=False,
        wrap=KubeNetworkSpec,
        )
    @kube_network.setter
    def kube_network(self, value: "KubeNetworkSpec|cluster_pb2.KubeNetworkSpec|None") -> None:
        return super()._set_field("kube_network",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "control_plane":"control_plane",
        "kube_network":"kube_network",
    }
    
class ControlPlaneSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ControlPlaneSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ControlPlaneSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        endpoints: "ControlPlaneEndpointsSpec|cluster_pb2.ControlPlaneEndpointsSpec|None|unset.UnsetType" = unset.Unset,
        etcd_cluster_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
        if not isinstance(endpoints, unset.UnsetType):
            self.endpoints = endpoints
        if not isinstance(etcd_cluster_size, unset.UnsetType):
            self.etcd_cluster_size = etcd_cluster_size
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
            "subnet_id",
            "endpoints",
            "etcd_cluster_size",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        Desired Kubernetes version of the cluster. For now only acceptable format is
        ``<major>.<minor>`` like "1.31". Option for patch version update will be added later.
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def subnet_id(self) -> "builtins.str":
        """
        Nebius VPC Subnet ID where control plane instances will be located.
        Also will be default NodeGroup subnet.
        """
        
        return super()._get_field("subnet_id", explicit_presence=False,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def endpoints(self) -> "ControlPlaneEndpointsSpec":
        """
        Specification of endpoints of cluster control plane.
        """
        
        return super()._get_field("endpoints", explicit_presence=False,
        wrap=ControlPlaneEndpointsSpec,
        )
    @endpoints.setter
    def endpoints(self, value: "ControlPlaneEndpointsSpec|cluster_pb2.ControlPlaneEndpointsSpec|None") -> None:
        return super()._set_field("endpoints",value,explicit_presence=False,
        )
    
    @builtins.property
    def etcd_cluster_size(self) -> "builtins.int":
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with ``etcd_cluster_size: 3`` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        
        return super()._get_field("etcd_cluster_size", explicit_presence=False,
        )
    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("etcd_cluster_size",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
        "subnet_id":"subnet_id",
        "endpoints":"endpoints",
        "etcd_cluster_size":"etcd_cluster_size",
    }
    
class ControlPlaneEndpointsSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ControlPlaneEndpointsSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ControlPlaneEndpointsSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        public_endpoint: "PublicEndpointSpec|cluster_pb2.PublicEndpointSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(public_endpoint, unset.UnsetType):
            self.public_endpoint = public_endpoint
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "public_endpoint",
        ]
    
    @builtins.property
    def public_endpoint(self) -> "PublicEndpointSpec|None":
        """
        Public endpoint specification. When set, a public endpoint is created.
        """
        
        return super()._get_field("public_endpoint", explicit_presence=True,
        wrap=PublicEndpointSpec,
        )
    @public_endpoint.setter
    def public_endpoint(self, value: "PublicEndpointSpec|cluster_pb2.PublicEndpointSpec|None") -> None:
        return super()._set_field("public_endpoint",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "public_endpoint":"public_endpoint",
    }
    
class PublicEndpointSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.PublicEndpointSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.PublicEndpointSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class KubeNetworkSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.KubeNetworkSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.KubeNetworkSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        service_cidrs: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(service_cidrs, unset.UnsetType):
            self.service_cidrs = service_cidrs
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "service_cidrs",
        ]
    
    @builtins.property
    def service_cidrs(self) -> "abc.MutableSequence[builtins.str]":
        """
        CIDR blocks for Service ClusterIP allocation.
        For now, only one value is supported.
        Must be a valid CIDR block or prefix length.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
        
        return super()._get_field("service_cidrs", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @service_cidrs.setter
    def service_cidrs(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("service_cidrs",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "service_cidrs":"service_cidrs",
    }
    
class ClusterStatus(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ClusterStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ClusterStatus",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1.ClusterStatus.State",cluster_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        PROVISIONING = 1
        RUNNING = 2
        DELETING = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "ClusterStatus.State|cluster_pb2.ClusterStatus.State|None|unset.UnsetType" = unset.Unset,
        control_plane: "ControlPlaneStatus|cluster_pb2.ControlPlaneStatus|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(control_plane, unset.UnsetType):
            self.control_plane = control_plane
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "control_plane",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "ClusterStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=ClusterStatus.State,
        )
    @state.setter
    def state(self, value: "ClusterStatus.State|cluster_pb2.ClusterStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def control_plane(self) -> "ControlPlaneStatus":
        return super()._get_field("control_plane", explicit_presence=False,
        wrap=ControlPlaneStatus,
        )
    @control_plane.setter
    def control_plane(self, value: "ControlPlaneStatus|cluster_pb2.ControlPlaneStatus|None") -> None:
        return super()._set_field("control_plane",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Show that changes are in flight
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "control_plane":"control_plane",
        "reconciling":"reconciling",
        "State":"State",
    }
    
class ControlPlaneStatus(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ControlPlaneStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ControlPlaneStatus",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        endpoints: "ControlPlaneStatusEndpoints|cluster_pb2.ControlPlaneStatusEndpoints|None|unset.UnsetType" = unset.Unset,
        etcd_cluster_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        auth: "ControlPlaneStatusAuth|cluster_pb2.ControlPlaneStatusAuth|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(endpoints, unset.UnsetType):
            self.endpoints = endpoints
        if not isinstance(etcd_cluster_size, unset.UnsetType):
            self.etcd_cluster_size = etcd_cluster_size
        if not isinstance(auth, unset.UnsetType):
            self.auth = auth
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
            "endpoints",
            "etcd_cluster_size",
            "auth",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        .. role:: raw-html-m2r(raw)
           :format: html
        
        
        Actual Kubernetes and configuration version.
        Version have format ``<major>.<minor>.<patch>-nebius-cp.<infra_version>`` like "1.30.0-nebius-cp.3".
        Where :raw-html-m2r:`<major>`.\\ :raw-html-m2r:`<minor>`.\\ :raw-html-m2r:`<patch>` is Kubernetes version and :raw-html-m2r:`<infra_version>` is version of control plane infrastructure and configuration,
        which update may include bug fixes, security updates and new features of components running on control plane, like CCM or Cluster Autoscaler.
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def endpoints(self) -> "ControlPlaneStatusEndpoints":
        return super()._get_field("endpoints", explicit_presence=False,
        wrap=ControlPlaneStatusEndpoints,
        )
    @endpoints.setter
    def endpoints(self, value: "ControlPlaneStatusEndpoints|cluster_pb2.ControlPlaneStatusEndpoints|None") -> None:
        return super()._set_field("endpoints",value,explicit_presence=False,
        )
    
    @builtins.property
    def etcd_cluster_size(self) -> "builtins.int":
        """
        Number of instances in etcd cluster.
        """
        
        return super()._get_field("etcd_cluster_size", explicit_presence=False,
        )
    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("etcd_cluster_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def auth(self) -> "ControlPlaneStatusAuth":
        return super()._get_field("auth", explicit_presence=False,
        wrap=ControlPlaneStatusAuth,
        )
    @auth.setter
    def auth(self, value: "ControlPlaneStatusAuth|cluster_pb2.ControlPlaneStatusAuth|None") -> None:
        return super()._set_field("auth",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
        "endpoints":"endpoints",
        "etcd_cluster_size":"etcd_cluster_size",
        "auth":"auth",
    }
    
class ControlPlaneStatusEndpoints(pb_classes.Message):
    """
    Endpoints of Kubernetes control plane. Kubernetes API can be accessed at ``https://endpoint/``.
    """
    
    __PB2_CLASS__ = cluster_pb2.ControlPlaneStatusEndpoints
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ControlPlaneStatusEndpoints",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        public_endpoint: "builtins.str|None|unset.UnsetType" = unset.Unset,
        private_endpoint: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(public_endpoint, unset.UnsetType):
            self.public_endpoint = public_endpoint
        if not isinstance(private_endpoint, unset.UnsetType):
            self.private_endpoint = private_endpoint
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "public_endpoint",
            "private_endpoint",
        ]
    
    @builtins.property
    def public_endpoint(self) -> "builtins.str":
        """
        DNS name or IP address accessible from the Internet.
        """
        
        return super()._get_field("public_endpoint", explicit_presence=False,
        )
    @public_endpoint.setter
    def public_endpoint(self, value: "builtins.str|None") -> None:
        return super()._set_field("public_endpoint",value,explicit_presence=False,
        )
    
    @builtins.property
    def private_endpoint(self) -> "builtins.str":
        """
        DNS name or IP address accessible from the user VPC.
        """
        
        return super()._get_field("private_endpoint", explicit_presence=False,
        )
    @private_endpoint.setter
    def private_endpoint(self, value: "builtins.str|None") -> None:
        return super()._set_field("private_endpoint",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "public_endpoint":"public_endpoint",
        "private_endpoint":"private_endpoint",
    }
    
class ControlPlaneStatusAuth(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ControlPlaneStatusAuth
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ControlPlaneStatusAuth",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cluster_ca_certificate: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cluster_ca_certificate, unset.UnsetType):
            self.cluster_ca_certificate = cluster_ca_certificate
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cluster_ca_certificate",
        ]
    
    @builtins.property
    def cluster_ca_certificate(self) -> "builtins.str":
        """
        PEM with the Cluster Certificate Authority, that must be used for TLS connection to Kubernetes API.
        """
        
        return super()._get_field("cluster_ca_certificate", explicit_presence=False,
        )
    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: "builtins.str|None") -> None:
        return super()._set_field("cluster_ca_certificate",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cluster_ca_certificate":"cluster_ca_certificate",
    }
    
# file: nebius/mk8s/v1/cluster_service.proto
class CreateClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.CreateClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.CreateClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.GetClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.GetClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(resource_version, unset.UnsetType):
            self.resource_version = resource_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "resource_version",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_version(self) -> "builtins.str":
        return super()._get_field("resource_version", explicit_presence=False,
        )
    @resource_version.setter
    def resource_version(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "resource_version":"resource_version",
    }
    
class ListClustersRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClustersRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ListClustersRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        ID of the IAM container we are listing the resources in.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListClustersResponse(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClustersResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ListClustersResponse",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Cluster]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Cluster]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Cluster,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Cluster]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class UpdateClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.UpdateClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.UpdateClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata associated with the instance.
        Includes ID of the instance to update.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        """
        Updated specifications for the instance.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.DeleteClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.DeleteClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListClusterControlPlaneVersionsRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClusterControlPlaneVersionsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ListClusterControlPlaneVersionsRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class ListClusterControlPlaneVersionsResponse(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClusterControlPlaneVersionsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ListClusterControlPlaneVersionsResponse",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[ClusterControlPlaneVersion]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[ClusterControlPlaneVersion]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(ClusterControlPlaneVersion,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[ClusterControlPlaneVersion]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
    }
    
class ClusterControlPlaneVersion(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ClusterControlPlaneVersion
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ClusterControlPlaneVersion",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        Format of the version includes only MAJOR.MINOR, the same as can be passed to cluster creation API. For example "1.31".
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
    }
    

class ClusterServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.mk8s.v1.ClusterService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.mk8s.v1.ClusterService",cluster_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.mk8s.v1.ClusterService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetClusterRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetClusterRequest","Cluster"]:
        """
        Returns a specific mk8s cluster by its unique identifier.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.GetClusterRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1.Cluster`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=cluster_pb2.Cluster,
            result_wrapper=pb_classes.simple_wrapper(Cluster),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["v1_1.GetByNameRequest","Cluster"]:
        """
        Returns a specific mk8s cluster by its unique name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1.Cluster`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=cluster_pb2.Cluster,
            result_wrapper=pb_classes.simple_wrapper(Cluster),
            **kwargs,
        )
    
    def list(self,
        request: "ListClustersRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListClustersRequest","ListClustersResponse"]:
        """
        Returns a list of all mk8s clusters in the specified project.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.ListClustersRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1.ListClustersResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=cluster_service_pb2.ListClustersResponse,
            result_wrapper=pb_classes.simple_wrapper(ListClustersResponse),
            **kwargs,
        )
    
    def create(self,
        request: "CreateClusterRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateClusterRequest","operation.Operation[v1_1.Operation]"]:
        """
        Creates a new mk8s cluster.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.CreateClusterRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def update(self,
        request: "UpdateClusterRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateClusterRequest","operation.Operation[v1_1.Operation]"]:
        """
        Modifies an existing mk8s cluster.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.UpdateClusterRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteClusterRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteClusterRequest","operation.Operation[v1_1.Operation]"]:
        """
        Deletes an mk8s cluster.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.DeleteClusterRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def list_control_plane_versions(self,
        request: "ListClusterControlPlaneVersionsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListClusterControlPlaneVersionsRequest","ListClusterControlPlaneVersionsResponse"]:
        """
        ListControlPlaneVersions returns all k8s release versions available in Nebius API.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.ListClusterControlPlaneVersionsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1.ListClusterControlPlaneVersionsResponse`.
        """
        
        return super().request(
            method="ListControlPlaneVersions",
            request=request,
            result_pb2_class=cluster_service_pb2.ListClusterControlPlaneVersionsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListClusterControlPlaneVersionsResponse),
            **kwargs,
        )
    

# file: nebius/mk8s/v1/instance_template.proto
class DiskSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_template_pb2.DiskSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.DiskSpec",instance_template_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class DiskType(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1.DiskSpec.DiskType",instance_template_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        NETWORK_SSD = 1
        NETWORK_HDD = 2
        NETWORK_SSD_IO_M3 = 3
        NETWORK_SSD_NON_REPLICATED = 4
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__()
            self._message: "DiskSpec" = msg
    
    class __OneOfClass_size_size_bytes__(__OneOfClass_size__):
        field: typing.Literal["size_bytes"] = "size_bytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_bytes
    
    class __OneOfClass_size_size_kibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_kibibytes"] = "size_kibibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_kibibytes
    
    class __OneOfClass_size_size_mebibytes__(__OneOfClass_size__):
        field: typing.Literal["size_mebibytes"] = "size_mebibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_mebibytes
    
    class __OneOfClass_size_size_gibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_gibibytes"] = "size_gibibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_gibibytes
    
    @builtins.property
    def size(self) -> __OneOfClass_size_size_bytes__|__OneOfClass_size_size_kibibytes__|__OneOfClass_size_size_mebibytes__|__OneOfClass_size_size_gibibytes__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "size_bytes":
                return self.__OneOfClass_size_size_bytes__(self)
            case "size_kibibytes":
                return self.__OneOfClass_size_size_kibibytes__(self)
            case "size_mebibytes":
                return self.__OneOfClass_size_size_mebibytes__(self)
            case "size_gibibytes":
                return self.__OneOfClass_size_size_gibibytes__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_kibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_mebibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_gibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        block_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        type: "DiskSpec.DiskType|instance_template_pb2.DiskSpec.DiskType|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(size_kibibytes, unset.UnsetType):
            self.size_kibibytes = size_kibibytes
        if not isinstance(size_mebibytes, unset.UnsetType):
            self.size_mebibytes = size_mebibytes
        if not isinstance(size_gibibytes, unset.UnsetType):
            self.size_gibibytes = size_gibibytes
        if not isinstance(block_size_bytes, unset.UnsetType):
            self.block_size_bytes = block_size_bytes
        if not isinstance(type, unset.UnsetType):
            self.type = type
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "size_bytes",
            "size_kibibytes",
            "size_mebibytes",
            "size_gibibytes",
            "block_size_bytes",
            "type",
            "size",
            "DiskType",
        ]
    
    @builtins.property
    def size_bytes(self) -> "builtins.int|None":
        return super()._get_field("size_bytes", explicit_presence=True,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_kibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_kibibytes", explicit_presence=True,
        )
    @size_kibibytes.setter
    def size_kibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_kibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_mebibytes(self) -> "builtins.int|None":
        return super()._get_field("size_mebibytes", explicit_presence=True,
        )
    @size_mebibytes.setter
    def size_mebibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_mebibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_gibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_gibibytes", explicit_presence=True,
        )
    @size_gibibytes.setter
    def size_gibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_gibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def block_size_bytes(self) -> "builtins.int":
        return super()._get_field("block_size_bytes", explicit_presence=False,
        )
    @block_size_bytes.setter
    def block_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("block_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "DiskSpec.DiskType":
        return super()._get_field("type", explicit_presence=False,
        wrap=DiskSpec.DiskType,
        )
    @type.setter
    def type(self, value: "DiskSpec.DiskType|instance_template_pb2.DiskSpec.DiskType|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "size_bytes":"size_bytes",
        "size_kibibytes":"size_kibibytes",
        "size_mebibytes":"size_mebibytes",
        "size_gibibytes":"size_gibibytes",
        "block_size_bytes":"block_size_bytes",
        "type":"type",
        "size":"size",
        "DiskType":"DiskType",
    }
    
class ResourcesSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_template_pb2.ResourcesSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ResourcesSpec",instance_template_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "ResourcesSpec") -> None:
            super().__init__()
            self._message: "ResourcesSpec" = msg
    
    class __OneOfClass_size_preset__(__OneOfClass_size__):
        field: typing.Literal["preset"] = "preset"
        
        def __init__(self, msg: "ResourcesSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.preset
    
    @builtins.property
    def size(self) -> __OneOfClass_size_preset__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "preset":
                return self.__OneOfClass_size_preset__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        platform: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(platform, unset.UnsetType):
            self.platform = platform
        if not isinstance(preset, unset.UnsetType):
            self.preset = preset
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "platform",
            "preset",
            "size",
        ]
    
    @builtins.property
    def platform(self) -> "builtins.str":
        return super()._get_field("platform", explicit_presence=False,
        )
    @platform.setter
    def platform(self, value: "builtins.str|None") -> None:
        return super()._set_field("platform",value,explicit_presence=False,
        )
    
    @builtins.property
    def preset(self) -> "builtins.str|None":
        return super()._get_field("preset", explicit_presence=True,
        )
    @preset.setter
    def preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("preset",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "platform":"platform",
        "preset":"preset",
        "size":"size",
    }
    
# file: nebius/mk8s/v1/node_group.proto
class ConditionStatus(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1.ConditionStatus",node_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    CONDITION_STATUS_UNSPECIFIED = 0
    TRUE = 1
    FALSE = 2
    UNKNOWN = 3

class NodeGroup(pb_classes.Message):
    """
    NodeGroup represents Kubernetes node pool - set of worker machines having the same configuration.
    A Node is a Nebius Compute Instance created in Cluster.metadata.parent_id container, running kubelet
    that registers in Kubernetes API and a Node object created.
    """
    
    __PB2_CLASS__ = node_group_pb2.NodeGroup
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroup",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None|unset.UnsetType" = unset.Unset,
        status: "NodeGroupStatus|node_group_pb2.NodeGroupStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        The parent_id is an ID of Cluster
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "NodeGroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=NodeGroupSpec,
        )
    @spec.setter
    def spec(self, value: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "NodeGroupStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=NodeGroupStatus,
        )
    @status.setter
    def status(self, value: "NodeGroupStatus|node_group_pb2.NodeGroupStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class NodeGroupSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroupSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "NodeGroupSpec") -> None:
            super().__init__()
            self._message: "NodeGroupSpec" = msg
    
    class __OneOfClass_size_fixed_node_count__(__OneOfClass_size__):
        field: typing.Literal["fixed_node_count"] = "fixed_node_count"
        
        def __init__(self, msg: "NodeGroupSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.fixed_node_count
    
    class __OneOfClass_size_autoscaling__(__OneOfClass_size__):
        field: typing.Literal["autoscaling"] = "autoscaling"
        
        def __init__(self, msg: "NodeGroupSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "NodeGroupAutoscalingSpec":
            return self._message.autoscaling
    
    @builtins.property
    def size(self) -> __OneOfClass_size_fixed_node_count__|__OneOfClass_size_autoscaling__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "fixed_node_count":
                return self.__OneOfClass_size_fixed_node_count__(self)
            case "autoscaling":
                return self.__OneOfClass_size_autoscaling__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        fixed_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        autoscaling: "NodeGroupAutoscalingSpec|node_group_pb2.NodeGroupAutoscalingSpec|None|unset.UnsetType" = unset.Unset,
        template: "NodeTemplate|node_group_pb2.NodeTemplate|None|unset.UnsetType" = unset.Unset,
        strategy: "NodeGroupDeploymentStrategy|node_group_pb2.NodeGroupDeploymentStrategy|None|unset.UnsetType" = unset.Unset,
        auto_repair: "NodeGroupAutoRepairSpec|node_group_pb2.NodeGroupAutoRepairSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(fixed_node_count, unset.UnsetType):
            self.fixed_node_count = fixed_node_count
        if not isinstance(autoscaling, unset.UnsetType):
            self.autoscaling = autoscaling
        if not isinstance(template, unset.UnsetType):
            self.template = template
        if not isinstance(strategy, unset.UnsetType):
            self.strategy = strategy
        if not isinstance(auto_repair, unset.UnsetType):
            self.auto_repair = auto_repair
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
            "fixed_node_count",
            "autoscaling",
            "template",
            "strategy",
            "auto_repair",
            "size",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        .. role:: raw-html-m2r(raw)
           :format: html
        
        
        Version is desired Kubernetes version of the cluster. For now only acceptable format is
        ``<major>.<minor>`` like "1.31". Option for patch version update will be added later.
        By default the cluster control plane :raw-html-m2r:`<major>`.\\ :raw-html-m2r:`<minor>` version will be used.
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def fixed_node_count(self) -> "builtins.int|None":
        """
        Number of nodes in the group. Can be changed manually at any time.
        """
        
        return super()._get_field("fixed_node_count", explicit_presence=True,
        )
    @fixed_node_count.setter
    def fixed_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("fixed_node_count",value,explicit_presence=True,
        )
    
    @builtins.property
    def autoscaling(self) -> "NodeGroupAutoscalingSpec|None":
        """
        Enables `Kubernetes Cluster Autoscaler <https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler>`_
        for that NodeGroup, and defines autoscaling parameters.
        """
        
        return super()._get_field("autoscaling", explicit_presence=True,
        wrap=NodeGroupAutoscalingSpec,
        )
    @autoscaling.setter
    def autoscaling(self, value: "NodeGroupAutoscalingSpec|node_group_pb2.NodeGroupAutoscalingSpec|None") -> None:
        return super()._set_field("autoscaling",value,explicit_presence=True,
        )
    
    @builtins.property
    def template(self) -> "NodeTemplate":
        """
        Parameters for Kubernetes Node object and Nebius Compute Instance
        If not written opposite a NodeTemplate field update will cause NodeGroup roll-out according NodeGroupDeploymentStrategy.
        """
        
        return super()._get_field("template", explicit_presence=False,
        wrap=NodeTemplate,
        )
    @template.setter
    def template(self, value: "NodeTemplate|node_group_pb2.NodeTemplate|None") -> None:
        return super()._set_field("template",value,explicit_presence=False,
        )
    
    @builtins.property
    def strategy(self) -> "NodeGroupDeploymentStrategy":
        """
        Defines deployment - roll-out, or nodes re-creation during configuration change.
        Allows to setup compromise in roll-out speed, extra resources consumption and workloads disruption.
        """
        
        return super()._get_field("strategy", explicit_presence=False,
        wrap=NodeGroupDeploymentStrategy,
        )
    @strategy.setter
    def strategy(self, value: "NodeGroupDeploymentStrategy|node_group_pb2.NodeGroupDeploymentStrategy|None") -> None:
        return super()._set_field("strategy",value,explicit_presence=False,
        )
    
    @builtins.property
    def auto_repair(self) -> "NodeGroupAutoRepairSpec":
        """
        Parameters for nodes auto repair.
        """
        
        return super()._get_field("auto_repair", explicit_presence=False,
        wrap=NodeGroupAutoRepairSpec,
        )
    @auto_repair.setter
    def auto_repair(self, value: "NodeGroupAutoRepairSpec|node_group_pb2.NodeGroupAutoRepairSpec|None") -> None:
        return super()._set_field("auto_repair",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
        "fixed_node_count":"fixed_node_count",
        "autoscaling":"autoscaling",
        "template":"template",
        "strategy":"strategy",
        "auto_repair":"auto_repair",
        "size":"size",
    }
    
class NodeTemplate(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeTemplate
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeTemplate",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "NodeMetadataTemplate|node_group_pb2.NodeMetadataTemplate|None|unset.UnsetType" = unset.Unset,
        taints: "abc.Iterable[NodeTaint]|None|unset.UnsetType" = unset.Unset,
        resources: "ResourcesSpec|instance_template_pb2.ResourcesSpec|None|unset.UnsetType" = unset.Unset,
        boot_disk: "DiskSpec|instance_template_pb2.DiskSpec|None|unset.UnsetType" = unset.Unset,
        gpu_settings: "GpuSettings|node_group_pb2.GpuSettings|None|unset.UnsetType" = unset.Unset,
        os: "builtins.str|None|unset.UnsetType" = unset.Unset,
        gpu_cluster: "GpuClusterSpec|node_group_pb2.GpuClusterSpec|None|unset.UnsetType" = unset.Unset,
        network_interfaces: "abc.Iterable[NetworkInterfaceTemplate]|None|unset.UnsetType" = unset.Unset,
        filesystems: "abc.Iterable[AttachedFilesystemSpec]|None|unset.UnsetType" = unset.Unset,
        cloud_init_user_data: "builtins.str|None|unset.UnsetType" = unset.Unset,
        service_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preemptible: "PreemptibleSpec|node_group_pb2.PreemptibleSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(taints, unset.UnsetType):
            self.taints = taints
        if not isinstance(resources, unset.UnsetType):
            self.resources = resources
        if not isinstance(boot_disk, unset.UnsetType):
            self.boot_disk = boot_disk
        if not isinstance(gpu_settings, unset.UnsetType):
            self.gpu_settings = gpu_settings
        if not isinstance(os, unset.UnsetType):
            self.os = os
        if not isinstance(gpu_cluster, unset.UnsetType):
            self.gpu_cluster = gpu_cluster
        if not isinstance(network_interfaces, unset.UnsetType):
            self.network_interfaces = network_interfaces
        if not isinstance(filesystems, unset.UnsetType):
            self.filesystems = filesystems
        if not isinstance(cloud_init_user_data, unset.UnsetType):
            self.cloud_init_user_data = cloud_init_user_data
        if not isinstance(service_account_id, unset.UnsetType):
            self.service_account_id = service_account_id
        if not isinstance(preemptible, unset.UnsetType):
            self.preemptible = preemptible
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "taints",
            "resources",
            "boot_disk",
            "gpu_settings",
            "os",
            "gpu_cluster",
            "network_interfaces",
            "filesystems",
            "cloud_init_user_data",
            "service_account_id",
            "preemptible",
        ]
    
    @builtins.property
    def metadata(self) -> "NodeMetadataTemplate":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=NodeMetadataTemplate,
        )
    @metadata.setter
    def metadata(self, value: "NodeMetadataTemplate|node_group_pb2.NodeMetadataTemplate|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def taints(self) -> "abc.MutableSequence[NodeTaint]":
        """
        Kubernetes Node taints.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.
        Field change will NOT trigger NodeGroup roll out.
        """
        
        return super()._get_field("taints", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NodeTaint,None,None),
        )
    @taints.setter
    def taints(self, value: "abc.Iterable[NodeTaint]|None") -> None:
        return super()._set_field("taints",value,explicit_presence=False,
        )
    
    @builtins.property
    def resources(self) -> "ResourcesSpec":
        """
        Resources that will have Nebius Compute Instance where Node kubelet will run.
        """
        
        return super()._get_field("resources", explicit_presence=False,
        wrap=ResourcesSpec,
        )
    @resources.setter
    def resources(self, value: "ResourcesSpec|instance_template_pb2.ResourcesSpec|None") -> None:
        return super()._set_field("resources",value,explicit_presence=False,
        )
    
    @builtins.property
    def boot_disk(self) -> "DiskSpec":
        """
        Parameters of a Node Nebius Compute Instance boot disk.
        """
        
        return super()._get_field("boot_disk", explicit_presence=False,
        wrap=DiskSpec,
        )
    @boot_disk.setter
    def boot_disk(self, value: "DiskSpec|instance_template_pb2.DiskSpec|None") -> None:
        return super()._set_field("boot_disk",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_settings(self) -> "GpuSettings":
        """
        GPU-related settings.
        """
        
        return super()._get_field("gpu_settings", explicit_presence=False,
        wrap=GpuSettings,
        )
    @gpu_settings.setter
    def gpu_settings(self, value: "GpuSettings|node_group_pb2.GpuSettings|None") -> None:
        return super()._set_field("gpu_settings",value,explicit_presence=False,
        )
    
    @builtins.property
    def os(self) -> "builtins.str":
        """
        OS version that will be used to create the boot disk of Compute Instances in the NodeGroup.
        Supported platform / Kubernetes version / OS / driver presets combinations
        
        
        * ``gpu-l40s-a``\\ , ``gpu-l40s-d``\\ , ``gpu-h100-sxm``\\ , ``gpu-h200-sxm``\\ , ``cpu-e1``\\ , ``cpu-e2``\\ , ``cpu-d3``\\ :
        
          * ``drivers_preset``\\ : ``""``
        
            * ``version``\\ : 1.30  ``"ubuntu22.04"``
            * ``version``\\ : 1.31  ``"ubuntu22.04"`` (default), ``"ubuntu24.04"``
        
        * ``gpu-l40s-a``\\ , ``gpu-l40s-d``\\ , ``gpu-h100-sxm``\\ , ``gpu-h200-sxm``\\ :
        
          * ``drivers_preset``\\ : ``"cuda12"`` (CUDA 12.4)
        
            * ``version``\\ : 1.30, 1.31  ``"ubuntu22.04"``
        
          * ``drivers_preset``\\ : ``"cuda12.4"``
        
            * ``version``\\ : 1.31  ``"ubuntu22.04"``
        
          * ``drivers_preset``\\ : ``"cuda12.8"``
        
            * ``version``\\ : 1.31  ``"ubuntu24.04"``
        
        * ``gpu-b200-sxm``\\ :
        
          * ``drivers_preset``\\ : ``""``
        
            * ``version``\\ : 1.30, 1.31  ``"ubuntu24.04"``
        
          * ``drivers_preset``\\ : ``"cuda12"`` (CUDA 12.8)
        
            * ``version``\\ : 1.30, 1.31  ``"ubuntu24.04"``
        
          * ``drivers_preset``\\ : ``"cuda12.8"``
        
            * ``version``\\ : 1.31  ``"ubuntu24.04"``
        
        * ``gpu-b200-sxm-a``\\ :
        
          * ``drivers_preset``\\ : ``""``
        
            * ``version``\\ : 1.31  ``"ubuntu24.04"``
        
          * ``drivers_preset``\\ : ``"cuda12.8"``
        
            * ``version``\\ : 1.31  ``"ubuntu24.04"``
        """
        
        return super()._get_field("os", explicit_presence=False,
        )
    @os.setter
    def os(self, value: "builtins.str|None") -> None:
        return super()._set_field("os",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_cluster(self) -> "GpuClusterSpec":
        """
        Nebius Compute GPUCluster ID that will be attached to node.
        """
        
        return super()._get_field("gpu_cluster", explicit_presence=False,
        wrap=GpuClusterSpec,
        )
    @gpu_cluster.setter
    def gpu_cluster(self, value: "GpuClusterSpec|node_group_pb2.GpuClusterSpec|None") -> None:
        return super()._set_field("gpu_cluster",value,explicit_presence=False,
        )
    
    @builtins.property
    def network_interfaces(self) -> "abc.MutableSequence[NetworkInterfaceTemplate]":
        return super()._get_field("network_interfaces", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NetworkInterfaceTemplate,None,None),
        )
    @network_interfaces.setter
    def network_interfaces(self, value: "abc.Iterable[NetworkInterfaceTemplate]|None") -> None:
        return super()._set_field("network_interfaces",value,explicit_presence=False,
        )
    
    @builtins.property
    def filesystems(self) -> "abc.MutableSequence[AttachedFilesystemSpec]":
        """
        Static attachments of Compute Filesystem.
        Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
        """
        
        return super()._get_field("filesystems", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AttachedFilesystemSpec,None,None),
        )
    @filesystems.setter
    def filesystems(self, value: "abc.Iterable[AttachedFilesystemSpec]|None") -> None:
        return super()._set_field("filesystems",value,explicit_presence=False,
        )
    
    @builtins.property
    def cloud_init_user_data(self) -> "builtins.str":
        """
        cloud-init user-data
        Should contain at least one SSH key.
        """
        
        return super()._get_field("cloud_init_user_data", explicit_presence=False,
        )
    @cloud_init_user_data.setter
    def cloud_init_user_data(self, value: "builtins.str|None") -> None:
        return super()._set_field("cloud_init_user_data",value,explicit_presence=False,
        )
    
    @builtins.property
    def service_account_id(self) -> "builtins.str":
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make ``nebius`` CLI or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.
        
        ``resource.serviceaccount.issueAccessToken`` permission is required to use this field.
        """
        
        return super()._get_field("service_account_id", explicit_presence=False,
        )
    @service_account_id.setter
    def service_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("service_account_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def preemptible(self) -> "PreemptibleSpec|None":
        """
        Configures whether the nodes in the group are preemptible.
        Set to empty value to enable preemptible nodes.
        """
        
        return super()._get_field("preemptible", explicit_presence=True,
        wrap=PreemptibleSpec,
        )
    @preemptible.setter
    def preemptible(self, value: "PreemptibleSpec|node_group_pb2.PreemptibleSpec|None") -> None:
        return super()._set_field("preemptible",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "taints":"taints",
        "resources":"resources",
        "boot_disk":"boot_disk",
        "gpu_settings":"gpu_settings",
        "os":"os",
        "gpu_cluster":"gpu_cluster",
        "network_interfaces":"network_interfaces",
        "filesystems":"filesystems",
        "cloud_init_user_data":"cloud_init_user_data",
        "service_account_id":"service_account_id",
        "preemptible":"preemptible",
    }
    
class NodeMetadataTemplate(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeMetadataTemplate
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeMetadataTemplate",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class LabelsEntry(pb_classes.Message):
        __PB2_CLASS__ = node_group_pb2.NodeMetadataTemplate.LabelsEntry
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeMetadataTemplate.LabelsEntry",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            key: "builtins.str|None|unset.UnsetType" = unset.Unset,
            value: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(key, unset.UnsetType):
                self.key = key
            if not isinstance(value, unset.UnsetType):
                self.value = value
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "key",
                "value",
            ]
        
        @builtins.property
        def key(self) -> "builtins.str":
            return super()._get_field("key", explicit_presence=False,
            )
        @key.setter
        def key(self, value: "builtins.str|None") -> None:
            return super()._set_field("key",value,explicit_presence=False,
            )
        
        @builtins.property
        def value(self) -> "builtins.str":
            return super()._get_field("value", explicit_presence=False,
            )
        @value.setter
        def value(self, value: "builtins.str|None") -> None:
            return super()._set_field("value",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "key":"key",
            "value":"value",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        labels: "abc.Mapping[builtins.str,builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(labels, unset.UnsetType):
            self.labels = labels
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "labels",
            "LabelsEntry",
        ]
    
    @builtins.property
    def labels(self) -> "abc.MutableMapping[builtins.str,builtins.str]":
        """
        Kubernetes Node labels.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.
        
        System labels containing "kubernetes.io" and "k8s.io" will be ignored.
        Field change will NOT trigger NodeGroup roll out.
        """
        
        return super()._get_field("labels", explicit_presence=False,
        wrap=pb_classes.Map,
        )
    @labels.setter
    def labels(self, value: "abc.Mapping[builtins.str,builtins.str]|None") -> None:
        return super()._set_field("labels",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "labels":"labels",
        "LabelsEntry":"LabelsEntry",
    }
    
class GpuSettings(pb_classes.Message):
    """
    GPU-related settings.
    """
    
    __PB2_CLASS__ = node_group_pb2.GpuSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.GpuSettings",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        drivers_preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(drivers_preset, unset.UnsetType):
            self.drivers_preset = drivers_preset
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "drivers_preset",
        ]
    
    @builtins.property
    def drivers_preset(self) -> "builtins.str":
        """
        Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
        Supported presets for different platform / Kubernetes version combinations:
        
        
        * ``gpu-l40s-a``\\ , ``gpu-l40s-d``\\ , ``gpu-h100-sxm``\\ , ``gpu-h200-sxm``\\ :
        
          * ``version``\\ : 1.30  ``"cuda12"`` (CUDA 12.4)
          * ``version``\\ : 1.31  ``"cuda12"`` (CUDA 12.4), ``"cuda12.4"``\\ , ``"cuda12.8"``
        
        * ``gpu-b200-sxm``\\ :
        
          * ``version``\\ : 1.31  ``"cuda12"`` (CUDA 12.8), ``"cuda12.8"``
        
        * ``gpu-b200-sxm-a``\\ :
        
          * ``version``\\ : 1.31  ``"cuda12.8"``
        """
        
        return super()._get_field("drivers_preset", explicit_presence=False,
        )
    @drivers_preset.setter
    def drivers_preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("drivers_preset",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "drivers_preset":"drivers_preset",
    }
    
class GpuClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.GpuClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.GpuClusterSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class NetworkInterfaceTemplate(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NetworkInterfaceTemplate
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NetworkInterfaceTemplate",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        public_ip_address: "PublicIPAddress|node_group_pb2.PublicIPAddress|None|unset.UnsetType" = unset.Unset,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(public_ip_address, unset.UnsetType):
            self.public_ip_address = public_ip_address
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "public_ip_address",
            "subnet_id",
        ]
    
    @builtins.property
    def public_ip_address(self) -> "PublicIPAddress|None":
        """
        Parameters for Public IPv4 address associated with the interface.
        Set to empty value, to enable it.
        """
        
        return super()._get_field("public_ip_address", explicit_presence=True,
        wrap=PublicIPAddress,
        )
    @public_ip_address.setter
    def public_ip_address(self, value: "PublicIPAddress|node_group_pb2.PublicIPAddress|None") -> None:
        return super()._set_field("public_ip_address",value,explicit_presence=True,
        )
    
    @builtins.property
    def subnet_id(self) -> "builtins.str":
        """
        Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
        By default Cluster control plane subnet_id used.
        Subnet should be located in the same network with control plane.
        """
        
        return super()._get_field("subnet_id", explicit_presence=False,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "public_ip_address":"public_ip_address",
        "subnet_id":"subnet_id",
    }
    
class PublicIPAddress(pb_classes.Message):
    """
    Describes a public IP address.
    """
    
    __PB2_CLASS__ = node_group_pb2.PublicIPAddress
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.PublicIPAddress",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class AttachedFilesystemSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.AttachedFilesystemSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.AttachedFilesystemSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class AttachMode(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1.AttachedFilesystemSpec.AttachMode",node_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        READ_ONLY = 1
        READ_WRITE = 2
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "AttachedFilesystemSpec") -> None:
            super().__init__()
            self._message: "AttachedFilesystemSpec" = msg
    
    class __OneOfClass_type_existing_filesystem__(__OneOfClass_type__):
        field: typing.Literal["existing_filesystem"] = "existing_filesystem"
        
        def __init__(self, msg: "AttachedFilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ExistingFilesystem":
            return self._message.existing_filesystem
    
    @builtins.property
    def type(self) -> __OneOfClass_type_existing_filesystem__|None:
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "existing_filesystem":
                return self.__OneOfClass_type_existing_filesystem__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        attach_mode: "AttachedFilesystemSpec.AttachMode|node_group_pb2.AttachedFilesystemSpec.AttachMode|None|unset.UnsetType" = unset.Unset,
        mount_tag: "builtins.str|None|unset.UnsetType" = unset.Unset,
        existing_filesystem: "ExistingFilesystem|node_group_pb2.ExistingFilesystem|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(attach_mode, unset.UnsetType):
            self.attach_mode = attach_mode
        if not isinstance(mount_tag, unset.UnsetType):
            self.mount_tag = mount_tag
        if not isinstance(existing_filesystem, unset.UnsetType):
            self.existing_filesystem = existing_filesystem
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "attach_mode",
            "mount_tag",
            "existing_filesystem",
            "type",
            "AttachMode",
        ]
    
    @builtins.property
    def attach_mode(self) -> "AttachedFilesystemSpec.AttachMode":
        return super()._get_field("attach_mode", explicit_presence=False,
        wrap=AttachedFilesystemSpec.AttachMode,
        )
    @attach_mode.setter
    def attach_mode(self, value: "AttachedFilesystemSpec.AttachMode|node_group_pb2.AttachedFilesystemSpec.AttachMode|None") -> None:
        return super()._set_field("attach_mode",value,explicit_presence=False,
        )
    
    @builtins.property
    def mount_tag(self) -> "builtins.str":
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        
        return super()._get_field("mount_tag", explicit_presence=False,
        )
    @mount_tag.setter
    def mount_tag(self, value: "builtins.str|None") -> None:
        return super()._set_field("mount_tag",value,explicit_presence=False,
        )
    
    @builtins.property
    def existing_filesystem(self) -> "ExistingFilesystem|None":
        return super()._get_field("existing_filesystem", explicit_presence=True,
        wrap=ExistingFilesystem,
        )
    @existing_filesystem.setter
    def existing_filesystem(self, value: "ExistingFilesystem|node_group_pb2.ExistingFilesystem|None") -> None:
        return super()._set_field("existing_filesystem",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "attach_mode":"attach_mode",
        "mount_tag":"mount_tag",
        "existing_filesystem":"existing_filesystem",
        "type":"type",
        "AttachMode":"AttachMode",
    }
    
class ExistingFilesystem(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.ExistingFilesystem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ExistingFilesystem",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class NodeGroupAutoscalingSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupAutoscalingSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroupAutoscalingSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        min_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        max_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(min_node_count, unset.UnsetType):
            self.min_node_count = min_node_count
        if not isinstance(max_node_count, unset.UnsetType):
            self.max_node_count = max_node_count
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "min_node_count",
            "max_node_count",
        ]
    
    @builtins.property
    def min_node_count(self) -> "builtins.int":
        return super()._get_field("min_node_count", explicit_presence=False,
        )
    @min_node_count.setter
    def min_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("min_node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def max_node_count(self) -> "builtins.int":
        return super()._get_field("max_node_count", explicit_presence=False,
        )
    @max_node_count.setter
    def max_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("max_node_count",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "min_node_count":"min_node_count",
        "max_node_count":"max_node_count",
    }
    
class NodeTaint(pb_classes.Message):
    """
    See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    """
    
    __PB2_CLASS__ = node_group_pb2.NodeTaint
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeTaint",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class Effect(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1.NodeTaint.Effect",node_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        EFFECT_UNSPECIFIED = 0
        NO_EXECUTE = 1
        NO_SCHEDULE = 2
        PREFER_NO_SCHEDULE = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        key: "builtins.str|None|unset.UnsetType" = unset.Unset,
        value: "builtins.str|None|unset.UnsetType" = unset.Unset,
        effect: "NodeTaint.Effect|node_group_pb2.NodeTaint.Effect|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(key, unset.UnsetType):
            self.key = key
        if not isinstance(value, unset.UnsetType):
            self.value = value
        if not isinstance(effect, unset.UnsetType):
            self.effect = effect
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "key",
            "value",
            "effect",
            "Effect",
        ]
    
    @builtins.property
    def key(self) -> "builtins.str":
        return super()._get_field("key", explicit_presence=False,
        )
    @key.setter
    def key(self, value: "builtins.str|None") -> None:
        return super()._set_field("key",value,explicit_presence=False,
        )
    
    @builtins.property
    def value(self) -> "builtins.str":
        return super()._get_field("value", explicit_presence=False,
        )
    @value.setter
    def value(self, value: "builtins.str|None") -> None:
        return super()._set_field("value",value,explicit_presence=False,
        )
    
    @builtins.property
    def effect(self) -> "NodeTaint.Effect":
        return super()._get_field("effect", explicit_presence=False,
        wrap=NodeTaint.Effect,
        )
    @effect.setter
    def effect(self, value: "NodeTaint.Effect|node_group_pb2.NodeTaint.Effect|None") -> None:
        return super()._set_field("effect",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "key":"key",
        "value":"value",
        "effect":"effect",
        "Effect":"Effect",
    }
    
class NodeGroupDeploymentStrategy(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupDeploymentStrategy
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroupDeploymentStrategy",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "drain_timeout": well_known_1.duration_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        max_unavailable: "PercentOrCount|node_group_pb2.PercentOrCount|None|unset.UnsetType" = unset.Unset,
        max_surge: "PercentOrCount|node_group_pb2.PercentOrCount|None|unset.UnsetType" = unset.Unset,
        drain_timeout: "duration_pb2.Duration|datetime.timedelta|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(max_unavailable, unset.UnsetType):
            self.max_unavailable = max_unavailable
        if not isinstance(max_surge, unset.UnsetType):
            self.max_surge = max_surge
        if not isinstance(drain_timeout, unset.UnsetType):
            self.drain_timeout = drain_timeout
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "max_unavailable",
            "max_surge",
            "drain_timeout",
        ]
    
    @builtins.property
    def max_unavailable(self) -> "PercentOrCount":
        """
        The maximum number of nodes that can be simultaneously unavailable during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
        This value cannot be 0 if ``max_surge`` is also set to 0.
        Defaults to 0.
        Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
        ensuring that at least 80% of the desired nodes remain operational.
        """
        
        return super()._get_field("max_unavailable", explicit_presence=False,
        wrap=PercentOrCount,
        )
    @max_unavailable.setter
    def max_unavailable(self, value: "PercentOrCount|node_group_pb2.PercentOrCount|None") -> None:
        return super()._set_field("max_unavailable",value,explicit_presence=False,
        )
    
    @builtins.property
    def max_surge(self) -> "PercentOrCount":
        """
        The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
        This value cannot be 0 if ``max_unavailable`` is also set to 0.
        Defaults to 1.
        Example: If set to 25%, the node group can scale up by an additional 25% during the update,
        allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
        NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
          Available quota effectively limits ``max_surge``.
          In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
          Such error will be visible in Operation.progress_data.
        """
        
        return super()._get_field("max_surge", explicit_presence=False,
        wrap=PercentOrCount,
        )
    @max_surge.setter
    def max_surge(self, value: "PercentOrCount|node_group_pb2.PercentOrCount|None") -> None:
        return super()._set_field("max_surge",value,explicit_presence=False,
        )
    
    @builtins.property
    def drain_timeout(self) -> "datetime.timedelta":
        """
        Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
        falling back to pod deletion.
        By default, node can be drained unlimited time.
        Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
        then NodeGroup update with node re-creation will hung on that pod eviction.
        Note, that it is different from ``kubectl drain --timeout``
        """
        
        return super()._get_field("drain_timeout", explicit_presence=False,
        wrap=well_known_1.from_duration
        )
    @drain_timeout.setter
    def drain_timeout(self, value: "duration_pb2.Duration|datetime.timedelta|None") -> None:
        return super()._set_field("drain_timeout",value,explicit_presence=False,
        unwrap=well_known_1.to_duration
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "max_unavailable":"max_unavailable",
        "max_surge":"max_surge",
        "drain_timeout":"drain_timeout",
    }
    
class PercentOrCount(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.PercentOrCount
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.PercentOrCount",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_value__(pb_classes.OneOf):
        name: builtins.str= "value"
        
        def __init__(self, msg: "PercentOrCount") -> None:
            super().__init__()
            self._message: "PercentOrCount" = msg
    
    class __OneOfClass_value_percent__(__OneOfClass_value__):
        field: typing.Literal["percent"] = "percent"
        
        def __init__(self, msg: "PercentOrCount") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.percent
    
    class __OneOfClass_value_count__(__OneOfClass_value__):
        field: typing.Literal["count"] = "count"
        
        def __init__(self, msg: "PercentOrCount") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.count
    
    @builtins.property
    def value(self) -> __OneOfClass_value_percent__|__OneOfClass_value_count__|None:
        field_name_1: str|None = super().which_field_in_oneof("value")
        match field_name_1:
            case "percent":
                return self.__OneOfClass_value_percent__(self)
            case "count":
                return self.__OneOfClass_value_count__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        percent: "builtins.int|None|unset.UnsetType" = unset.Unset,
        count: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(percent, unset.UnsetType):
            self.percent = percent
        if not isinstance(count, unset.UnsetType):
            self.count = count
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "percent",
            "count",
            "value",
        ]
    
    @builtins.property
    def percent(self) -> "builtins.int|None":
        return super()._get_field("percent", explicit_presence=True,
        )
    @percent.setter
    def percent(self, value: "builtins.int|None") -> None:
        return super()._set_field("percent",value,explicit_presence=True,
        )
    
    @builtins.property
    def count(self) -> "builtins.int|None":
        return super()._get_field("count", explicit_presence=True,
        )
    @count.setter
    def count(self, value: "builtins.int|None") -> None:
        return super()._set_field("count",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "percent":"percent",
        "count":"count",
        "value":"value",
    }
    
class NodeGroupAutoRepairSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupAutoRepairSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroupAutoRepairSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        conditions: "abc.Iterable[NodeAutoRepairCondition]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(conditions, unset.UnsetType):
            self.conditions = conditions
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "conditions",
        ]
    
    @builtins.property
    def conditions(self) -> "abc.MutableSequence[NodeAutoRepairCondition]":
        """
        Conditions that determine whether a node should be auto repaired.
        """
        
        return super()._get_field("conditions", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NodeAutoRepairCondition,None,None),
        )
    @conditions.setter
    def conditions(self, value: "abc.Iterable[NodeAutoRepairCondition]|None") -> None:
        return super()._set_field("conditions",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "conditions":"conditions",
    }
    
class NodeAutoRepairCondition(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeAutoRepairCondition
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeAutoRepairCondition",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "timeout": well_known_1.duration_mask,
    }
    
    class __OneOfClass_trigger__(pb_classes.OneOf):
        name: builtins.str= "trigger"
        
        def __init__(self, msg: "NodeAutoRepairCondition") -> None:
            super().__init__()
            self._message: "NodeAutoRepairCondition" = msg
    
    class __OneOfClass_trigger_timeout__(__OneOfClass_trigger__):
        field: typing.Literal["timeout"] = "timeout"
        
        def __init__(self, msg: "NodeAutoRepairCondition") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "datetime.timedelta":
            return self._message.timeout
    
    class __OneOfClass_trigger_disabled__(__OneOfClass_trigger__):
        field: typing.Literal["disabled"] = "disabled"
        
        def __init__(self, msg: "NodeAutoRepairCondition") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.bool":
            return self._message.disabled
    
    @builtins.property
    def trigger(self) -> __OneOfClass_trigger_timeout__|__OneOfClass_trigger_disabled__|None:
        field_name_1: str|None = super().which_field_in_oneof("trigger")
        match field_name_1:
            case "timeout":
                return self.__OneOfClass_trigger_timeout__(self)
            case "disabled":
                return self.__OneOfClass_trigger_disabled__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        status: "ConditionStatus|node_group_pb2.ConditionStatus|None|unset.UnsetType" = unset.Unset,
        timeout: "duration_pb2.Duration|datetime.timedelta|None|unset.UnsetType" = unset.Unset,
        disabled: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(type, unset.UnsetType):
            self.type = type
        if not isinstance(status, unset.UnsetType):
            self.status = status
        if not isinstance(timeout, unset.UnsetType):
            self.timeout = timeout
        if not isinstance(disabled, unset.UnsetType):
            self.disabled = disabled
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "type",
            "status",
            "timeout",
            "disabled",
            "trigger",
        ]
    
    @builtins.property
    def type(self) -> "builtins.str":
        """
        Node condition type.
        """
        
        return super()._get_field("type", explicit_presence=False,
        )
    @type.setter
    def type(self, value: "builtins.str|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ConditionStatus":
        """
        Node condition status.
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=ConditionStatus,
        )
    @status.setter
    def status(self, value: "ConditionStatus|node_group_pb2.ConditionStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    @builtins.property
    def timeout(self) -> "datetime.timedelta|None":
        """
        The duration after which the node is automatically repaired if the condition remains in the specified status.
        """
        
        return super()._get_field("timeout", explicit_presence=True,
        wrap=well_known_1.from_duration
        )
    @timeout.setter
    def timeout(self, value: "duration_pb2.Duration|datetime.timedelta|None") -> None:
        return super()._set_field("timeout",value,explicit_presence=True,
        unwrap=well_known_1.to_duration
        )
    
    @builtins.property
    def disabled(self) -> "builtins.bool|None":
        """
        When true, disables the default auto-repair condition rules.
        """
        
        return super()._get_field("disabled", explicit_presence=True,
        )
    @disabled.setter
    def disabled(self, value: "builtins.bool|None") -> None:
        return super()._set_field("disabled",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "type":"type",
        "status":"status",
        "timeout":"timeout",
        "disabled":"disabled",
        "trigger":"trigger",
    }
    
class PreemptibleSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.PreemptibleSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.PreemptibleSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class NodeGroupStatus(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroupStatus",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1.NodeGroupStatus.State",node_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        PROVISIONING = 1
        RUNNING = 2
        DELETING = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "NodeGroupStatus.State|node_group_pb2.NodeGroupStatus.State|None|unset.UnsetType" = unset.Unset,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        target_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        outdated_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        ready_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        events: "abc.Iterable[v1_1.RecurrentResourceEvent]|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(target_node_count, unset.UnsetType):
            self.target_node_count = target_node_count
        if not isinstance(node_count, unset.UnsetType):
            self.node_count = node_count
        if not isinstance(outdated_node_count, unset.UnsetType):
            self.outdated_node_count = outdated_node_count
        if not isinstance(ready_node_count, unset.UnsetType):
            self.ready_node_count = ready_node_count
        if not isinstance(events, unset.UnsetType):
            self.events = events
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "version",
            "target_node_count",
            "node_count",
            "outdated_node_count",
            "ready_node_count",
            "events",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "NodeGroupStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=NodeGroupStatus.State,
        )
    @state.setter
    def state(self, value: "NodeGroupStatus.State|node_group_pb2.NodeGroupStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        .. role:: raw-html-m2r(raw)
           :format: html
        
        
        Actual version of NodeGroup. Have format ``<major>.<minor>.<patch>-nebius-node.<infra_version>`` like "1.30.0-nebius-node.10".
        Where :raw-html-m2r:`<major>`.\\ :raw-html-m2r:`<minor>`.\\ :raw-html-m2r:`<patch>` is Kubernetes version and :raw-html-m2r:`<infra_version>` is version of Node infrastructure and configuration,
        which update may include bug fixes, security updates and new features depending on worker node configuration.
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def target_node_count(self) -> "builtins.int":
        """
        Desired total number of nodes that should be in the node group.
        It is either ``NodeGroupSpec.fixed_node_count`` or arbitrary number between
        ``NodeGroupAutoscalingSpec.min_node_count`` and ``NodeGroupAutoscalingSpec.max_node_count`` decided by autoscaler.
        """
        
        return super()._get_field("target_node_count", explicit_presence=False,
        )
    @target_node_count.setter
    def target_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("target_node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def node_count(self) -> "builtins.int":
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        
        return super()._get_field("node_count", explicit_presence=False,
        )
    @node_count.setter
    def node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def outdated_node_count(self) -> "builtins.int":
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        
        return super()._get_field("outdated_node_count", explicit_presence=False,
        )
    @outdated_node_count.setter
    def outdated_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("outdated_node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def ready_node_count(self) -> "builtins.int":
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        
        return super()._get_field("ready_node_count", explicit_presence=False,
        )
    @ready_node_count.setter
    def ready_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("ready_node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def events(self) -> "abc.MutableSequence[v1_1.RecurrentResourceEvent]":
        return super()._get_field("events", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(v1_1.RecurrentResourceEvent,None,None),
        )
    @events.setter
    def events(self, value: "abc.Iterable[v1_1.RecurrentResourceEvent]|None") -> None:
        return super()._set_field("events",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Show that there are changes are in flight.
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "version":"version",
        "target_node_count":"target_node_count",
        "node_count":"node_count",
        "outdated_node_count":"outdated_node_count",
        "ready_node_count":"ready_node_count",
        "events":"events",
        "reconciling":"reconciling",
        "State":"State",
    }
    
# file: nebius/mk8s/v1/node_group_service.proto
class GetNodeGroupCompatibilityMatrixRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.GetNodeGroupCompatibilityMatrixRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.GetNodeGroupCompatibilityMatrixRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cluster_kubernetes_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        platform: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cluster_kubernetes_version, unset.UnsetType):
            self.cluster_kubernetes_version = cluster_kubernetes_version
        if not isinstance(platform, unset.UnsetType):
            self.platform = platform
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cluster_kubernetes_version",
            "platform",
        ]
    
    @builtins.property
    def cluster_kubernetes_version(self) -> "builtins.str":
        """
        Cluster kubernetes version.
        """
        
        return super()._get_field("cluster_kubernetes_version", explicit_presence=False,
        )
    @cluster_kubernetes_version.setter
    def cluster_kubernetes_version(self, value: "builtins.str|None") -> None:
        return super()._set_field("cluster_kubernetes_version",value,explicit_presence=False,
        )
    
    @builtins.property
    def platform(self) -> "builtins.str":
        """
        Hardware platform for which the capabilities are requested.
        """
        
        return super()._get_field("platform", explicit_presence=False,
        )
    @platform.setter
    def platform(self, value: "builtins.str|None") -> None:
        return super()._set_field("platform",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cluster_kubernetes_version":"cluster_kubernetes_version",
        "platform":"platform",
    }
    
class NodeGroupCompatibilityMatrix(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.NodeGroupCompatibilityMatrix
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroupCompatibilityMatrix",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        versions: "abc.Iterable[NodeGroupCompatibilityVersion]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(versions, unset.UnsetType):
            self.versions = versions
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "versions",
        ]
    
    @builtins.property
    def versions(self) -> "abc.MutableSequence[NodeGroupCompatibilityVersion]":
        """
        List of available versions.
        """
        
        return super()._get_field("versions", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NodeGroupCompatibilityVersion,None,None),
        )
    @versions.setter
    def versions(self, value: "abc.Iterable[NodeGroupCompatibilityVersion]|None") -> None:
        return super()._set_field("versions",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "versions":"versions",
    }
    
class NodeGroupCompatibilityVersion(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.NodeGroupCompatibilityVersion
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroupCompatibilityVersion",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        kubernetes_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        items: "abc.Iterable[NodeGroupCompatibilityVersionItem]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(kubernetes_version, unset.UnsetType):
            self.kubernetes_version = kubernetes_version
        if not isinstance(items, unset.UnsetType):
            self.items = items
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "kubernetes_version",
            "items",
        ]
    
    @builtins.property
    def kubernetes_version(self) -> "builtins.str":
        """
        Kubernetes version.
        """
        
        return super()._get_field("kubernetes_version", explicit_presence=False,
        )
    @kubernetes_version.setter
    def kubernetes_version(self, value: "builtins.str|None") -> None:
        return super()._set_field("kubernetes_version",value,explicit_presence=False,
        )
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[NodeGroupCompatibilityVersionItem]":
        """
        List of available images.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NodeGroupCompatibilityVersionItem,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[NodeGroupCompatibilityVersionItem]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "kubernetes_version":"kubernetes_version",
        "items":"items",
    }
    
class NodeGroupCompatibilityVersionItem(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.NodeGroupCompatibilityVersionItem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.NodeGroupCompatibilityVersionItem",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        os: "builtins.str|None|unset.UnsetType" = unset.Unset,
        drivers_preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
        compatible_platforms: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(os, unset.UnsetType):
            self.os = os
        if not isinstance(drivers_preset, unset.UnsetType):
            self.drivers_preset = drivers_preset
        if not isinstance(compatible_platforms, unset.UnsetType):
            self.compatible_platforms = compatible_platforms
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "os",
            "drivers_preset",
            "compatible_platforms",
        ]
    
    @builtins.property
    def os(self) -> "builtins.str":
        """
        Operating system.
        """
        
        return super()._get_field("os", explicit_presence=False,
        )
    @os.setter
    def os(self, value: "builtins.str|None") -> None:
        return super()._set_field("os",value,explicit_presence=False,
        )
    
    @builtins.property
    def drivers_preset(self) -> "builtins.str":
        """
        Drivers preset name.
        """
        
        return super()._get_field("drivers_preset", explicit_presence=False,
        )
    @drivers_preset.setter
    def drivers_preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("drivers_preset",value,explicit_presence=False,
        )
    
    @builtins.property
    def compatible_platforms(self) -> "abc.MutableSequence[builtins.str]":
        """
        Hardware platforms.
        """
        
        return super()._get_field("compatible_platforms", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @compatible_platforms.setter
    def compatible_platforms(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("compatible_platforms",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "os":"os",
        "drivers_preset":"drivers_preset",
        "compatible_platforms":"compatible_platforms",
    }
    
class CreateNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.CreateNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.CreateNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "NodeGroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=NodeGroupSpec,
        )
    @spec.setter
    def spec(self, value: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.GetNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.GetNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(resource_version, unset.UnsetType):
            self.resource_version = resource_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "resource_version",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_version(self) -> "builtins.str":
        return super()._get_field("resource_version", explicit_presence=False,
        )
    @resource_version.setter
    def resource_version(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "resource_version":"resource_version",
    }
    
class ListNodeGroupsRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.ListNodeGroupsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ListNodeGroupsRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        ID of the parent Cluster.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListNodeGroupsResponse(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.ListNodeGroupsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ListNodeGroupsResponse",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[NodeGroup]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[NodeGroup]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NodeGroup,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[NodeGroup]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class UpdateNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.UpdateNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.UpdateNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "NodeGroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=NodeGroupSpec,
        )
    @spec.setter
    def spec(self, value: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.DeleteNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.DeleteNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UpgradeNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.UpgradeNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.UpgradeNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_upgrade_type__(pb_classes.OneOf):
        name: builtins.str= "upgrade_type"
        
        def __init__(self, msg: "UpgradeNodeGroupRequest") -> None:
            super().__init__()
            self._message: "UpgradeNodeGroupRequest" = msg
    
    class __OneOfClass_upgrade_type_latest_infra_version__(__OneOfClass_upgrade_type__):
        field: typing.Literal["latest_infra_version"] = "latest_infra_version"
        
        def __init__(self, msg: "UpgradeNodeGroupRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "empty_pb2.Empty":
            return self._message.latest_infra_version
    
    @builtins.property
    def upgrade_type(self) -> __OneOfClass_upgrade_type_latest_infra_version__|None:
        field_name_1: str|None = super().which_field_in_oneof("upgrade_type")
        match field_name_1:
            case "latest_infra_version":
                return self.__OneOfClass_upgrade_type_latest_infra_version__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        latest_infra_version: "empty_pb2.Empty|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(latest_infra_version, unset.UnsetType):
            self.latest_infra_version = latest_infra_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "latest_infra_version",
            "upgrade_type",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def latest_infra_version(self) -> "empty_pb2.Empty|None":
        """
        Upgrades to the latest infra version, which includes latest supported kubernetes patch version. Kubernetes minor version remain the same.
        """
        
        return super()._get_field("latest_infra_version", explicit_presence=True,
        )
    @latest_infra_version.setter
    def latest_infra_version(self, value: "empty_pb2.Empty|None") -> None:
        return super()._set_field("latest_infra_version",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "latest_infra_version":"latest_infra_version",
        "upgrade_type":"upgrade_type",
    }
    

class NodeGroupServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.mk8s.v1.NodeGroupService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.mk8s.v1.NodeGroupService",node_group_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.mk8s.v1.NodeGroupService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetNodeGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetNodeGroupRequest","NodeGroup"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.GetNodeGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1.NodeGroup`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=node_group_pb2.NodeGroup,
            result_wrapper=pb_classes.simple_wrapper(NodeGroup),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["v1_1.GetByNameRequest","NodeGroup"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1.NodeGroup`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=node_group_pb2.NodeGroup,
            result_wrapper=pb_classes.simple_wrapper(NodeGroup),
            **kwargs,
        )
    
    def list(self,
        request: "ListNodeGroupsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListNodeGroupsRequest","ListNodeGroupsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.ListNodeGroupsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1.ListNodeGroupsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=node_group_service_pb2.ListNodeGroupsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListNodeGroupsResponse),
            **kwargs,
        )
    
    def create(self,
        request: "CreateNodeGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateNodeGroupRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.CreateNodeGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def update(self,
        request: "UpdateNodeGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateNodeGroupRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.UpdateNodeGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteNodeGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteNodeGroupRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.DeleteNodeGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def upgrade(self,
        request: "UpgradeNodeGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpgradeNodeGroupRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.UpgradeNodeGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Upgrade",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def get_compatibility_matrix(self,
        request: "GetNodeGroupCompatibilityMatrixRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetNodeGroupCompatibilityMatrixRequest","NodeGroupCompatibilityMatrix"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1.GetNodeGroupCompatibilityMatrixRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1.NodeGroupCompatibilityMatrix`.
        """
        
        return super().request(
            method="GetCompatibilityMatrix",
            request=request,
            result_pb2_class=node_group_service_pb2.NodeGroupCompatibilityMatrix,
            result_wrapper=pb_classes.simple_wrapper(NodeGroupCompatibilityMatrix),
            **kwargs,
        )
    

# file: nebius/mk8s/v1/progress_data.proto
class ProgressData(pb_classes.Message):
    __PB2_CLASS__ = progress_data_pb2.ProgressData
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.ProgressData",progress_data_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        problems: "abc.Iterable[Problem]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(problems, unset.UnsetType):
            self.problems = problems
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "problems",
        ]
    
    @builtins.property
    def problems(self) -> "abc.MutableSequence[Problem]":
        """
        Problems encountered during the operation execution.
        """
        
        return super()._get_field("problems", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Problem,None,None),
        )
    @problems.setter
    def problems(self, value: "abc.Iterable[Problem]|None") -> None:
        return super()._set_field("problems",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "problems":"problems",
    }
    
class Problem(pb_classes.Message):
    __PB2_CLASS__ = progress_data_pb2.Problem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1.Problem",progress_data_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        stage: "builtins.str|None|unset.UnsetType" = unset.Unset,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(stage, unset.UnsetType):
            self.stage = stage
        if not isinstance(message, unset.UnsetType):
            self.message = message
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "stage",
            "message",
        ]
    
    @builtins.property
    def stage(self) -> "builtins.str":
        """
        Stage on which the problem occurred.
        """
        
        return super()._get_field("stage", explicit_presence=False,
        )
    @stage.setter
    def stage(self, value: "builtins.str|None") -> None:
        return super()._set_field("stage",value,explicit_presence=False,
        )
    
    @builtins.property
    def message(self) -> "builtins.str":
        """
        Message describing the problem.
        """
        
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "stage":"stage",
        "message":"message",
    }
    
__all__ = [
    #@ local import names here @#
    "Cluster",
    "ClusterSpec",
    "ControlPlaneSpec",
    "ControlPlaneEndpointsSpec",
    "PublicEndpointSpec",
    "KubeNetworkSpec",
    "ClusterStatus",
    "ControlPlaneStatus",
    "ControlPlaneStatusEndpoints",
    "ControlPlaneStatusAuth",
    "CreateClusterRequest",
    "GetClusterRequest",
    "ListClustersRequest",
    "ListClustersResponse",
    "UpdateClusterRequest",
    "DeleteClusterRequest",
    "ListClusterControlPlaneVersionsRequest",
    "ListClusterControlPlaneVersionsResponse",
    "ClusterControlPlaneVersion",
    "ClusterServiceClient",
    "DiskSpec",
    "ResourcesSpec",
    "ConditionStatus",
    "NodeGroup",
    "NodeGroupSpec",
    "NodeTemplate",
    "NodeMetadataTemplate",
    "GpuSettings",
    "GpuClusterSpec",
    "NetworkInterfaceTemplate",
    "PublicIPAddress",
    "AttachedFilesystemSpec",
    "ExistingFilesystem",
    "NodeGroupAutoscalingSpec",
    "NodeTaint",
    "NodeGroupDeploymentStrategy",
    "PercentOrCount",
    "NodeGroupAutoRepairSpec",
    "NodeAutoRepairCondition",
    "PreemptibleSpec",
    "NodeGroupStatus",
    "GetNodeGroupCompatibilityMatrixRequest",
    "NodeGroupCompatibilityMatrix",
    "NodeGroupCompatibilityVersion",
    "NodeGroupCompatibilityVersionItem",
    "CreateNodeGroupRequest",
    "GetNodeGroupRequest",
    "ListNodeGroupsRequest",
    "ListNodeGroupsResponse",
    "UpdateNodeGroupRequest",
    "DeleteNodeGroupRequest",
    "UpgradeNodeGroupRequest",
    "NodeGroupServiceClient",
    "ProgressData",
    "Problem",
]
