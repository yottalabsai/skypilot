# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.dns.v1``"""

import builtins as builtins
import collections.abc as abc
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import nebius.aio.client as client
import nebius.aio.request as request
import nebius.aio.request_kwargs as request_kwargs
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.dns.v1.record_pb2 as record_pb2
import nebius.api.nebius.dns.v1.record_service_pb2 as record_service_pb2
import nebius.api.nebius.dns.v1.zone_pb2 as zone_pb2
import nebius.api.nebius.dns.v1.zone_service_pb2 as zone_service_pb2
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import typing as typing
import typing_extensions as typing_extensions
#@ local imports here @#

# file: nebius/dns/v1/record.proto
class Record(pb_classes.Message):
    """
    API Resource: DNS *Resource Record* (RR), an information entry about a specific domain
    
    Each record is contained within a DNS zone, which is a container for DNS data of a specific domain, and, possibly, its subdomains
    DNS zones are represented in this API by the ``Zone`` API Resource which is managed by the ``ZoneService``
    """
    
    __PB2_CLASS__ = record_pb2.Record
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.Record",record_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "RecordSpec|record_pb2.RecordSpec|None|unset.UnsetType" = unset.Unset,
        status: "RecordStatus|record_pb2.RecordStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        DNS record metadata
        ``metadata.parent_id`` must be a DNS zone ID
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "RecordSpec":
        """
        DNS record specification, including its relative name, type, data and TTL
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=RecordSpec,
        )
    @spec.setter
    def spec(self, value: "RecordSpec|record_pb2.RecordSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "RecordStatus":
        """
        DNS record status, including e.g. its effective FQDN (fully-qualified domain name)
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=RecordStatus,
        )
    @status.setter
    def status(self, value: "RecordStatus|record_pb2.RecordStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class RecordSpec(pb_classes.Message):
    """
    DNS record specification
    """
    
    __PB2_CLASS__ = record_pb2.RecordSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.RecordSpec",record_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class RecordType(pb_enum.Enum):
        """
        DNS Record type
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.dns.v1.RecordSpec.RecordType",record_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        RECORD_TYPE_UNSPECIFIED = 0
        """
        Record type is not specified
        """
        
        A = 1
        """
        ``A`` record: IPv4 address
        """
        
        AAAA = 2
        """
        ``AAAA`` record: IPv6 address
        """
        
        PTR = 3
        """
        ``PTR`` record: mapping from IP address to a domain name
        """
        
        CNAME = 4
        """
        ``CNAME`` record: an alias for a *canonical domain name*
        """
        
        MX = 5
        """
        ``MX`` record: mail server information (domain name, priority)
        """
        
        TXT = 6
        """
        ``TXT`` record: text data, typically used to verify e-mail addresses, websites and TLS certificates
        """
        
        SRV = 7
        """
        ``SRV`` record: information about a network service (domain name, port, weight)
        """
        
        NS = 8
        """
        ``NS`` record: domain name of an authoritative nameserver for this DNS zone, or one of its subzones
        """
        
        SOA = 9
        """
        ``SOA`` record: administrative information about this DNS zone
        """
        
        CAA = 10
        """
        ``CAA`` record: certificate issuance settings for this DNS zone and its subzones
        """
        
        SVCB = 11
        """
        ``SVCB`` record: service binding. See `RFC 9460, section 2.3 <https://www.rfc-editor.org/rfc/rfc9460.html#section-2.3>`_
        """
        
        HTTPS = 12
        """
        ``HTTPS`` record: service binding with HTTPS protocol configuration. See `RFC 9460, section 9.1 <https://www.rfc-editor.org/rfc/rfc9460.html#section-9.1>`_
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        relative_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        type: "RecordSpec.RecordType|record_pb2.RecordSpec.RecordType|None|unset.UnsetType" = unset.Unset,
        ttl: "builtins.int|None|unset.UnsetType" = unset.Unset,
        data: "builtins.str|None|unset.UnsetType" = unset.Unset,
        deletion_protection: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(relative_name, unset.UnsetType):
            self.relative_name = relative_name
        if not isinstance(type, unset.UnsetType):
            self.type = type
        if not isinstance(ttl, unset.UnsetType):
            self.ttl = ttl
        if not isinstance(data, unset.UnsetType):
            self.data = data
        if not isinstance(deletion_protection, unset.UnsetType):
            self.deletion_protection = deletion_protection
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "relative_name",
            "type",
            "ttl",
            "data",
            "deletion_protection",
            "RecordType",
        ]
    
    @builtins.property
    def relative_name(self) -> "builtins.str":
        """
        Zone-relative name of this record (e.g., ``www`` for ``www.<parent zone's domain name>``\\ )
        Use ``@`` for records in zone apex (that is, records that have the same domain name as the zone itself)
        To see the resolved absolute domain name, see ``Record.status.effective_fqdn``
        """
        
        return super()._get_field("relative_name", explicit_presence=False,
        )
    @relative_name.setter
    def relative_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("relative_name",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "RecordSpec.RecordType":
        """
        Record type
        """
        
        return super()._get_field("type", explicit_presence=False,
        wrap=RecordSpec.RecordType,
        )
    @type.setter
    def type(self, value: "RecordSpec.RecordType|record_pb2.RecordSpec.RecordType|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    @builtins.property
    def ttl(self) -> "builtins.int":
        """
        Record TTL. If absent or negative, will be assumed to be the default value (\\ ``600``\\ )
        """
        
        return super()._get_field("ttl", explicit_presence=False,
        )
    @ttl.setter
    def ttl(self, value: "builtins.int|None") -> None:
        return super()._set_field("ttl",value,explicit_presence=False,
        )
    
    @builtins.property
    def data(self) -> "builtins.str":
        """
        Record data in text format
        
        This should be the RDATA part of this Resource Record's `presentation (zonefile) format <https://datatracker.ietf.org/doc/html/rfc9499#name-resource-records>`_. E.g., ``10 xyz.tuv`` for a ``@ 600 IN MX 10 xyz.tuv.`` resource record in a zonefile
        """
        
        return super()._get_field("data", explicit_presence=False,
        )
    @data.setter
    def data(self, value: "builtins.str|None") -> None:
        return super()._set_field("data",value,explicit_presence=False,
        )
    
    @builtins.property
    def deletion_protection(self) -> "builtins.bool":
        """
        Mark this record as delete-protected
        Delete-protected records can *only* be deleted by explicitly calling ``RecordService/Delete`` API with ``force`` flag set to ``true``
        """
        
        return super()._get_field("deletion_protection", explicit_presence=False,
        )
    @deletion_protection.setter
    def deletion_protection(self, value: "builtins.bool|None") -> None:
        return super()._set_field("deletion_protection",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "relative_name":"relative_name",
        "type":"type",
        "ttl":"ttl",
        "data":"data",
        "deletion_protection":"deletion_protection",
        "RecordType":"RecordType",
    }
    
class RecordStatus(pb_classes.Message):
    """
    DNS record status
    """
    
    __PB2_CLASS__ = record_pb2.RecordStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.RecordStatus",record_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        zone_domain_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        effective_fqdn: "builtins.str|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(zone_domain_name, unset.UnsetType):
            self.zone_domain_name = zone_domain_name
        if not isinstance(effective_fqdn, unset.UnsetType):
            self.effective_fqdn = effective_fqdn
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "zone_domain_name",
            "effective_fqdn",
            "reconciling",
        ]
    
    @builtins.property
    def zone_domain_name(self) -> "builtins.str":
        """
        Domain name of this record's parent zone including ``.`` at the end, e.g. ``example.com.``
        """
        
        return super()._get_field("zone_domain_name", explicit_presence=False,
        )
    @zone_domain_name.setter
    def zone_domain_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("zone_domain_name",value,explicit_presence=False,
        )
    
    @builtins.property
    def effective_fqdn(self) -> "builtins.str":
        """
        Fully-qualified domain name of this record including ``.`` at the end, e.g. ``www.example.com.``
        """
        
        return super()._get_field("effective_fqdn", explicit_presence=False,
        )
    @effective_fqdn.setter
    def effective_fqdn(self, value: "builtins.str|None") -> None:
        return super()._set_field("effective_fqdn",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is a running Operation for this Record
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "zone_domain_name":"zone_domain_name",
        "effective_fqdn":"effective_fqdn",
        "reconciling":"reconciling",
    }
    
class GetRecordRequest(pb_classes.Message):
    """
    Request to get the DNS record by its ID and, optionally, its resource version
    """
    
    __PB2_CLASS__ = record_pb2.GetRecordRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.GetRecordRequest",record_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_version: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(resource_version, unset.UnsetType):
            self.resource_version = resource_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "resource_version",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Record ID
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_version(self) -> "builtins.int":
        """
        Optional: expected record version (\\ ``metadata.resource_version``\\ )
        
        
        * If specified, the requested version will be returned if possible (if the version has changed, you will get a ``FAILED_PRECONDITION`` error)
        * If not specified or set to ``0``\\ , the latest version will be returned
        """
        
        return super()._get_field("resource_version", explicit_presence=False,
        )
    @resource_version.setter
    def resource_version(self, value: "builtins.int|None") -> None:
        return super()._set_field("resource_version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "resource_version":"resource_version",
    }
    
class ListRecordsRequest(pb_classes.Message):
    """
    Request to list DNS records in the specified parent DNS zone
    """
    
    __PB2_CLASS__ = record_pb2.ListRecordsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.ListRecordsRequest",record_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Parent DNS zone ID
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Page size
        If not specified or set to ``0``\\ , a default page size of ``100`` will be used
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        An opaque listing continuation token
        
        
        * If not specified or empty, the first page of results will be returned
        * If specified, the next page of results (as identified by the token) will be returned
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListRecordsResponse(pb_classes.Message):
    """
    Response with a single page of DNS record listing results
    """
    
    __PB2_CLASS__ = record_pb2.ListRecordsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.ListRecordsResponse",record_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Record]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Record]":
        """
        This page's items
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Record,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Record]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        An opaque listing continuation token that can be used to return the next page of listing results
        If ``next_page_token`` is empty, this is the last result page
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
# file: nebius/dns/v1/record_service.proto

class RecordServiceClient(client.Client):
    """
    Service for managing DNS records (\\ ``Record`` resources)
    
    This class provides the client methods for the ``.nebius.dns.v1.RecordService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.dns.v1.RecordService",record_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.dns.v1.RecordService"
    
    def get(self,
        request: "GetRecordRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["GetRecordRequest","Record"]:
        """
        Gets the DNS record with the specified ID
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.dns.v1.GetRecordRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.dns.v1.Record`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=record_pb2.Record,
            result_wrapper=pb_classes.simple_wrapper(Record),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["v1_1.GetByNameRequest","Record"]:
        """
        Gets the DNS record by its parent DNS zone (\\ ``metadata.parent_id``\\ ) and ``metadata.name``
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.dns.v1.Record`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=record_pb2.Record,
            result_wrapper=pb_classes.simple_wrapper(Record),
            **kwargs,
        )
    
    def list(self,
        request: "ListRecordsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["ListRecordsRequest","ListRecordsResponse"]:
        """
        Lists DNS records in the specified DNS zone
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.dns.v1.ListRecordsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.dns.v1.ListRecordsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=record_pb2.ListRecordsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListRecordsResponse),
            **kwargs,
        )
    

# file: nebius/dns/v1/zone.proto
class Zone(pb_classes.Message):
    """
    API Resource: *DNS zone*\\ , a container for DNS data
    
    Each DNS zone starts at a particular domain within the hierarchical DNS namespace tree, e.g., ``example.com.``\\ , and can also include its subdomains, e.g., ``sales.example.com.``
    DNS Zones contain *Resource Records* (RRs), which are individual information entries about the domain(s), e.g., a domain's IP address
    See the `graphical explanation of DNS zones and Resource Records on Wikipedia <https://en.wikipedia.org/wiki/Domain_Name_System#/media/File:Domain_name_space.svg>`_
    
    A Resource Record is represented in this API by the ``Record`` API Resource which is managed by the ``RecordService``
    """
    
    __PB2_CLASS__ = zone_pb2.Zone
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.Zone",zone_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ZoneSpec|zone_pb2.ZoneSpec|None|unset.UnsetType" = unset.Unset,
        status: "ZoneStatus|zone_pb2.ZoneStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        DNS zone metadata
        ``metadata.parent_id`` must be an IAM Container ID
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ZoneSpec":
        """
        DNS zone specification, including its domain name and scope
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=ZoneSpec,
        )
    @spec.setter
    def spec(self, value: "ZoneSpec|zone_pb2.ZoneSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ZoneStatus":
        """
        DNS zone status, including e.g. the number of records in the zone
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=ZoneStatus,
        )
    @status.setter
    def status(self, value: "ZoneStatus|zone_pb2.ZoneStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ZoneSpec(pb_classes.Message):
    """
    DNS Zone specification
    """
    
    __PB2_CLASS__ = zone_pb2.ZoneSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.ZoneSpec",zone_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_scope__(pb_classes.OneOf):
        name: builtins.str= "scope"
        
        def __init__(self, msg: "ZoneSpec") -> None:
            super().__init__()
            self._message: "ZoneSpec" = msg
    
    class __OneOfClass_scope_vpc__(__OneOfClass_scope__):
        field: typing.Literal["vpc"] = "vpc"
        
        def __init__(self, msg: "ZoneSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "VpcZoneScope":
            return self._message.vpc
    
    @builtins.property
    def scope(self) -> __OneOfClass_scope_vpc__|None:
        """
        Scope for this zone
        The scope is chosen at zone creation time and cannot be changed, but scope's attributes can sometimes be changed
        """
        
        field_name_1: str|None = super().which_field_in_oneof("scope")
        match field_name_1:
            case "vpc":
                return self.__OneOfClass_scope_vpc__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        domain_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        vpc: "VpcZoneScope|zone_pb2.VpcZoneScope|None|unset.UnsetType" = unset.Unset,
        soa_spec: "SoaSpec|zone_pb2.SoaSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(domain_name, unset.UnsetType):
            self.domain_name = domain_name
        if not isinstance(vpc, unset.UnsetType):
            self.vpc = vpc
        if not isinstance(soa_spec, unset.UnsetType):
            self.soa_spec = soa_spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "domain_name",
            "vpc",
            "soa_spec",
            "scope",
        ]
    
    @builtins.property
    def domain_name(self) -> "builtins.str":
        """
        Fully qualified domain name of this zone, including ``.`` at the end
        """
        
        return super()._get_field("domain_name", explicit_presence=False,
        )
    @domain_name.setter
    def domain_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("domain_name",value,explicit_presence=False,
        )
    
    @builtins.property
    def vpc(self) -> "VpcZoneScope|None":
        """
        A VPC zone, which is only visible from a virtual network (VPC)
        """
        
        return super()._get_field("vpc", explicit_presence=True,
        wrap=VpcZoneScope,
        )
    @vpc.setter
    def vpc(self, value: "VpcZoneScope|zone_pb2.VpcZoneScope|None") -> None:
        return super()._set_field("vpc",value,explicit_presence=True,
        )
    
    @builtins.property
    def soa_spec(self) -> "SoaSpec":
        """
        Custom SOA (Start of Authority) record specification for the zone
        """
        
        return super()._get_field("soa_spec", explicit_presence=False,
        wrap=SoaSpec,
        )
    @soa_spec.setter
    def soa_spec(self, value: "SoaSpec|zone_pb2.SoaSpec|None") -> None:
        return super()._set_field("soa_spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "domain_name":"domain_name",
        "vpc":"vpc",
        "soa_spec":"soa_spec",
        "scope":"scope",
    }
    
class VpcZoneScope(pb_classes.Message):
    """
    VPC zone scope specification
    """
    
    __PB2_CLASS__ = zone_pb2.VpcZoneScope
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.VpcZoneScope",zone_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        primary_network_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(primary_network_id, unset.UnsetType):
            self.primary_network_id = primary_network_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "primary_network_id",
        ]
    
    @builtins.property
    def primary_network_id(self) -> "builtins.str":
        """
        ID of the virtual network that this zone's records will be visible from
        This value cannot be changed after creating the zone
        """
        
        return super()._get_field("primary_network_id", explicit_presence=False,
        )
    @primary_network_id.setter
    def primary_network_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("primary_network_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "primary_network_id":"primary_network_id",
    }
    
class SoaSpec(pb_classes.Message):
    """
    Custom SOA (Start of Authority) record specification for the zone
    """
    
    __PB2_CLASS__ = zone_pb2.SoaSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.SoaSpec",zone_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        negative_ttl: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(negative_ttl, unset.UnsetType):
            self.negative_ttl = negative_ttl
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "negative_ttl",
        ]
    
    @builtins.property
    def negative_ttl(self) -> "builtins.int":
        """
        Specifies TTL, in seconds, for caching ``NXDOMAIN`` ("record not found") DNS responses from this zone (\\ *negative caching*\\ )
        Set this TTL to a low value if you frequently delete and recreate records instead of updating them
        *Note:* Values of less than ``5`` will be ignored, and a default negative caching TTL will be used instead
        """
        
        return super()._get_field("negative_ttl", explicit_presence=False,
        )
    @negative_ttl.setter
    def negative_ttl(self, value: "builtins.int|None") -> None:
        return super()._set_field("negative_ttl",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "negative_ttl":"negative_ttl",
    }
    
class ZoneStatus(pb_classes.Message):
    """
    DNS zone status
    """
    
    __PB2_CLASS__ = zone_pb2.ZoneStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.ZoneStatus",zone_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        record_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(record_count, unset.UnsetType):
            self.record_count = record_count
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "record_count",
            "reconciling",
        ]
    
    @builtins.property
    def record_count(self) -> "builtins.int":
        """
        Number of records in this zone. May be 0 if not calculated (e.g., in listings)
        """
        
        return super()._get_field("record_count", explicit_presence=False,
        )
    @record_count.setter
    def record_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("record_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is a running Operation for this Zone
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "record_count":"record_count",
        "reconciling":"reconciling",
    }
    
class GetZoneRequest(pb_classes.Message):
    """
    Request to get the DNS zone by its ID and, optionally, its resource version
    """
    
    __PB2_CLASS__ = zone_pb2.GetZoneRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.GetZoneRequest",zone_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_version: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(resource_version, unset.UnsetType):
            self.resource_version = resource_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "resource_version",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Zone ID
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_version(self) -> "builtins.int":
        """
        Optional: expected zone version (\\ ``metadata.resource_version``\\ )
        
        
        * If specified, the requested version will be returned if possible (if the version has changed, you will get a ``FAILED_PRECONDITION`` error)
        * If not specified or set to ``0``\\ , the latest zone version will be returned
        """
        
        return super()._get_field("resource_version", explicit_presence=False,
        )
    @resource_version.setter
    def resource_version(self, value: "builtins.int|None") -> None:
        return super()._set_field("resource_version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "resource_version":"resource_version",
    }
    
class ListZonesRequest(pb_classes.Message):
    """
    Request to list DNS zones in the specified parent IAM container
    """
    
    __PB2_CLASS__ = zone_pb2.ListZonesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.ListZonesRequest",zone_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Parent IAM container ID
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Page size
        If not specified or set to ``0``\\ , a default page size of ``100`` will be used
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        An opaque listing continuation token
        
        
        * If not specified or empty, the first page of results will be returned
        * If specified, the next page of results (as identified by the token) will be returned
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListZonesResponse(pb_classes.Message):
    """
    Response with a single page of DNS zone listing results
    """
    
    __PB2_CLASS__ = zone_pb2.ListZonesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.dns.v1.ListZonesResponse",zone_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Zone]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Zone]":
        """
        This page's items
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Zone,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Zone]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        An opaque listing continuation token that can be used to return the next page of listing results
        If ``next_page_token`` is empty, this is the last result page
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
# file: nebius/dns/v1/zone_service.proto

class ZoneServiceClient(client.Client):
    """
    Service for managing DNS zones (\\ ``Zone`` resources)
    
    This class provides the client methods for the ``.nebius.dns.v1.ZoneService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.dns.v1.ZoneService",zone_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.dns.v1.ZoneService"
    
    def get(self,
        request: "GetZoneRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["GetZoneRequest","Zone"]:
        """
        Gets the DNS zone with the specified ID
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.dns.v1.GetZoneRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.dns.v1.Zone`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=zone_pb2.Zone,
            result_wrapper=pb_classes.simple_wrapper(Zone),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["v1_1.GetByNameRequest","Zone"]:
        """
        Gets the DNS zone by its parent IAM container (\\ ``metadata.parent_id``\\ ) and ``metadata.name``
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.dns.v1.Zone`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=zone_pb2.Zone,
            result_wrapper=pb_classes.simple_wrapper(Zone),
            **kwargs,
        )
    
    def list(self,
        request: "ListZonesRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request.Request["ListZonesRequest","ListZonesResponse"]:
        """
        Lists DNS zones in the specified parent IAM container
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.dns.v1.ListZonesRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.dns.v1.ListZonesResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=zone_pb2.ListZonesResponse,
            result_wrapper=pb_classes.simple_wrapper(ListZonesResponse),
            **kwargs,
        )
    

__all__ = [
    #@ local import names here @#
    "Record",
    "RecordSpec",
    "RecordStatus",
    "GetRecordRequest",
    "ListRecordsRequest",
    "ListRecordsResponse",
    "RecordServiceClient",
    "Zone",
    "ZoneSpec",
    "VpcZoneScope",
    "SoaSpec",
    "ZoneStatus",
    "GetZoneRequest",
    "ListZonesRequest",
    "ListZonesResponse",
    "ZoneServiceClient",
]
