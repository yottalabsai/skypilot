# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.storage.v1alpha1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.duration_pb2 as duration_pb2
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.aio.request_kwargs as request_kwargs
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1.operation_pb2 as operation_pb2
import nebius.api.nebius.storage.v1alpha1.transfer_pb2 as transfer_pb2
import nebius.api.nebius.storage.v1alpha1.transfer_service_pb2 as transfer_service_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
import typing_extensions as typing_extensions
#@ local imports here @#

# file: nebius/storage/v1alpha1/transfer.proto
class Transfer(pb_classes.Message):
    __PB2_CLASS__ = transfer_pb2.Transfer
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.Transfer",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "TransferSpec|transfer_pb2.TransferSpec|None|unset.UnsetType" = unset.Unset,
        status: "TransferStatus|transfer_pb2.TransferStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "TransferSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=TransferSpec,
        )
    @spec.setter
    def spec(self, value: "TransferSpec|transfer_pb2.TransferSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "TransferStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=TransferStatus,
        )
    @status.setter
    def status(self, value: "TransferStatus|transfer_pb2.TransferStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class TransferSpec(pb_classes.Message):
    __PB2_CLASS__ = transfer_pb2.TransferSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "inter_iteration_interval": well_known_1.duration_mask,
    }
    
    class SourceBucket(pb_classes.Message):
        __PB2_CLASS__ = transfer_pb2.TransferSpec.SourceBucket
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.SourceBucket",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            endpoint: "builtins.str|None|unset.UnsetType" = unset.Unset,
            bucket_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
            region: "builtins.str|None|unset.UnsetType" = unset.Unset,
            prefix: "builtins.str|None|unset.UnsetType" = unset.Unset,
            credentials: "TransferSpec.BucketCredentials|transfer_pb2.TransferSpec.BucketCredentials|None|unset.UnsetType" = unset.Unset,
            limiters: "TransferSpec.Limiters|transfer_pb2.TransferSpec.Limiters|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(endpoint, unset.UnsetType):
                self.endpoint = endpoint
            if not isinstance(bucket_name, unset.UnsetType):
                self.bucket_name = bucket_name
            if not isinstance(region, unset.UnsetType):
                self.region = region
            if not isinstance(prefix, unset.UnsetType):
                self.prefix = prefix
            if not isinstance(credentials, unset.UnsetType):
                self.credentials = credentials
            if not isinstance(limiters, unset.UnsetType):
                self.limiters = limiters
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "endpoint",
                "bucket_name",
                "region",
                "prefix",
                "credentials",
                "limiters",
            ]
        
        @builtins.property
        def endpoint(self) -> "builtins.str":
            """
            The endpoint must be in the form of a URL, starting with the protocol (https),
            followed by the endpoint address without a trailing slash.
            Example: https://storage.us-central1.nebius.cloud
            """
            
            return super()._get_field("endpoint", explicit_presence=False,
            )
        @endpoint.setter
        def endpoint(self, value: "builtins.str|None") -> None:
            return super()._set_field("endpoint",value,explicit_presence=False,
            )
        
        @builtins.property
        def bucket_name(self) -> "builtins.str":
            return super()._get_field("bucket_name", explicit_presence=False,
            )
        @bucket_name.setter
        def bucket_name(self, value: "builtins.str|None") -> None:
            return super()._set_field("bucket_name",value,explicit_presence=False,
            )
        
        @builtins.property
        def region(self) -> "builtins.str":
            return super()._get_field("region", explicit_presence=False,
            )
        @region.setter
        def region(self, value: "builtins.str|None") -> None:
            return super()._set_field("region",value,explicit_presence=False,
            )
        
        @builtins.property
        def prefix(self) -> "builtins.str":
            """
            Prefix to filter objects in the source bucket. Only objects whose keys start with this prefix will be transferred.
            During transfer, the resulting object key in the destination bucket is computed
            by removing source.prefix from the original key and then prepending destination.prefix (if provided).
            Important: This transformation may result in an empty object key or one that exceeds allowed length limits.
            Use prefixes that guarantee valid resulting object keys for your objects after transformation.
            """
            
            return super()._get_field("prefix", explicit_presence=False,
            )
        @prefix.setter
        def prefix(self, value: "builtins.str|None") -> None:
            return super()._set_field("prefix",value,explicit_presence=False,
            )
        
        @builtins.property
        def credentials(self) -> "TransferSpec.BucketCredentials":
            """
            Credentials for accessing the source bucket. These credentials must have list and get permissions.
            This parameter must be specified only during create operations.
            """
            
            return super()._get_field("credentials", explicit_presence=False,
            wrap=TransferSpec.BucketCredentials,
            )
        @credentials.setter
        def credentials(self, value: "TransferSpec.BucketCredentials|transfer_pb2.TransferSpec.BucketCredentials|None") -> None:
            return super()._set_field("credentials",value,explicit_presence=False,
            )
        
        @builtins.property
        def limiters(self) -> "TransferSpec.Limiters":
            """
            Limiters applied to source bucket operations. These limits include all operations
            required for transfer (HeadObject, GetObject, ListObjects). For details about
            which operations are used, see public documentation: http://docs.nebius.com/object-storage/transfer/quickstart#background.
            
            Note: Since the service performs comparable request volumes and data transfers
            to both source and destination, these limits will indirectly constrain
            destination operations as well.
            """
            
            return super()._get_field("limiters", explicit_presence=False,
            wrap=TransferSpec.Limiters,
            )
        @limiters.setter
        def limiters(self, value: "TransferSpec.Limiters|transfer_pb2.TransferSpec.Limiters|None") -> None:
            return super()._set_field("limiters",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "endpoint":"endpoint",
            "bucket_name":"bucket_name",
            "region":"region",
            "prefix":"prefix",
            "credentials":"credentials",
            "limiters":"limiters",
        }
        
    
    class DestinationBucket(pb_classes.Message):
        __PB2_CLASS__ = transfer_pb2.TransferSpec.DestinationBucket
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.DestinationBucket",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            bucket_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
            prefix: "builtins.str|None|unset.UnsetType" = unset.Unset,
            credentials: "TransferSpec.BucketCredentials|transfer_pb2.TransferSpec.BucketCredentials|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(bucket_name, unset.UnsetType):
                self.bucket_name = bucket_name
            if not isinstance(prefix, unset.UnsetType):
                self.prefix = prefix
            if not isinstance(credentials, unset.UnsetType):
                self.credentials = credentials
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "bucket_name",
                "prefix",
                "credentials",
            ]
        
        @builtins.property
        def bucket_name(self) -> "builtins.str":
            return super()._get_field("bucket_name", explicit_presence=False,
            )
        @bucket_name.setter
        def bucket_name(self, value: "builtins.str|None") -> None:
            return super()._set_field("bucket_name",value,explicit_presence=False,
            )
        
        @builtins.property
        def prefix(self) -> "builtins.str":
            """
            Prefix to add to the beginning of each transferred object key in the destination bucket.
            During transfer, the resulting object key in the destination bucket is computed
            by removing source.prefix (if provided) from the original key and then prepending destination.prefix.
            Important: This transformation may result in an empty object key or one that exceeds allowed length limits.
            Use prefixes that guarantee valid resulting object keys for your objects after transformation.
            """
            
            return super()._get_field("prefix", explicit_presence=False,
            )
        @prefix.setter
        def prefix(self, value: "builtins.str|None") -> None:
            return super()._set_field("prefix",value,explicit_presence=False,
            )
        
        @builtins.property
        def credentials(self) -> "TransferSpec.BucketCredentials":
            """
            Credentials for accessing the destination bucket. These credentials must have head and write permissions.
            This parameter must be specified only during create operations.
            """
            
            return super()._get_field("credentials", explicit_presence=False,
            wrap=TransferSpec.BucketCredentials,
            )
        @credentials.setter
        def credentials(self, value: "TransferSpec.BucketCredentials|transfer_pb2.TransferSpec.BucketCredentials|None") -> None:
            return super()._set_field("credentials",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "bucket_name":"bucket_name",
            "prefix":"prefix",
            "credentials":"credentials",
        }
        
    
    class BucketCredentials(pb_classes.Message):
        __PB2_CLASS__ = transfer_pb2.TransferSpec.BucketCredentials
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.BucketCredentials",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        class CredentialsAnonymous(pb_classes.Message):
            __PB2_CLASS__ = transfer_pb2.TransferSpec.BucketCredentials.CredentialsAnonymous
            __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.BucketCredentials.CredentialsAnonymous",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
            __mask_functions__ = {
            }
            
            def __init__(
                self,
                initial_message: message_1.Message|None = None,
            ) -> None:
                super().__init__(initial_message)
            
            def __dir__(self) ->abc.Iterable[builtins.str]:
                return [
                ]
            
            __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            }
            
        
        class CredentialsAccessKey(pb_classes.Message):
            __PB2_CLASS__ = transfer_pb2.TransferSpec.BucketCredentials.CredentialsAccessKey
            __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.BucketCredentials.CredentialsAccessKey",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
            __mask_functions__ = {
            }
            
            def __init__(
                self,
                initial_message: message_1.Message|None = None,
                *,
                access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
                secret_access_key: "builtins.str|None|unset.UnsetType" = unset.Unset,
            ) -> None:
                super().__init__(initial_message)
                if not isinstance(access_key_id, unset.UnsetType):
                    self.access_key_id = access_key_id
                if not isinstance(secret_access_key, unset.UnsetType):
                    self.secret_access_key = secret_access_key
            
            def __dir__(self) ->abc.Iterable[builtins.str]:
                return [
                    "access_key_id",
                    "secret_access_key",
                ]
            
            @builtins.property
            def access_key_id(self) -> "builtins.str":
                return super()._get_field("access_key_id", explicit_presence=False,
                )
            @access_key_id.setter
            def access_key_id(self, value: "builtins.str|None") -> None:
                return super()._set_field("access_key_id",value,explicit_presence=False,
                )
            
            @builtins.property
            def secret_access_key(self) -> "builtins.str":
                return super()._get_field("secret_access_key", explicit_presence=False,
                )
            @secret_access_key.setter
            def secret_access_key(self, value: "builtins.str|None") -> None:
                return super()._set_field("secret_access_key",value,explicit_presence=False,
                )
            
            __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
                "access_key_id":"access_key_id",
                "secret_access_key":"secret_access_key",
            }
            
        
        class AzureAccessKey(pb_classes.Message):
            __PB2_CLASS__ = transfer_pb2.TransferSpec.BucketCredentials.AzureAccessKey
            __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.BucketCredentials.AzureAccessKey",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
            __mask_functions__ = {
            }
            
            def __init__(
                self,
                initial_message: message_1.Message|None = None,
                *,
                account_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
                access_key: "builtins.str|None|unset.UnsetType" = unset.Unset,
            ) -> None:
                super().__init__(initial_message)
                if not isinstance(account_name, unset.UnsetType):
                    self.account_name = account_name
                if not isinstance(access_key, unset.UnsetType):
                    self.access_key = access_key
            
            def __dir__(self) ->abc.Iterable[builtins.str]:
                return [
                    "account_name",
                    "access_key",
                ]
            
            @builtins.property
            def account_name(self) -> "builtins.str":
                return super()._get_field("account_name", explicit_presence=False,
                )
            @account_name.setter
            def account_name(self, value: "builtins.str|None") -> None:
                return super()._set_field("account_name",value,explicit_presence=False,
                )
            
            @builtins.property
            def access_key(self) -> "builtins.str":
                return super()._get_field("access_key", explicit_presence=False,
                )
            @access_key.setter
            def access_key(self, value: "builtins.str|None") -> None:
                return super()._set_field("access_key",value,explicit_presence=False,
                )
            
            __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
                "account_name":"account_name",
                "access_key":"access_key",
            }
            
        
        class __OneOfClass_credentials__(pb_classes.OneOf):
            name: builtins.str= "credentials"
            
            def __init__(self, msg: "TransferSpec.BucketCredentials") -> None:
                super().__init__()
                self._message: "TransferSpec.BucketCredentials" = msg
        
        class __OneOfClass_credentials_anonymous__(__OneOfClass_credentials__):
            field: typing.Literal["anonymous"] = "anonymous"
            
            def __init__(self, msg: "TransferSpec.BucketCredentials") -> None:
                super().__init__(msg)
            @builtins.property
            def value(self) -> "TransferSpec.BucketCredentials.CredentialsAnonymous":
                return self._message.anonymous
        
        class __OneOfClass_credentials_access_key__(__OneOfClass_credentials__):
            field: typing.Literal["access_key"] = "access_key"
            
            def __init__(self, msg: "TransferSpec.BucketCredentials") -> None:
                super().__init__(msg)
            @builtins.property
            def value(self) -> "TransferSpec.BucketCredentials.CredentialsAccessKey":
                return self._message.access_key
        
        class __OneOfClass_credentials_azure_access_key__(__OneOfClass_credentials__):
            field: typing.Literal["azure_access_key"] = "azure_access_key"
            
            def __init__(self, msg: "TransferSpec.BucketCredentials") -> None:
                super().__init__(msg)
            @builtins.property
            def value(self) -> "TransferSpec.BucketCredentials.AzureAccessKey":
                return self._message.azure_access_key
        
        @builtins.property
        def credentials(self) -> __OneOfClass_credentials_anonymous__|__OneOfClass_credentials_access_key__|__OneOfClass_credentials_azure_access_key__|None:
            field_name_1: str|None = super().which_field_in_oneof("credentials")
            match field_name_1:
                case "anonymous":
                    return self.__OneOfClass_credentials_anonymous__(self)
                case "access_key":
                    return self.__OneOfClass_credentials_access_key__(self)
                case "azure_access_key":
                    return self.__OneOfClass_credentials_azure_access_key__(self)
                case None:
                    return None
                case _:
                    raise pb_classes.OneOfMatchError(field_name_1)
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            anonymous: "TransferSpec.BucketCredentials.CredentialsAnonymous|transfer_pb2.TransferSpec.BucketCredentials.CredentialsAnonymous|None|unset.UnsetType" = unset.Unset,
            access_key: "TransferSpec.BucketCredentials.CredentialsAccessKey|transfer_pb2.TransferSpec.BucketCredentials.CredentialsAccessKey|None|unset.UnsetType" = unset.Unset,
            azure_access_key: "TransferSpec.BucketCredentials.AzureAccessKey|transfer_pb2.TransferSpec.BucketCredentials.AzureAccessKey|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(anonymous, unset.UnsetType):
                self.anonymous = anonymous
            if not isinstance(access_key, unset.UnsetType):
                self.access_key = access_key
            if not isinstance(azure_access_key, unset.UnsetType):
                self.azure_access_key = azure_access_key
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "anonymous",
                "access_key",
                "azure_access_key",
                "CredentialsAnonymous",
                "CredentialsAccessKey",
                "AzureAccessKey",
                "credentials",
            ]
        
        @builtins.property
        def anonymous(self) -> "TransferSpec.BucketCredentials.CredentialsAnonymous|None":
            return super()._get_field("anonymous", explicit_presence=True,
            wrap=TransferSpec.BucketCredentials.CredentialsAnonymous,
            )
        @anonymous.setter
        def anonymous(self, value: "TransferSpec.BucketCredentials.CredentialsAnonymous|transfer_pb2.TransferSpec.BucketCredentials.CredentialsAnonymous|None") -> None:
            return super()._set_field("anonymous",value,explicit_presence=True,
            )
        
        @builtins.property
        def access_key(self) -> "TransferSpec.BucketCredentials.CredentialsAccessKey|None":
            return super()._get_field("access_key", explicit_presence=True,
            wrap=TransferSpec.BucketCredentials.CredentialsAccessKey,
            )
        @access_key.setter
        def access_key(self, value: "TransferSpec.BucketCredentials.CredentialsAccessKey|transfer_pb2.TransferSpec.BucketCredentials.CredentialsAccessKey|None") -> None:
            return super()._set_field("access_key",value,explicit_presence=True,
            )
        
        @builtins.property
        def azure_access_key(self) -> "TransferSpec.BucketCredentials.AzureAccessKey|None":
            return super()._get_field("azure_access_key", explicit_presence=True,
            wrap=TransferSpec.BucketCredentials.AzureAccessKey,
            )
        @azure_access_key.setter
        def azure_access_key(self, value: "TransferSpec.BucketCredentials.AzureAccessKey|transfer_pb2.TransferSpec.BucketCredentials.AzureAccessKey|None") -> None:
            return super()._set_field("azure_access_key",value,explicit_presence=True,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "anonymous":"anonymous",
            "access_key":"access_key",
            "azure_access_key":"azure_access_key",
            "CredentialsAnonymous":"CredentialsAnonymous",
            "CredentialsAccessKey":"CredentialsAccessKey",
            "AzureAccessKey":"AzureAccessKey",
            "credentials":"credentials",
        }
        
    
    class Limiters(pb_classes.Message):
        __PB2_CLASS__ = transfer_pb2.TransferSpec.Limiters
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.Limiters",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            bandwidth_bytes_per_second: "builtins.int|None|unset.UnsetType" = unset.Unset,
            requests_per_second: "builtins.int|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(bandwidth_bytes_per_second, unset.UnsetType):
                self.bandwidth_bytes_per_second = bandwidth_bytes_per_second
            if not isinstance(requests_per_second, unset.UnsetType):
                self.requests_per_second = requests_per_second
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "bandwidth_bytes_per_second",
                "requests_per_second",
            ]
        
        @builtins.property
        def bandwidth_bytes_per_second(self) -> "builtins.int":
            """
            Maximum bandwidth in bytes per second. If set to zero, default limit will be applied.
            """
            
            return super()._get_field("bandwidth_bytes_per_second", explicit_presence=False,
            )
        @bandwidth_bytes_per_second.setter
        def bandwidth_bytes_per_second(self, value: "builtins.int|None") -> None:
            return super()._set_field("bandwidth_bytes_per_second",value,explicit_presence=False,
            )
        
        @builtins.property
        def requests_per_second(self) -> "builtins.int":
            """
            Maximum number of requests per second. If set to zero, default limit will be applied.
            """
            
            return super()._get_field("requests_per_second", explicit_presence=False,
            )
        @requests_per_second.setter
        def requests_per_second(self, value: "builtins.int|None") -> None:
            return super()._set_field("requests_per_second",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "bandwidth_bytes_per_second":"bandwidth_bytes_per_second",
            "requests_per_second":"requests_per_second",
        }
        
    
    class StopConditionAfterOneIteration(pb_classes.Message):
        __PB2_CLASS__ = transfer_pb2.TransferSpec.StopConditionAfterOneIteration
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.StopConditionAfterOneIteration",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
        ) -> None:
            super().__init__(initial_message)
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
            ]
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        }
        
    
    class StopConditionAfterNEmptyIterations(pb_classes.Message):
        __PB2_CLASS__ = transfer_pb2.TransferSpec.StopConditionAfterNEmptyIterations
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.StopConditionAfterNEmptyIterations",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            empty_iterations_threshold: "builtins.int|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(empty_iterations_threshold, unset.UnsetType):
                self.empty_iterations_threshold = empty_iterations_threshold
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "empty_iterations_threshold",
            ]
        
        @builtins.property
        def empty_iterations_threshold(self) -> "builtins.int":
            """
            Number of consecutive iterations with zero transferred objects required to stop transfer.
            """
            
            return super()._get_field("empty_iterations_threshold", explicit_presence=False,
            )
        @empty_iterations_threshold.setter
        def empty_iterations_threshold(self, value: "builtins.int|None") -> None:
            return super()._set_field("empty_iterations_threshold",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "empty_iterations_threshold":"empty_iterations_threshold",
        }
        
    
    class StopConditionInfinite(pb_classes.Message):
        __PB2_CLASS__ = transfer_pb2.TransferSpec.StopConditionInfinite
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferSpec.StopConditionInfinite",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
        ) -> None:
            super().__init__(initial_message)
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
            ]
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        }
        
    
    class OverwriteStrategy(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.storage.v1alpha1.TransferSpec.OverwriteStrategy",transfer_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        OVERWRITE_STRATEGY_UNSPECIFIED = 0
        NEVER = 1
        """
        Never overwrite objects that exist in the destination.
        If object exists in destination bucket, skip it.
        Safest option to prevent data loss.
        """
        
        IF_NEWER = 2
        """
        Overwrite only if source object is newer than destination.
        Comparison based on Last-Modified timestamp.
        Recommended for incremental sync scenarios.
        """
        
        ALWAYS = 3
        """
        Always overwrite destination objects unconditionally.
        Use with caution - may cause data loss in destination.
        Suitable for full bucket synchronization.
        """
        
    
    class __OneOfClass_stop_condition__(pb_classes.OneOf):
        name: builtins.str= "stop_condition"
        
        def __init__(self, msg: "TransferSpec") -> None:
            super().__init__()
            self._message: "TransferSpec" = msg
    
    class __OneOfClass_stop_condition_after_one_iteration__(__OneOfClass_stop_condition__):
        field: typing.Literal["after_one_iteration"] = "after_one_iteration"
        
        def __init__(self, msg: "TransferSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "TransferSpec.StopConditionAfterOneIteration":
            return self._message.after_one_iteration
    
    class __OneOfClass_stop_condition_after_n_empty_iterations__(__OneOfClass_stop_condition__):
        field: typing.Literal["after_n_empty_iterations"] = "after_n_empty_iterations"
        
        def __init__(self, msg: "TransferSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "TransferSpec.StopConditionAfterNEmptyIterations":
            return self._message.after_n_empty_iterations
    
    class __OneOfClass_stop_condition_infinite__(__OneOfClass_stop_condition__):
        field: typing.Literal["infinite"] = "infinite"
        
        def __init__(self, msg: "TransferSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "TransferSpec.StopConditionInfinite":
            return self._message.infinite
    
    @builtins.property
    def stop_condition(self) -> __OneOfClass_stop_condition_after_one_iteration__|__OneOfClass_stop_condition_after_n_empty_iterations__|__OneOfClass_stop_condition_infinite__|None:
        """
        The stop condition is checked after every iteration. If the condition is met, the transfer will stop.
        """
        
        field_name_1: str|None = super().which_field_in_oneof("stop_condition")
        match field_name_1:
            case "after_one_iteration":
                return self.__OneOfClass_stop_condition_after_one_iteration__(self)
            case "after_n_empty_iterations":
                return self.__OneOfClass_stop_condition_after_n_empty_iterations__(self)
            case "infinite":
                return self.__OneOfClass_stop_condition_infinite__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        source: "TransferSpec.SourceBucket|transfer_pb2.TransferSpec.SourceBucket|None|unset.UnsetType" = unset.Unset,
        destination: "TransferSpec.DestinationBucket|transfer_pb2.TransferSpec.DestinationBucket|None|unset.UnsetType" = unset.Unset,
        after_one_iteration: "TransferSpec.StopConditionAfterOneIteration|transfer_pb2.TransferSpec.StopConditionAfterOneIteration|None|unset.UnsetType" = unset.Unset,
        after_n_empty_iterations: "TransferSpec.StopConditionAfterNEmptyIterations|transfer_pb2.TransferSpec.StopConditionAfterNEmptyIterations|None|unset.UnsetType" = unset.Unset,
        infinite: "TransferSpec.StopConditionInfinite|transfer_pb2.TransferSpec.StopConditionInfinite|None|unset.UnsetType" = unset.Unset,
        inter_iteration_interval: "duration_pb2.Duration|datetime.timedelta|None|unset.UnsetType" = unset.Unset,
        overwrite_strategy: "TransferSpec.OverwriteStrategy|transfer_pb2.TransferSpec.OverwriteStrategy|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(source, unset.UnsetType):
            self.source = source
        if not isinstance(destination, unset.UnsetType):
            self.destination = destination
        if not isinstance(after_one_iteration, unset.UnsetType):
            self.after_one_iteration = after_one_iteration
        if not isinstance(after_n_empty_iterations, unset.UnsetType):
            self.after_n_empty_iterations = after_n_empty_iterations
        if not isinstance(infinite, unset.UnsetType):
            self.infinite = infinite
        if not isinstance(inter_iteration_interval, unset.UnsetType):
            self.inter_iteration_interval = inter_iteration_interval
        if not isinstance(overwrite_strategy, unset.UnsetType):
            self.overwrite_strategy = overwrite_strategy
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "source",
            "destination",
            "after_one_iteration",
            "after_n_empty_iterations",
            "infinite",
            "inter_iteration_interval",
            "overwrite_strategy",
            "SourceBucket",
            "DestinationBucket",
            "BucketCredentials",
            "Limiters",
            "StopConditionAfterOneIteration",
            "StopConditionAfterNEmptyIterations",
            "StopConditionInfinite",
            "stop_condition",
            "OverwriteStrategy",
        ]
    
    @builtins.property
    def source(self) -> "TransferSpec.SourceBucket":
        return super()._get_field("source", explicit_presence=False,
        wrap=TransferSpec.SourceBucket,
        )
    @source.setter
    def source(self, value: "TransferSpec.SourceBucket|transfer_pb2.TransferSpec.SourceBucket|None") -> None:
        return super()._set_field("source",value,explicit_presence=False,
        )
    
    @builtins.property
    def destination(self) -> "TransferSpec.DestinationBucket":
        return super()._get_field("destination", explicit_presence=False,
        wrap=TransferSpec.DestinationBucket,
        )
    @destination.setter
    def destination(self, value: "TransferSpec.DestinationBucket|transfer_pb2.TransferSpec.DestinationBucket|None") -> None:
        return super()._set_field("destination",value,explicit_presence=False,
        )
    
    @builtins.property
    def after_one_iteration(self) -> "TransferSpec.StopConditionAfterOneIteration|None":
        return super()._get_field("after_one_iteration", explicit_presence=True,
        wrap=TransferSpec.StopConditionAfterOneIteration,
        )
    @after_one_iteration.setter
    def after_one_iteration(self, value: "TransferSpec.StopConditionAfterOneIteration|transfer_pb2.TransferSpec.StopConditionAfterOneIteration|None") -> None:
        return super()._set_field("after_one_iteration",value,explicit_presence=True,
        )
    
    @builtins.property
    def after_n_empty_iterations(self) -> "TransferSpec.StopConditionAfterNEmptyIterations|None":
        return super()._get_field("after_n_empty_iterations", explicit_presence=True,
        wrap=TransferSpec.StopConditionAfterNEmptyIterations,
        )
    @after_n_empty_iterations.setter
    def after_n_empty_iterations(self, value: "TransferSpec.StopConditionAfterNEmptyIterations|transfer_pb2.TransferSpec.StopConditionAfterNEmptyIterations|None") -> None:
        return super()._set_field("after_n_empty_iterations",value,explicit_presence=True,
        )
    
    @builtins.property
    def infinite(self) -> "TransferSpec.StopConditionInfinite|None":
        """
        Infinite transfers do not stop automatically and can be stopped manually by the user.
        """
        
        return super()._get_field("infinite", explicit_presence=True,
        wrap=TransferSpec.StopConditionInfinite,
        )
    @infinite.setter
    def infinite(self, value: "TransferSpec.StopConditionInfinite|transfer_pb2.TransferSpec.StopConditionInfinite|None") -> None:
        return super()._set_field("infinite",value,explicit_presence=True,
        )
    
    @builtins.property
    def inter_iteration_interval(self) -> "datetime.timedelta":
        """
        Time to wait between transfer iterations. Default is 15 minutes if not specified.
        """
        
        return super()._get_field("inter_iteration_interval", explicit_presence=False,
        wrap=well_known_1.from_duration
        )
    @inter_iteration_interval.setter
    def inter_iteration_interval(self, value: "duration_pb2.Duration|datetime.timedelta|None") -> None:
        return super()._set_field("inter_iteration_interval",value,explicit_presence=False,
        unwrap=well_known_1.to_duration
        )
    
    @builtins.property
    def overwrite_strategy(self) -> "TransferSpec.OverwriteStrategy":
        """
        Overwrite strategy set logic of overwrite already existed objects in destination bucket.
        """
        
        return super()._get_field("overwrite_strategy", explicit_presence=False,
        wrap=TransferSpec.OverwriteStrategy,
        )
    @overwrite_strategy.setter
    def overwrite_strategy(self, value: "TransferSpec.OverwriteStrategy|transfer_pb2.TransferSpec.OverwriteStrategy|None") -> None:
        return super()._set_field("overwrite_strategy",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "source":"source",
        "destination":"destination",
        "after_one_iteration":"after_one_iteration",
        "after_n_empty_iterations":"after_n_empty_iterations",
        "infinite":"infinite",
        "inter_iteration_interval":"inter_iteration_interval",
        "overwrite_strategy":"overwrite_strategy",
        "SourceBucket":"SourceBucket",
        "DestinationBucket":"DestinationBucket",
        "BucketCredentials":"BucketCredentials",
        "Limiters":"Limiters",
        "StopConditionAfterOneIteration":"StopConditionAfterOneIteration",
        "StopConditionAfterNEmptyIterations":"StopConditionAfterNEmptyIterations",
        "StopConditionInfinite":"StopConditionInfinite",
        "stop_condition":"stop_condition",
        "OverwriteStrategy":"OverwriteStrategy",
    }
    
class TransferStatus(pb_classes.Message):
    __PB2_CLASS__ = transfer_pb2.TransferStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferStatus",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.storage.v1alpha1.TransferStatus.State",transfer_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        STOPPING = 2
        STOPPED = 3
        FAILING = 4
        FAILED = 5
    
    class SuspensionState(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.storage.v1alpha1.TransferStatus.SuspensionState",transfer_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        SUSPENSION_STATE_UNSPECIFIED = 0
        NOT_SUSPENDED = 1
        SUSPENDED = 2
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "TransferStatus.State|transfer_pb2.TransferStatus.State|None|unset.UnsetType" = unset.Unset,
        error: "builtins.str|None|unset.UnsetType" = unset.Unset,
        suspension_state: "TransferStatus.SuspensionState|transfer_pb2.TransferStatus.SuspensionState|None|unset.UnsetType" = unset.Unset,
        last_iteration: "TransferIteration|transfer_pb2.TransferIteration|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(error, unset.UnsetType):
            self.error = error
        if not isinstance(suspension_state, unset.UnsetType):
            self.suspension_state = suspension_state
        if not isinstance(last_iteration, unset.UnsetType):
            self.last_iteration = last_iteration
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "error",
            "suspension_state",
            "last_iteration",
            "State",
            "SuspensionState",
        ]
    
    @builtins.property
    def state(self) -> "TransferStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=TransferStatus.State,
        )
    @state.setter
    def state(self, value: "TransferStatus.State|transfer_pb2.TransferStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def error(self) -> "builtins.str":
        """
        Error information if the transfer has failed.
        """
        
        return super()._get_field("error", explicit_presence=False,
        )
    @error.setter
    def error(self, value: "builtins.str|None") -> None:
        return super()._set_field("error",value,explicit_presence=False,
        )
    
    @builtins.property
    def suspension_state(self) -> "TransferStatus.SuspensionState":
        return super()._get_field("suspension_state", explicit_presence=False,
        wrap=TransferStatus.SuspensionState,
        )
    @suspension_state.setter
    def suspension_state(self, value: "TransferStatus.SuspensionState|transfer_pb2.TransferStatus.SuspensionState|None") -> None:
        return super()._set_field("suspension_state",value,explicit_presence=False,
        )
    
    @builtins.property
    def last_iteration(self) -> "TransferIteration":
        return super()._get_field("last_iteration", explicit_presence=False,
        wrap=TransferIteration,
        )
    @last_iteration.setter
    def last_iteration(self, value: "TransferIteration|transfer_pb2.TransferIteration|None") -> None:
        return super()._set_field("last_iteration",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "error":"error",
        "suspension_state":"suspension_state",
        "last_iteration":"last_iteration",
        "State":"State",
        "SuspensionState":"SuspensionState",
    }
    
class TransferIteration(pb_classes.Message):
    __PB2_CLASS__ = transfer_pb2.TransferIteration
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.TransferIteration",transfer_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "start_time": well_known_1.ts_mask,
        "end_time": well_known_1.ts_mask,
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.storage.v1alpha1.TransferIteration.State",transfer_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        IN_PROGRESS = 1
        COMPLETED = 2
        STOPPED = 3
        FAILED = 4
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        sequence_number: "builtins.int|None|unset.UnsetType" = unset.Unset,
        state: "TransferIteration.State|transfer_pb2.TransferIteration.State|None|unset.UnsetType" = unset.Unset,
        error: "builtins.str|None|unset.UnsetType" = unset.Unset,
        start_time: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        end_time: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        objects_discovered_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        objects_migrated_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        objects_skipped_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        objects_migrated_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        average_throughput_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(sequence_number, unset.UnsetType):
            self.sequence_number = sequence_number
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(error, unset.UnsetType):
            self.error = error
        if not isinstance(start_time, unset.UnsetType):
            self.start_time = start_time
        if not isinstance(end_time, unset.UnsetType):
            self.end_time = end_time
        if not isinstance(objects_discovered_count, unset.UnsetType):
            self.objects_discovered_count = objects_discovered_count
        if not isinstance(objects_migrated_count, unset.UnsetType):
            self.objects_migrated_count = objects_migrated_count
        if not isinstance(objects_skipped_count, unset.UnsetType):
            self.objects_skipped_count = objects_skipped_count
        if not isinstance(objects_migrated_size, unset.UnsetType):
            self.objects_migrated_size = objects_migrated_size
        if not isinstance(average_throughput_bytes, unset.UnsetType):
            self.average_throughput_bytes = average_throughput_bytes
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "sequence_number",
            "state",
            "error",
            "start_time",
            "end_time",
            "objects_discovered_count",
            "objects_migrated_count",
            "objects_skipped_count",
            "objects_migrated_size",
            "average_throughput_bytes",
            "State",
        ]
    
    @builtins.property
    def sequence_number(self) -> "builtins.int":
        return super()._get_field("sequence_number", explicit_presence=False,
        )
    @sequence_number.setter
    def sequence_number(self, value: "builtins.int|None") -> None:
        return super()._set_field("sequence_number",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "TransferIteration.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=TransferIteration.State,
        )
    @state.setter
    def state(self, value: "TransferIteration.State|transfer_pb2.TransferIteration.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def error(self) -> "builtins.str":
        """
        Human-readable error description. Populated only if state is FAILED.
        """
        
        return super()._get_field("error", explicit_presence=False,
        )
    @error.setter
    def error(self, value: "builtins.str|None") -> None:
        return super()._set_field("error",value,explicit_presence=False,
        )
    
    @builtins.property
    def start_time(self) -> "datetime.datetime":
        return super()._get_field("start_time", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @start_time.setter
    def start_time(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("start_time",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def end_time(self) -> "datetime.datetime":
        return super()._get_field("end_time", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @end_time.setter
    def end_time(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("end_time",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def objects_discovered_count(self) -> "builtins.int":
        return super()._get_field("objects_discovered_count", explicit_presence=False,
        )
    @objects_discovered_count.setter
    def objects_discovered_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("objects_discovered_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def objects_migrated_count(self) -> "builtins.int":
        return super()._get_field("objects_migrated_count", explicit_presence=False,
        )
    @objects_migrated_count.setter
    def objects_migrated_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("objects_migrated_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def objects_skipped_count(self) -> "builtins.int":
        return super()._get_field("objects_skipped_count", explicit_presence=False,
        )
    @objects_skipped_count.setter
    def objects_skipped_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("objects_skipped_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def objects_migrated_size(self) -> "builtins.int":
        return super()._get_field("objects_migrated_size", explicit_presence=False,
        )
    @objects_migrated_size.setter
    def objects_migrated_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("objects_migrated_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def average_throughput_bytes(self) -> "builtins.int":
        return super()._get_field("average_throughput_bytes", explicit_presence=False,
        )
    @average_throughput_bytes.setter
    def average_throughput_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("average_throughput_bytes",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "sequence_number":"sequence_number",
        "state":"state",
        "error":"error",
        "start_time":"start_time",
        "end_time":"end_time",
        "objects_discovered_count":"objects_discovered_count",
        "objects_migrated_count":"objects_migrated_count",
        "objects_skipped_count":"objects_skipped_count",
        "objects_migrated_size":"objects_migrated_size",
        "average_throughput_bytes":"average_throughput_bytes",
        "State":"State",
    }
    
# file: nebius/storage/v1alpha1/transfer_service.proto
class GetTransferRequest(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.GetTransferRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.GetTransferRequest",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListTransfersRequest(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.ListTransfersRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.ListTransfersRequest",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response. Default: 10.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListTransfersResponse(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.ListTransfersResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.ListTransfersResponse",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Transfer]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Transfer]":
        """
        List of transfers returned in the response.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Transfer,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Transfer]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class CreateTransferRequest(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.CreateTransferRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.CreateTransferRequest",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "TransferSpec|transfer_pb2.TransferSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "TransferSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=TransferSpec,
        )
    @spec.setter
    def spec(self, value: "TransferSpec|transfer_pb2.TransferSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateTransferRequest(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.UpdateTransferRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.UpdateTransferRequest",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "TransferSpec|transfer_pb2.TransferSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "TransferSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=TransferSpec,
        )
    @spec.setter
    def spec(self, value: "TransferSpec|transfer_pb2.TransferSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class StopTransferRequest(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.StopTransferRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.StopTransferRequest",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ResumeTransferRequest(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.ResumeTransferRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.ResumeTransferRequest",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeleteTransferRequest(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.DeleteTransferRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.DeleteTransferRequest",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_version: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(resource_version, unset.UnsetType):
            self.resource_version = resource_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "resource_version",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_version(self) -> "builtins.int":
        return super()._get_field("resource_version", explicit_presence=False,
        )
    @resource_version.setter
    def resource_version(self, value: "builtins.int|None") -> None:
        return super()._set_field("resource_version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "resource_version":"resource_version",
    }
    
class GetIterationHistoryRequest(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.GetIterationHistoryRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.GetIterationHistoryRequest",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        transfer_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(transfer_id, unset.UnsetType):
            self.transfer_id = transfer_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "transfer_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def transfer_id(self) -> "builtins.str":
        return super()._get_field("transfer_id", explicit_presence=False,
        )
    @transfer_id.setter
    def transfer_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("transfer_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "transfer_id":"transfer_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class GetIterationHistoryResponse(pb_classes.Message):
    __PB2_CLASS__ = transfer_service_pb2.GetIterationHistoryResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.storage.v1alpha1.GetIterationHistoryResponse",transfer_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        iterations: "abc.Iterable[TransferIteration]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(iterations, unset.UnsetType):
            self.iterations = iterations
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "iterations",
            "next_page_token",
        ]
    
    @builtins.property
    def iterations(self) -> "abc.MutableSequence[TransferIteration]":
        """
        List of transfer iterations sorted from newest to oldest.
        """
        
        return super()._get_field("iterations", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(TransferIteration,None,None),
        )
    @iterations.setter
    def iterations(self, value: "abc.Iterable[TransferIteration]|None") -> None:
        return super()._set_field("iterations",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "iterations":"iterations",
        "next_page_token":"next_page_token",
    }
    

class TransferServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    TransferService provides functionality for creating and managing transfers
    that migrate data from other S3 providers or across different regions of Nebius Object Storage.
    Each transfer consists of consecutive iterations where the service lists objects in the source bucket and
    moves those that need to be transferred according to the specified overwrite strategy.
    After an iteration completes, the transfer will stop if its stop condition is met. Otherwise,
    it will wait for the defined inter-iteration interval before starting the next iteration.
    
    This class provides the client methods for the ``.nebius.storage.v1alpha1.TransferService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.storage.v1alpha1.TransferService",transfer_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.storage.v1alpha1.TransferService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetTransferRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetTransferRequest","Transfer"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.storage.v1alpha1.GetTransferRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.storage.v1alpha1.Transfer`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=transfer_pb2.Transfer,
            result_wrapper=pb_classes.simple_wrapper(Transfer),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["v1_1.GetByNameRequest","Transfer"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.storage.v1alpha1.Transfer`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=transfer_pb2.Transfer,
            result_wrapper=pb_classes.simple_wrapper(Transfer),
            **kwargs,
        )
    
    def list(self,
        request: "ListTransfersRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListTransfersRequest","ListTransfersResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.storage.v1alpha1.ListTransfersRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.storage.v1alpha1.ListTransfersResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=transfer_service_pb2.ListTransfersResponse,
            result_wrapper=pb_classes.simple_wrapper(ListTransfersResponse),
            **kwargs,
        )
    
    def create(self,
        request: "CreateTransferRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateTransferRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.storage.v1alpha1.CreateTransferRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def update(self,
        request: "UpdateTransferRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateTransferRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.storage.v1alpha1.UpdateTransferRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def stop(self,
        request: "StopTransferRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["StopTransferRequest","operation.Operation[v1_1.Operation]"]:
        """
        Stop active transfer. If the transfer is currently moving data,
        it will be transitioned to the Stopping state and will move to the Stopped state once all processes have been stopped.
        If the transfer is waiting between iterations, it will stop immediately.
        Only transfer in Active state can be stopped.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.storage.v1alpha1.StopTransferRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Stop",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def resume(self,
        request: "ResumeTransferRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ResumeTransferRequest","operation.Operation[v1_1.Operation]"]:
        """
        Resume stopped or failed transfer.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.storage.v1alpha1.ResumeTransferRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Resume",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteTransferRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteTransferRequest","operation.Operation[v1_1.Operation]"]:
        """
        Fully delete a transfer along with its history. Only stopped or failed transfers can be deleted.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.storage.v1alpha1.DeleteTransferRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def get_iteration_history(self,
        request: "GetIterationHistoryRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetIterationHistoryRequest","GetIterationHistoryResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.storage.v1alpha1.GetIterationHistoryRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.storage.v1alpha1.GetIterationHistoryResponse`.
        """
        
        return super().request(
            method="GetIterationHistory",
            request=request,
            result_pb2_class=transfer_service_pb2.GetIterationHistoryResponse,
            result_wrapper=pb_classes.simple_wrapper(GetIterationHistoryResponse),
            **kwargs,
        )
    

__all__ = [
    #@ local import names here @#
    "Transfer",
    "TransferSpec",
    "TransferStatus",
    "TransferIteration",
    "GetTransferRequest",
    "ListTransfersRequest",
    "ListTransfersResponse",
    "CreateTransferRequest",
    "UpdateTransferRequest",
    "StopTransferRequest",
    "ResumeTransferRequest",
    "DeleteTransferRequest",
    "GetIterationHistoryRequest",
    "GetIterationHistoryResponse",
    "TransferServiceClient",
]
