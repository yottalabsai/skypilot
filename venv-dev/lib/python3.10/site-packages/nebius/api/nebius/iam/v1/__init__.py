# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.iam.v1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import nebius.aio.client as client
import nebius.aio.operation as operation_1
import nebius.aio.request as request_1
import nebius.aio.request_kwargs as request_kwargs
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1.operation_pb2 as operation_pb2
import nebius.api.nebius.iam.v1.access_key_pb2 as access_key_pb2
import nebius.api.nebius.iam.v1.access_key_service_pb2 as access_key_service_pb2
import nebius.api.nebius.iam.v1.access_pb2 as access_pb2
import nebius.api.nebius.iam.v1.access_permit_pb2 as access_permit_pb2
import nebius.api.nebius.iam.v1.access_permit_service_pb2 as access_permit_service_pb2
import nebius.api.nebius.iam.v1.auth_public_key_pb2 as auth_public_key_pb2
import nebius.api.nebius.iam.v1.auth_public_key_service_pb2 as auth_public_key_service_pb2
import nebius.api.nebius.iam.v1.container_pb2 as container_pb2
import nebius.api.nebius.iam.v1.federated_credentials_pb2 as federated_credentials_pb2
import nebius.api.nebius.iam.v1.federated_credentials_service_pb2 as federated_credentials_service_pb2
import nebius.api.nebius.iam.v1.federation_certificate_pb2 as federation_certificate_pb2
import nebius.api.nebius.iam.v1.federation_certificate_service_pb2 as federation_certificate_service_pb2
import nebius.api.nebius.iam.v1.federation_pb2 as federation_pb2
import nebius.api.nebius.iam.v1.federation_service_pb2 as federation_service_pb2
import nebius.api.nebius.iam.v1.group_membership_pb2 as group_membership_pb2
import nebius.api.nebius.iam.v1.group_membership_service_pb2 as group_membership_service_pb2
import nebius.api.nebius.iam.v1.group_pb2 as group_pb2
import nebius.api.nebius.iam.v1.group_service_pb2 as group_service_pb2
import nebius.api.nebius.iam.v1.invitation_pb2 as invitation_pb2
import nebius.api.nebius.iam.v1.invitation_service_pb2 as invitation_service_pb2
import nebius.api.nebius.iam.v1.profile_service_pb2 as profile_service_pb2
import nebius.api.nebius.iam.v1.project_service_pb2 as project_service_pb2
import nebius.api.nebius.iam.v1.service_account_pb2 as service_account_pb2
import nebius.api.nebius.iam.v1.service_account_service_pb2 as service_account_service_pb2
import nebius.api.nebius.iam.v1.session_management_service_pb2 as session_management_service_pb2
import nebius.api.nebius.iam.v1.state_pb2 as state_pb2
import nebius.api.nebius.iam.v1.static_key_pb2 as static_key_pb2
import nebius.api.nebius.iam.v1.static_key_service_pb2 as static_key_service_pb2
import nebius.api.nebius.iam.v1.suspension_state_pb2 as suspension_state_pb2
import nebius.api.nebius.iam.v1.tenant_service_pb2 as tenant_service_pb2
import nebius.api.nebius.iam.v1.tenant_user_account_pb2 as tenant_user_account_pb2
import nebius.api.nebius.iam.v1.tenant_user_account_service_pb2 as tenant_user_account_service_pb2
import nebius.api.nebius.iam.v1.tenant_user_account_with_attributes_service_pb2 as tenant_user_account_with_attributes_service_pb2
import nebius.api.nebius.iam.v1.token_exchange_service_pb2 as token_exchange_service_pb2
import nebius.api.nebius.iam.v1.token_service_pb2 as token_service_pb2
import nebius.api.nebius.iam.v1.user_account_pb2 as user_account_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
import typing_extensions as typing_extensions
#@ local imports here @#

# file: nebius/iam/v1/access.proto
class Account(pb_classes.Message):
    __PB2_CLASS__ = access_pb2.Account
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Account",access_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class UserAccount(pb_classes.Message):
        __PB2_CLASS__ = access_pb2.Account.UserAccount
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Account.UserAccount",access_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(id, unset.UnsetType):
                self.id = id
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "id",
            ]
        
        @builtins.property
        def id(self) -> "builtins.str":
            return super()._get_field("id", explicit_presence=False,
            )
        @id.setter
        def id(self, value: "builtins.str|None") -> None:
            return super()._set_field("id",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "id":"id",
        }
        
    
    class ServiceAccount(pb_classes.Message):
        __PB2_CLASS__ = access_pb2.Account.ServiceAccount
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Account.ServiceAccount",access_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(id, unset.UnsetType):
                self.id = id
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "id",
            ]
        
        @builtins.property
        def id(self) -> "builtins.str":
            return super()._get_field("id", explicit_presence=False,
            )
        @id.setter
        def id(self, value: "builtins.str|None") -> None:
            return super()._set_field("id",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "id":"id",
        }
        
    
    class AnonymousAccount(pb_classes.Message):
        __PB2_CLASS__ = access_pb2.Account.AnonymousAccount
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Account.AnonymousAccount",access_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
        ) -> None:
            super().__init__(initial_message)
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
            ]
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        }
        
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "Account") -> None:
            super().__init__()
            self._message: "Account" = msg
    
    class __OneOfClass_type_user_account__(__OneOfClass_type__):
        field: typing.Literal["user_account"] = "user_account"
        
        def __init__(self, msg: "Account") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Account.UserAccount":
            return self._message.user_account
    
    class __OneOfClass_type_service_account__(__OneOfClass_type__):
        field: typing.Literal["service_account"] = "service_account"
        
        def __init__(self, msg: "Account") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Account.ServiceAccount":
            return self._message.service_account
    
    class __OneOfClass_type_anonymous_account__(__OneOfClass_type__):
        field: typing.Literal["anonymous_account"] = "anonymous_account"
        
        def __init__(self, msg: "Account") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Account.AnonymousAccount":
            return self._message.anonymous_account
    
    @builtins.property
    def type(self) -> __OneOfClass_type_user_account__|__OneOfClass_type_service_account__|__OneOfClass_type_anonymous_account__|None:
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "user_account":
                return self.__OneOfClass_type_user_account__(self)
            case "service_account":
                return self.__OneOfClass_type_service_account__(self)
            case "anonymous_account":
                return self.__OneOfClass_type_anonymous_account__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        user_account: "Account.UserAccount|access_pb2.Account.UserAccount|None|unset.UnsetType" = unset.Unset,
        service_account: "Account.ServiceAccount|access_pb2.Account.ServiceAccount|None|unset.UnsetType" = unset.Unset,
        anonymous_account: "Account.AnonymousAccount|access_pb2.Account.AnonymousAccount|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(user_account, unset.UnsetType):
            self.user_account = user_account
        if not isinstance(service_account, unset.UnsetType):
            self.service_account = service_account
        if not isinstance(anonymous_account, unset.UnsetType):
            self.anonymous_account = anonymous_account
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "user_account",
            "service_account",
            "anonymous_account",
            "UserAccount",
            "ServiceAccount",
            "AnonymousAccount",
            "type",
        ]
    
    @builtins.property
    def user_account(self) -> "Account.UserAccount|None":
        return super()._get_field("user_account", explicit_presence=True,
        wrap=Account.UserAccount,
        )
    @user_account.setter
    def user_account(self, value: "Account.UserAccount|access_pb2.Account.UserAccount|None") -> None:
        return super()._set_field("user_account",value,explicit_presence=True,
        )
    
    @builtins.property
    def service_account(self) -> "Account.ServiceAccount|None":
        return super()._get_field("service_account", explicit_presence=True,
        wrap=Account.ServiceAccount,
        )
    @service_account.setter
    def service_account(self, value: "Account.ServiceAccount|access_pb2.Account.ServiceAccount|None") -> None:
        return super()._set_field("service_account",value,explicit_presence=True,
        )
    
    @builtins.property
    def anonymous_account(self) -> "Account.AnonymousAccount|None":
        return super()._get_field("anonymous_account", explicit_presence=True,
        wrap=Account.AnonymousAccount,
        )
    @anonymous_account.setter
    def anonymous_account(self, value: "Account.AnonymousAccount|access_pb2.Account.AnonymousAccount|None") -> None:
        return super()._set_field("anonymous_account",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "user_account":"user_account",
        "service_account":"service_account",
        "anonymous_account":"anonymous_account",
        "UserAccount":"UserAccount",
        "ServiceAccount":"ServiceAccount",
        "AnonymousAccount":"AnonymousAccount",
        "type":"type",
    }
    
# file: nebius/iam/v1/access_key.proto
class AccessKey(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKey
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessKey",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
        status: "AccessKeyStatus|access_key_pb2.AccessKeyStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "AccessKeyStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=AccessKeyStatus,
        )
    @status.setter
    def status(self, value: "AccessKeyStatus|access_key_pb2.AccessKeyStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class AccessKeySpec(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKeySpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessKeySpec",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expires_at": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        expires_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(expires_at, unset.UnsetType):
            self.expires_at = expires_at
        if not isinstance(description, unset.UnsetType):
            self.description = description
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "expires_at",
            "description",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_at(self) -> "datetime.datetime":
        return super()._get_field("expires_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expires_at.setter
    def expires_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expires_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "expires_at":"expires_at",
        "description":"description",
    }
    
class AccessKeyStatus(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKeyStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessKeyStatus",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.AccessKeyStatus.State",access_key_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        INACTIVE = 2
        EXPIRED = 3
        DELETING = 4
        DELETED = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "AccessKeyStatus.State|access_key_pb2.AccessKeyStatus.State|None|unset.UnsetType" = unset.Unset,
        fingerprint: "builtins.str|None|unset.UnsetType" = unset.Unset,
        algorithm: "builtins.str|None|unset.UnsetType" = unset.Unset,
        key_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        secret: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(fingerprint, unset.UnsetType):
            self.fingerprint = fingerprint
        if not isinstance(algorithm, unset.UnsetType):
            self.algorithm = algorithm
        if not isinstance(key_size, unset.UnsetType):
            self.key_size = key_size
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
        if not isinstance(secret, unset.UnsetType):
            self.secret = secret
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "fingerprint",
            "algorithm",
            "key_size",
            "aws_access_key_id",
            "secret",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "AccessKeyStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=AccessKeyStatus.State,
        )
    @state.setter
    def state(self, value: "AccessKeyStatus.State|access_key_pb2.AccessKeyStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def fingerprint(self) -> "builtins.str":
        return super()._get_field("fingerprint", explicit_presence=False,
        )
    @fingerprint.setter
    def fingerprint(self, value: "builtins.str|None") -> None:
        return super()._set_field("fingerprint",value,explicit_presence=False,
        )
    
    @builtins.property
    def algorithm(self) -> "builtins.str":
        return super()._get_field("algorithm", explicit_presence=False,
        )
    @algorithm.setter
    def algorithm(self, value: "builtins.str|None") -> None:
        return super()._set_field("algorithm",value,explicit_presence=False,
        )
    
    @builtins.property
    def key_size(self) -> "builtins.int":
        return super()._get_field("key_size", explicit_presence=False,
        )
    @key_size.setter
    def key_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("key_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def secret(self) -> "builtins.str":
        return super()._get_field("secret", explicit_presence=False,
        )
    @secret.setter
    def secret(self, value: "builtins.str|None") -> None:
        return super()._set_field("secret",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "fingerprint":"fingerprint",
        "algorithm":"algorithm",
        "key_size":"key_size",
        "aws_access_key_id":"aws_access_key_id",
        "secret":"secret",
        "State":"State",
    }
    
# file: nebius/iam/v1/access_key_service.proto
class CreateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.CreateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class KeyIdentity(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.KeyIdentity
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.KeyIdentity",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_identity__(pb_classes.OneOf):
        name: builtins.str= "identity"
        
        def __init__(self, msg: "KeyIdentity") -> None:
            super().__init__()
            self._message: "KeyIdentity" = msg
    
    class __OneOfClass_identity_id__(__OneOfClass_identity__):
        field: typing.Literal["id"] = "id"
        
        def __init__(self, msg: "KeyIdentity") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.id
    
    class __OneOfClass_identity_aws_access_key_id__(__OneOfClass_identity__):
        field: typing.Literal["aws_access_key_id"] = "aws_access_key_id"
        
        def __init__(self, msg: "KeyIdentity") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.aws_access_key_id
    
    @builtins.property
    def identity(self) -> __OneOfClass_identity_id__|__OneOfClass_identity_aws_access_key_id__|None:
        field_name_1: str|None = super().which_field_in_oneof("identity")
        match field_name_1:
            case "id":
                return self.__OneOfClass_identity_id__(self)
            case "aws_access_key_id":
                return self.__OneOfClass_identity_aws_access_key_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "aws_access_key_id",
            "identity",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str|None":
        return super()._get_field("id", explicit_presence=True,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=True,
        )
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str|None":
        return super()._get_field("aws_access_key_id", explicit_presence=True,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "aws_access_key_id":"aws_access_key_id",
        "identity":"identity",
    }
    
class GetAccessKeySecretOnceRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeySecretOnceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessKeySecretOnceRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessKeyByIdRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeyByIdRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessKeyByIdRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessKeyByAwsIdRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeyByAwsIdRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessKeyByAwsIdRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "aws_access_key_id",
        ]
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "aws_access_key_id":"aws_access_key_id",
    }
    
class ListAccessKeysRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessKeysRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListAccessKeysByAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysByAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessKeysByAccountRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        """
        Represents the parent account ID.
        """
        
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class UpdateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.UpdateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ActivateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ActivateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ActivateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "KeyIdentity|access_key_service_pb2.KeyIdentity|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "KeyIdentity":
        return super()._get_field("id", explicit_presence=False,
        wrap=KeyIdentity,
        )
    @id.setter
    def id(self, value: "KeyIdentity|access_key_service_pb2.KeyIdentity|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeactivateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.DeactivateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeactivateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "KeyIdentity|access_key_service_pb2.KeyIdentity|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "KeyIdentity":
        return super()._get_field("id", explicit_presence=False,
        wrap=KeyIdentity,
        )
    @id.setter
    def id(self, value: "KeyIdentity|access_key_service_pb2.KeyIdentity|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeleteAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.DeleteAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "KeyIdentity|access_key_service_pb2.KeyIdentity|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "KeyIdentity":
        return super()._get_field("id", explicit_presence=False,
        wrap=KeyIdentity,
        )
    @id.setter
    def id(self, value: "KeyIdentity|access_key_service_pb2.KeyIdentity|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessKeySecretOnceResponse(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeySecretOnceResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessKeySecretOnceResponse",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        secret: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(secret, unset.UnsetType):
            self.secret = secret
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "secret",
        ]
    
    @builtins.property
    def secret(self) -> "builtins.str":
        return super()._get_field("secret", explicit_presence=False,
        )
    @secret.setter
    def secret(self, value: "builtins.str|None") -> None:
        return super()._set_field("secret",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "secret":"secret",
    }
    
class ListAccessKeysResponse(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessKeysResponse",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[AccessKey]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[AccessKey]":
        """
        List of access keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AccessKey,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[AccessKey]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class AccessKeyServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    Access keys management [deprecated]
    
    Supported until 09/01/26. Access keys v1 API is deprecated. Please use the v2 API instead. All existing keys remain accessible through the v2 API.
    
    This class provides the client methods for the ``.nebius.iam.v1.AccessKeyService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.AccessKeyService",access_key_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.AccessKeyService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    __service_deprecation_details__ = (
    """Service .nebius.iam.v1.AccessKeyService is deprecated. Supported until 09/01/26. Access keys v1 API is deprecated. Please use the v2 API instead. All existing keys remain accessible through the v2 API."""
    )
    
    def create(self,
        request: "CreateAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def list(self,
        request: "ListAccessKeysRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListAccessKeysRequest","ListAccessKeysResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAccessKeysRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAccessKeysResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=access_key_service_pb2.ListAccessKeysResponse,
            result_wrapper=pb_classes.simple_wrapper(ListAccessKeysResponse),
            **kwargs,
        )
    
    def list_by_account(self,
        request: "ListAccessKeysByAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListAccessKeysByAccountRequest","ListAccessKeysResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAccessKeysByAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAccessKeysResponse`.
        """
        
        return super().request(
            method="ListByAccount",
            request=request,
            result_pb2_class=access_key_service_pb2.ListAccessKeysResponse,
            result_wrapper=pb_classes.simple_wrapper(ListAccessKeysResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get_by_id(self,
        request: "GetAccessKeyByIdRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetAccessKeyByIdRequest","AccessKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAccessKeyByIdRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.AccessKey`.
        """
        
        return super().request(
            method="GetById",
            request=request,
            result_pb2_class=access_key_pb2.AccessKey,
            result_wrapper=pb_classes.simple_wrapper(AccessKey),
            **kwargs,
        )
    
    def get_by_aws_id(self,
        request: "GetAccessKeyByAwsIdRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetAccessKeyByAwsIdRequest","AccessKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAccessKeyByAwsIdRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.AccessKey`.
        """
        
        return super().request(
            method="GetByAwsId",
            request=request,
            result_pb2_class=access_key_pb2.AccessKey,
            result_wrapper=pb_classes.simple_wrapper(AccessKey),
            **kwargs,
        )
    
    def get_secret_once(self,
        request: "GetAccessKeySecretOnceRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetAccessKeySecretOnceRequest","GetAccessKeySecretOnceResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAccessKeySecretOnceRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.GetAccessKeySecretOnceResponse`.
        """
        
        return super().request(
            method="GetSecretOnce",
            request=request,
            result_pb2_class=access_key_service_pb2.GetAccessKeySecretOnceResponse,
            result_wrapper=pb_classes.simple_wrapper(GetAccessKeySecretOnceResponse),
            **kwargs,
        )
    
    def activate(self,
        request: "ActivateAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ActivateAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ActivateAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Activate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def deactivate(self,
        request: "DeactivateAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeactivateAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeactivateAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Deactivate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/access_permit.proto
class AccessPermit(pb_classes.Message):
    __PB2_CLASS__ = access_permit_pb2.AccessPermit
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessPermit",access_permit_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessPermitSpec|access_permit_pb2.AccessPermitSpec|None|unset.UnsetType" = unset.Unset,
        status: "AccessPermitStatus|access_permit_pb2.AccessPermitStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessPermitSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessPermitSpec,
        )
    @spec.setter
    def spec(self, value: "AccessPermitSpec|access_permit_pb2.AccessPermitSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "AccessPermitStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=AccessPermitStatus,
        )
    @status.setter
    def status(self, value: "AccessPermitStatus|access_permit_pb2.AccessPermitStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class AccessPermitSpec(pb_classes.Message):
    __PB2_CLASS__ = access_permit_pb2.AccessPermitSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessPermitSpec",access_permit_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        role: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
        if not isinstance(role, unset.UnsetType):
            self.role = role
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
            "role",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        Resource for granting access permit.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def role(self) -> "builtins.str":
        """
        Role for granting access permit.
        """
        
        return super()._get_field("role", explicit_presence=False,
        )
    @role.setter
    def role(self, value: "builtins.str|None") -> None:
        return super()._set_field("role",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
        "role":"role",
    }
    
class AccessPermitStatus(pb_classes.Message):
    __PB2_CLASS__ = access_permit_pb2.AccessPermitStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessPermitStatus",access_permit_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
# file: nebius/iam/v1/access_permit_service.proto
class CreateAccessPermitRequest(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.CreateAccessPermitRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateAccessPermitRequest",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessPermitSpec|access_permit_pb2.AccessPermitSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessPermitSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessPermitSpec,
        )
    @spec.setter
    def spec(self, value: "AccessPermitSpec|access_permit_pb2.AccessPermitSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ListAccessPermitRequest(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.ListAccessPermitRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessPermitRequest",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class DeleteAccessPermitRequest(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.DeleteAccessPermitRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteAccessPermitRequest",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessPermitRequest(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.GetAccessPermitRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessPermitRequest",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListAccessPermitResponse(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.ListAccessPermitResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessPermitResponse",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[AccessPermit]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[AccessPermit]":
        """
        List of access bindings returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AccessPermit,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[AccessPermit]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class AccessPermitServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.AccessPermitService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.AccessPermitService",access_permit_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.AccessPermitService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateAccessPermitRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateAccessPermitRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        Creates access permit for provided resource with provided role.
        Subject of access permit is also a parent of access permit.
        If resource is unknown - NOT_FOUND will be thrown.
        If parent of subject is not from resource's hierarchy - NOT_FOUND will be thrown.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateAccessPermitRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def list(self,
        request: "ListAccessPermitRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListAccessPermitRequest","ListAccessPermitResponse"]:
        """
        Lists access permits for provided parent
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAccessPermitRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAccessPermitResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=access_permit_service_pb2.ListAccessPermitResponse,
            result_wrapper=pb_classes.simple_wrapper(ListAccessPermitResponse),
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteAccessPermitRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteAccessPermitRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        Delete access permit by id
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteAccessPermitRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetAccessPermitRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetAccessPermitRequest","AccessPermit"]:
        """
        Gets access permit by id
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAccessPermitRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.AccessPermit`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=access_permit_pb2.AccessPermit,
            result_wrapper=pb_classes.simple_wrapper(AccessPermit),
            **kwargs,
        )
    

# file: nebius/iam/v1/auth_public_key.proto
class AuthPublicKey(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_pb2.AuthPublicKey
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AuthPublicKey",auth_public_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None|unset.UnsetType" = unset.Unset,
        status: "AuthPublicKeyStatus|auth_public_key_pb2.AuthPublicKeyStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AuthPublicKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AuthPublicKeySpec,
        )
    @spec.setter
    def spec(self, value: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "AuthPublicKeyStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=AuthPublicKeyStatus,
        )
    @status.setter
    def status(self, value: "AuthPublicKeyStatus|auth_public_key_pb2.AuthPublicKeyStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class AuthPublicKeySpec(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_pb2.AuthPublicKeySpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AuthPublicKeySpec",auth_public_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expires_at": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        expires_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        data: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(expires_at, unset.UnsetType):
            self.expires_at = expires_at
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(data, unset.UnsetType):
            self.data = data
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "expires_at",
            "description",
            "data",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_at(self) -> "datetime.datetime":
        return super()._get_field("expires_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expires_at.setter
    def expires_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expires_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def data(self) -> "builtins.str":
        return super()._get_field("data", explicit_presence=False,
        )
    @data.setter
    def data(self, value: "builtins.str|None") -> None:
        return super()._set_field("data",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "expires_at":"expires_at",
        "description":"description",
        "data":"data",
    }
    
class AuthPublicKeyStatus(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_pb2.AuthPublicKeyStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AuthPublicKeyStatus",auth_public_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.AuthPublicKeyStatus.State",auth_public_key_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        INACTIVE = 2
        EXPIRED = 3
        DELETING = 4
        DELETED = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "AuthPublicKeyStatus.State|auth_public_key_pb2.AuthPublicKeyStatus.State|None|unset.UnsetType" = unset.Unset,
        fingerprint: "builtins.str|None|unset.UnsetType" = unset.Unset,
        algorithm: "builtins.str|None|unset.UnsetType" = unset.Unset,
        key_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(fingerprint, unset.UnsetType):
            self.fingerprint = fingerprint
        if not isinstance(algorithm, unset.UnsetType):
            self.algorithm = algorithm
        if not isinstance(key_size, unset.UnsetType):
            self.key_size = key_size
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "fingerprint",
            "algorithm",
            "key_size",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "AuthPublicKeyStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=AuthPublicKeyStatus.State,
        )
    @state.setter
    def state(self, value: "AuthPublicKeyStatus.State|auth_public_key_pb2.AuthPublicKeyStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def fingerprint(self) -> "builtins.str":
        return super()._get_field("fingerprint", explicit_presence=False,
        )
    @fingerprint.setter
    def fingerprint(self, value: "builtins.str|None") -> None:
        return super()._set_field("fingerprint",value,explicit_presence=False,
        )
    
    @builtins.property
    def algorithm(self) -> "builtins.str":
        return super()._get_field("algorithm", explicit_presence=False,
        )
    @algorithm.setter
    def algorithm(self, value: "builtins.str|None") -> None:
        return super()._set_field("algorithm",value,explicit_presence=False,
        )
    
    @builtins.property
    def key_size(self) -> "builtins.int":
        return super()._get_field("key_size", explicit_presence=False,
        )
    @key_size.setter
    def key_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("key_size",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "fingerprint":"fingerprint",
        "algorithm":"algorithm",
        "key_size":"key_size",
        "State":"State",
    }
    
# file: nebius/iam/v1/auth_public_key_service.proto
class CreateAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.CreateAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AuthPublicKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AuthPublicKeySpec,
        )
    @spec.setter
    def spec(self, value: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.GetAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.ListAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListAuthPublicKeyByAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.ListAuthPublicKeyByAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAuthPublicKeyByAccountRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        """
        Represents the parent account ID.
        """
        
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class UpdateAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.UpdateAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AuthPublicKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AuthPublicKeySpec,
        )
    @spec.setter
    def spec(self, value: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ActivateAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.ActivateAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ActivateAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeactivateAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.DeactivateAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeactivateAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeleteAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.DeleteAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListAuthPublicKeyResponse(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.ListAuthPublicKeyResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAuthPublicKeyResponse",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[AuthPublicKey]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[AuthPublicKey]":
        """
        List of auth public keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AuthPublicKey,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[AuthPublicKey]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class AuthPublicKeyServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.AuthPublicKeyService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.AuthPublicKeyService",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.AuthPublicKeyService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateAuthPublicKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateAuthPublicKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetAuthPublicKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetAuthPublicKeyRequest","AuthPublicKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAuthPublicKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.AuthPublicKey`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=auth_public_key_pb2.AuthPublicKey,
            result_wrapper=pb_classes.simple_wrapper(AuthPublicKey),
            **kwargs,
        )
    
    def list(self,
        request: "ListAuthPublicKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListAuthPublicKeyRequest","ListAuthPublicKeyResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAuthPublicKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAuthPublicKeyResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=auth_public_key_service_pb2.ListAuthPublicKeyResponse,
            result_wrapper=pb_classes.simple_wrapper(ListAuthPublicKeyResponse),
            **kwargs,
        )
    
    def list_by_account(self,
        request: "ListAuthPublicKeyByAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListAuthPublicKeyByAccountRequest","ListAuthPublicKeyResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAuthPublicKeyByAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAuthPublicKeyResponse`.
        """
        
        return super().request(
            method="ListByAccount",
            request=request,
            result_pb2_class=auth_public_key_service_pb2.ListAuthPublicKeyResponse,
            result_wrapper=pb_classes.simple_wrapper(ListAuthPublicKeyResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateAuthPublicKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateAuthPublicKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def activate(self,
        request: "ActivateAuthPublicKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ActivateAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ActivateAuthPublicKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Activate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def deactivate(self,
        request: "DeactivateAuthPublicKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeactivateAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeactivateAuthPublicKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Deactivate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteAuthPublicKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteAuthPublicKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/state.proto
class State(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.State",state_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    STATE_UNSPECIFIED = 0
    ACTIVE = 1
    SCHEDULING_FOR_DELETION = 2
    SCHEDULED_FOR_DELETION = 3
    SCHEDULING_FOR_DELETION_BY_PARENT = 4
    SCHEDULED_FOR_DELETION_BY_PARENT = 5
    UNDELETING = 6
    PURGING = 7
    PURGED = 8
    CREATED = 9
    ACTIVATING = 10
    PARKING = 11
    PARKED = 12
    CREATING = 1001
    """
    DRAFT = 1000;
    """
    

# file: nebius/iam/v1/suspension_state.proto
class SuspensionState(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.SuspensionState",suspension_state_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    SUSPENSION_STATE_UNSPECIFIED = 0
    NONE = 1
    SUSPENDING = 2
    SUSPENDED = 3
    RESUMING = 4

# file: nebius/iam/v1/container.proto
class Container(pb_classes.Message):
    __PB2_CLASS__ = container_pb2.Container
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Container",container_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ContainerSpec|container_pb2.ContainerSpec|None|unset.UnsetType" = unset.Unset,
        status: "ContainerStatus|container_pb2.ContainerStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ContainerSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ContainerSpec,
        )
    @spec.setter
    def spec(self, value: "ContainerSpec|container_pb2.ContainerSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ContainerStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ContainerStatus,
        )
    @status.setter
    def status(self, value: "ContainerStatus|container_pb2.ContainerStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ContainerSpec(pb_classes.Message):
    __PB2_CLASS__ = container_pb2.ContainerSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ContainerSpec",container_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        region: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(region, unset.UnsetType):
            self.region = region
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "region",
        ]
    
    @builtins.property
    def region(self) -> "builtins.str":
        return super()._get_field("region", explicit_presence=False,
        )
    @region.setter
    def region(self, value: "builtins.str|None") -> None:
        return super()._set_field("region",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "region":"region",
    }
    
class ContainerStatus(pb_classes.Message):
    __PB2_CLASS__ = container_pb2.ContainerStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ContainerStatus",container_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        suspension_state: "SuspensionState|suspension_state_pb2.SuspensionState|None|unset.UnsetType" = unset.Unset,
        container_state: "State|state_pb2.State|None|unset.UnsetType" = unset.Unset,
        region: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(suspension_state, unset.UnsetType):
            self.suspension_state = suspension_state
        if not isinstance(container_state, unset.UnsetType):
            self.container_state = container_state
        if not isinstance(region, unset.UnsetType):
            self.region = region
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "suspension_state",
            "container_state",
            "region",
        ]
    
    @builtins.property
    def suspension_state(self) -> "SuspensionState":
        return super()._get_field("suspension_state", explicit_presence=False,
        wrap=SuspensionState,
        )
    @suspension_state.setter
    def suspension_state(self, value: "SuspensionState|suspension_state_pb2.SuspensionState|None") -> None:
        return super()._set_field("suspension_state",value,explicit_presence=False,
        )
    
    @builtins.property
    def container_state(self) -> "State":
        return super()._get_field("container_state", explicit_presence=False,
        wrap=State,
        )
    @container_state.setter
    def container_state(self, value: "State|state_pb2.State|None") -> None:
        return super()._set_field("container_state",value,explicit_presence=False,
        )
    
    @builtins.property
    def region(self) -> "builtins.str":
        return super()._get_field("region", explicit_presence=False,
        )
    @region.setter
    def region(self, value: "builtins.str|None") -> None:
        return super()._set_field("region",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "suspension_state":"suspension_state",
        "container_state":"container_state",
        "region":"region",
    }
    
# file: nebius/iam/v1/federated_credentials.proto
class FederatedCredentials(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_pb2.FederatedCredentials
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederatedCredentials",federated_credentials_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None|unset.UnsetType" = unset.Unset,
        status: "FederatedCredentialsStatus|federated_credentials_pb2.FederatedCredentialsStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederatedCredentialsSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederatedCredentialsSpec,
        )
    @spec.setter
    def spec(self, value: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FederatedCredentialsStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FederatedCredentialsStatus,
        )
    @status.setter
    def status(self, value: "FederatedCredentialsStatus|federated_credentials_pb2.FederatedCredentialsStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class FederatedCredentialsSpec(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_pb2.FederatedCredentialsSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederatedCredentialsSpec",federated_credentials_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_credentials_provider__(pb_classes.OneOf):
        name: builtins.str= "credentials_provider"
        
        def __init__(self, msg: "FederatedCredentialsSpec") -> None:
            super().__init__()
            self._message: "FederatedCredentialsSpec" = msg
    
    class __OneOfClass_credentials_provider_oidc_provider__(__OneOfClass_credentials_provider__):
        field: typing.Literal["oidc_provider"] = "oidc_provider"
        
        def __init__(self, msg: "FederatedCredentialsSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "OidcCredentialsProvider":
            return self._message.oidc_provider
    
    @builtins.property
    def credentials_provider(self) -> __OneOfClass_credentials_provider_oidc_provider__|None:
        """
        provider of federated credentials used for federated subject authentication
        """
        
        field_name_1: str|None = super().which_field_in_oneof("credentials_provider")
        match field_name_1:
            case "oidc_provider":
                return self.__OneOfClass_credentials_provider_oidc_provider__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        oidc_provider: "OidcCredentialsProvider|federated_credentials_pb2.OidcCredentialsProvider|None|unset.UnsetType" = unset.Unset,
        federated_subject_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subject_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(oidc_provider, unset.UnsetType):
            self.oidc_provider = oidc_provider
        if not isinstance(federated_subject_id, unset.UnsetType):
            self.federated_subject_id = federated_subject_id
        if not isinstance(subject_id, unset.UnsetType):
            self.subject_id = subject_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "oidc_provider",
            "federated_subject_id",
            "subject_id",
            "credentials_provider",
        ]
    
    @builtins.property
    def oidc_provider(self) -> "OidcCredentialsProvider|None":
        return super()._get_field("oidc_provider", explicit_presence=True,
        wrap=OidcCredentialsProvider,
        )
    @oidc_provider.setter
    def oidc_provider(self, value: "OidcCredentialsProvider|federated_credentials_pb2.OidcCredentialsProvider|None") -> None:
        return super()._set_field("oidc_provider",value,explicit_presence=True,
        )
    
    @builtins.property
    def federated_subject_id(self) -> "builtins.str":
        """
        Federated subject ID.For oidc_provider subject will be calculated based on the sub claim of the JWT federation token.
        """
        
        return super()._get_field("federated_subject_id", explicit_presence=False,
        )
    @federated_subject_id.setter
    def federated_subject_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federated_subject_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def subject_id(self) -> "builtins.str":
        """
        IAM subject, in which federated subject will be impersonated to. E.g. for workload identities it will be IAM service account.
        """
        
        return super()._get_field("subject_id", explicit_presence=False,
        )
    @subject_id.setter
    def subject_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subject_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "oidc_provider":"oidc_provider",
        "federated_subject_id":"federated_subject_id",
        "subject_id":"subject_id",
        "credentials_provider":"credentials_provider",
    }
    
class OidcCredentialsProvider(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_pb2.OidcCredentialsProvider
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.OidcCredentialsProvider",federated_credentials_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        issuer_url: "builtins.str|None|unset.UnsetType" = unset.Unset,
        jwk_set_json: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(issuer_url, unset.UnsetType):
            self.issuer_url = issuer_url
        if not isinstance(jwk_set_json, unset.UnsetType):
            self.jwk_set_json = jwk_set_json
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "issuer_url",
            "jwk_set_json",
        ]
    
    @builtins.property
    def issuer_url(self) -> "builtins.str":
        """
        *
        It's not required provider OIDC issuer should be real OIDC provider, but should expose OIDC configuration
        with "/.well-known/openid-configuration" endpoint. Configuration should contains the "jwks_uri" endpoint
        where the JSON Web Key Set (JWKS) can be found; this set contains public keys used to verify
        JSON Web Tokens (JWTs) issued by an identity provider.
        
        Limitations for external OIDC providers:
        
        
        * token service limits the number of handled keys by 50. If your JWKS return more than 50,
          the only first 50  will be used for signature verifying.
        * response size for jwks_uri and "/.well-known/openid-configuration limited by 100KB.
        """
        
        return super()._get_field("issuer_url", explicit_presence=False,
        )
    @issuer_url.setter
    def issuer_url(self, value: "builtins.str|None") -> None:
        return super()._set_field("issuer_url",value,explicit_presence=False,
        )
    
    @builtins.property
    def jwk_set_json(self) -> "builtins.str":
        """
        *
        Literally json, which represents JWKS with public keys for JWT verification.
        It worth mentioned that in a case of adding/rotating keys the jwk_set_json also should be updated here.
        Besides, the "issuer" parameter should be set even if the JWKS will be resolved locally.
        """
        
        return super()._get_field("jwk_set_json", explicit_presence=False,
        )
    @jwk_set_json.setter
    def jwk_set_json(self, value: "builtins.str|None") -> None:
        return super()._set_field("jwk_set_json",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "issuer_url":"issuer_url",
        "jwk_set_json":"jwk_set_json",
    }
    
class FederatedCredentialsStatus(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_pb2.FederatedCredentialsStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederatedCredentialsStatus",federated_credentials_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
# file: nebius/iam/v1/federated_credentials_service.proto
class GetFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.GetFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetByNameFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.GetByNameFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetByNameFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Container (project), which contains desired credentials.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Federated credentials name.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class CreateFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.CreateFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederatedCredentialsSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederatedCredentialsSpec,
        )
    @spec.setter
    def spec(self, value: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.UpdateFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederatedCredentialsSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederatedCredentialsSpec,
        )
    @spec.setter
    def spec(self, value: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ListFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.ListFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the parent NID
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response. Default is 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListFederatedCredentialsResponse(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.ListFederatedCredentialsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederatedCredentialsResponse",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[FederatedCredentials]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[FederatedCredentials]":
        """
        List of user accounts returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(FederatedCredentials,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[FederatedCredentials]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class DeleteFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.DeleteFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class FederatedCredentialsServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.FederatedCredentialsService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.FederatedCredentialsService",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.FederatedCredentialsService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetFederatedCredentialsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetFederatedCredentialsRequest","FederatedCredentials"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetFederatedCredentialsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.FederatedCredentials`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=federated_credentials_pb2.FederatedCredentials,
            result_wrapper=pb_classes.simple_wrapper(FederatedCredentials),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetByNameFederatedCredentialsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetByNameFederatedCredentialsRequest","FederatedCredentials"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetByNameFederatedCredentialsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.FederatedCredentials`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=federated_credentials_pb2.FederatedCredentials,
            result_wrapper=pb_classes.simple_wrapper(FederatedCredentials),
            **kwargs,
        )
    
    def list(self,
        request: "ListFederatedCredentialsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListFederatedCredentialsRequest","ListFederatedCredentialsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListFederatedCredentialsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListFederatedCredentialsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=federated_credentials_service_pb2.ListFederatedCredentialsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListFederatedCredentialsResponse),
            **kwargs,
        )
    
    def create(self,
        request: "CreateFederatedCredentialsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateFederatedCredentialsRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateFederatedCredentialsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def update(self,
        request: "UpdateFederatedCredentialsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateFederatedCredentialsRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateFederatedCredentialsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteFederatedCredentialsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteFederatedCredentialsRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteFederatedCredentialsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/federation.proto
class Federation(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.Federation
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Federation",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationSpec|federation_pb2.FederationSpec|None|unset.UnsetType" = unset.Unset,
        status: "FederationStatus|federation_pb2.FederationStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationSpec,
        )
    @spec.setter
    def spec(self, value: "FederationSpec|federation_pb2.FederationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FederationStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FederationStatus,
        )
    @status.setter
    def status(self, value: "FederationStatus|federation_pb2.FederationStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class FederationSpec(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.FederationSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationSpec",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_settings__(pb_classes.OneOf):
        name: builtins.str= "settings"
        
        def __init__(self, msg: "FederationSpec") -> None:
            super().__init__()
            self._message: "FederationSpec" = msg
    
    class __OneOfClass_settings_saml_settings__(__OneOfClass_settings__):
        field: typing.Literal["saml_settings"] = "saml_settings"
        
        def __init__(self, msg: "FederationSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "SamlSettings":
            return self._message.saml_settings
    
    @builtins.property
    def settings(self) -> __OneOfClass_settings_saml_settings__|None:
        field_name_1: str|None = super().which_field_in_oneof("settings")
        match field_name_1:
            case "saml_settings":
                return self.__OneOfClass_settings_saml_settings__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        user_account_auto_creation: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        active: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        saml_settings: "SamlSettings|federation_pb2.SamlSettings|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(user_account_auto_creation, unset.UnsetType):
            self.user_account_auto_creation = user_account_auto_creation
        if not isinstance(active, unset.UnsetType):
            self.active = active
        if not isinstance(saml_settings, unset.UnsetType):
            self.saml_settings = saml_settings
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "user_account_auto_creation",
            "active",
            "saml_settings",
            "settings",
        ]
    
    @builtins.property
    def user_account_auto_creation(self) -> "builtins.bool":
        return super()._get_field("user_account_auto_creation", explicit_presence=False,
        )
    @user_account_auto_creation.setter
    def user_account_auto_creation(self, value: "builtins.bool|None") -> None:
        return super()._set_field("user_account_auto_creation",value,explicit_presence=False,
        )
    
    @builtins.property
    def active(self) -> "builtins.bool":
        return super()._get_field("active", explicit_presence=False,
        )
    @active.setter
    def active(self, value: "builtins.bool|None") -> None:
        return super()._set_field("active",value,explicit_presence=False,
        )
    
    @builtins.property
    def saml_settings(self) -> "SamlSettings|None":
        return super()._get_field("saml_settings", explicit_presence=True,
        wrap=SamlSettings,
        )
    @saml_settings.setter
    def saml_settings(self, value: "SamlSettings|federation_pb2.SamlSettings|None") -> None:
        return super()._set_field("saml_settings",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "user_account_auto_creation":"user_account_auto_creation",
        "active":"active",
        "saml_settings":"saml_settings",
        "settings":"settings",
    }
    
class SamlSettings(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.SamlSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.SamlSettings",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        idp_issuer: "builtins.str|None|unset.UnsetType" = unset.Unset,
        sso_url: "builtins.str|None|unset.UnsetType" = unset.Unset,
        force_authn: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(idp_issuer, unset.UnsetType):
            self.idp_issuer = idp_issuer
        if not isinstance(sso_url, unset.UnsetType):
            self.sso_url = sso_url
        if not isinstance(force_authn, unset.UnsetType):
            self.force_authn = force_authn
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "idp_issuer",
            "sso_url",
            "force_authn",
        ]
    
    @builtins.property
    def idp_issuer(self) -> "builtins.str":
        return super()._get_field("idp_issuer", explicit_presence=False,
        )
    @idp_issuer.setter
    def idp_issuer(self, value: "builtins.str|None") -> None:
        return super()._set_field("idp_issuer",value,explicit_presence=False,
        )
    
    @builtins.property
    def sso_url(self) -> "builtins.str":
        return super()._get_field("sso_url", explicit_presence=False,
        )
    @sso_url.setter
    def sso_url(self, value: "builtins.str|None") -> None:
        return super()._set_field("sso_url",value,explicit_presence=False,
        )
    
    @builtins.property
    def force_authn(self) -> "builtins.bool":
        """
        if "true", the identity provider MUST authenticate the presenter directly rather than rely on a previous security context.
        """
        
        return super()._get_field("force_authn", explicit_presence=False,
        )
    @force_authn.setter
    def force_authn(self, value: "builtins.bool|None") -> None:
        return super()._set_field("force_authn",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "idp_issuer":"idp_issuer",
        "sso_url":"sso_url",
        "force_authn":"force_authn",
    }
    
class FederationStatus(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.FederationStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationStatus",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.FederationStatus.State",federation_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        ACTIVE = 1
        INACTIVE = 2
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "FederationStatus.State|federation_pb2.FederationStatus.State|None|unset.UnsetType" = unset.Unset,
        users_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        certificates_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(users_count, unset.UnsetType):
            self.users_count = users_count
        if not isinstance(certificates_count, unset.UnsetType):
            self.certificates_count = certificates_count
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "users_count",
            "certificates_count",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "FederationStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=FederationStatus.State,
        )
    @state.setter
    def state(self, value: "FederationStatus.State|federation_pb2.FederationStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def users_count(self) -> "builtins.int":
        return super()._get_field("users_count", explicit_presence=False,
        )
    @users_count.setter
    def users_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("users_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def certificates_count(self) -> "builtins.int":
        return super()._get_field("certificates_count", explicit_presence=False,
        )
    @certificates_count.setter
    def certificates_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("certificates_count",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "users_count":"users_count",
        "certificates_count":"certificates_count",
        "State":"State",
    }
    
# file: nebius/iam/v1/federation_certificate.proto
class FederationCertificate(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_pb2.FederationCertificate
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationCertificate",federation_certificate_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None|unset.UnsetType" = unset.Unset,
        status: "FederationCertificateStatus|federation_certificate_pb2.FederationCertificateStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationCertificateSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationCertificateSpec,
        )
    @spec.setter
    def spec(self, value: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FederationCertificateStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FederationCertificateStatus,
        )
    @status.setter
    def status(self, value: "FederationCertificateStatus|federation_certificate_pb2.FederationCertificateStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class FederationCertificateSpec(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_pb2.FederationCertificateSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationCertificateSpec",federation_certificate_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        data: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(data, unset.UnsetType):
            self.data = data
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
            "data",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def data(self) -> "builtins.str":
        return super()._get_field("data", explicit_presence=False,
        )
    @data.setter
    def data(self, value: "builtins.str|None") -> None:
        return super()._set_field("data",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
        "data":"data",
    }
    
class FederationCertificateStatus(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_pb2.FederationCertificateStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationCertificateStatus",federation_certificate_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "not_before": well_known_1.ts_mask,
        "not_after": well_known_1.ts_mask,
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.FederationCertificateStatus.State",federation_certificate_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        EXPIRED = 2
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "FederationCertificateStatus.State|federation_certificate_pb2.FederationCertificateStatus.State|None|unset.UnsetType" = unset.Unset,
        fingerprint: "builtins.str|None|unset.UnsetType" = unset.Unset,
        algorithm: "builtins.str|None|unset.UnsetType" = unset.Unset,
        key_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        not_before: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        not_after: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(fingerprint, unset.UnsetType):
            self.fingerprint = fingerprint
        if not isinstance(algorithm, unset.UnsetType):
            self.algorithm = algorithm
        if not isinstance(key_size, unset.UnsetType):
            self.key_size = key_size
        if not isinstance(not_before, unset.UnsetType):
            self.not_before = not_before
        if not isinstance(not_after, unset.UnsetType):
            self.not_after = not_after
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "fingerprint",
            "algorithm",
            "key_size",
            "not_before",
            "not_after",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "FederationCertificateStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=FederationCertificateStatus.State,
        )
    @state.setter
    def state(self, value: "FederationCertificateStatus.State|federation_certificate_pb2.FederationCertificateStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def fingerprint(self) -> "builtins.str":
        return super()._get_field("fingerprint", explicit_presence=False,
        )
    @fingerprint.setter
    def fingerprint(self, value: "builtins.str|None") -> None:
        return super()._set_field("fingerprint",value,explicit_presence=False,
        )
    
    @builtins.property
    def algorithm(self) -> "builtins.str":
        return super()._get_field("algorithm", explicit_presence=False,
        )
    @algorithm.setter
    def algorithm(self, value: "builtins.str|None") -> None:
        return super()._set_field("algorithm",value,explicit_presence=False,
        )
    
    @builtins.property
    def key_size(self) -> "builtins.int":
        return super()._get_field("key_size", explicit_presence=False,
        )
    @key_size.setter
    def key_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("key_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def not_before(self) -> "datetime.datetime":
        return super()._get_field("not_before", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @not_before.setter
    def not_before(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("not_before",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def not_after(self) -> "datetime.datetime":
        return super()._get_field("not_after", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @not_after.setter
    def not_after(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("not_after",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "fingerprint":"fingerprint",
        "algorithm":"algorithm",
        "key_size":"key_size",
        "not_before":"not_before",
        "not_after":"not_after",
        "State":"State",
    }
    
# file: nebius/iam/v1/federation_certificate_service.proto
class CreateFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.CreateFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationCertificateSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationCertificateSpec,
        )
    @spec.setter
    def spec(self, value: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.GetFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFederationCertificateByFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.ListFederationCertificateByFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederationCertificateByFederationRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "federation_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        """
        Represents the parent federation ID. Corresponds to the parent_id value.
        """
        
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "federation_id":"federation_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class UpdateFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.UpdateFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationCertificateSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationCertificateSpec,
        )
    @spec.setter
    def spec(self, value: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateBulkFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.UpdateBulkFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateBulkFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        updates: "abc.Iterable[UpdateFederationCertificateRequest]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
        if not isinstance(updates, unset.UnsetType):
            self.updates = updates
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "federation_id",
            "updates",
        ]
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        """
        Represents the parent federation ID. All certificates in update should have identical parent id.
        """
        
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def updates(self) -> "abc.MutableSequence[UpdateFederationCertificateRequest]":
        """
        If target certificate contains id - the existing one will be updates, otherwise the new one will be created.
        """
        
        return super()._get_field("updates", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(UpdateFederationCertificateRequest,None,None),
        )
    @updates.setter
    def updates(self, value: "abc.Iterable[UpdateFederationCertificateRequest]|None") -> None:
        return super()._set_field("updates",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "federation_id":"federation_id",
        "updates":"updates",
    }
    
class DeleteFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.DeleteFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFederationCertificateResponse(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.ListFederationCertificateResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederationCertificateResponse",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[FederationCertificate]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[FederationCertificate]":
        """
        List of public keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(FederationCertificate,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[FederationCertificate]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class FederationCertificateServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.FederationCertificateService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.FederationCertificateService",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.FederationCertificateService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateFederationCertificateRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateFederationCertificateRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateFederationCertificateRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetFederationCertificateRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetFederationCertificateRequest","FederationCertificate"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetFederationCertificateRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.FederationCertificate`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=federation_certificate_pb2.FederationCertificate,
            result_wrapper=pb_classes.simple_wrapper(FederationCertificate),
            **kwargs,
        )
    
    def list_by_federation(self,
        request: "ListFederationCertificateByFederationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListFederationCertificateByFederationRequest","ListFederationCertificateResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListFederationCertificateByFederationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListFederationCertificateResponse`.
        """
        
        return super().request(
            method="ListByFederation",
            request=request,
            result_pb2_class=federation_certificate_service_pb2.ListFederationCertificateResponse,
            result_wrapper=pb_classes.simple_wrapper(ListFederationCertificateResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateFederationCertificateRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateFederationCertificateRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateFederationCertificateRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def update_bulk(self,
        request: "UpdateBulkFederationCertificateRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateBulkFederationCertificateRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        Replaces all federation's certificates with provided in the request. Certificates which are not presented will be removed.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateBulkFederationCertificateRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="UpdateBulk",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteFederationCertificateRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteFederationCertificateRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteFederationCertificateRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/federation_service.proto
class CreateFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.CreateFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationSpec|federation_pb2.FederationSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationSpec,
        )
    @spec.setter
    def spec(self, value: "FederationSpec|federation_pb2.FederationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.GetFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFederationsRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.ListFederationsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederationsRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListFederationsResponse(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.ListFederationsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederationsResponse",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Federation]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Federation]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Federation,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Federation]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class UpdateFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.UpdateFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationSpec|federation_pb2.FederationSpec|None|unset.UnsetType" = unset.Unset,
        status: "FederationStatus|federation_pb2.FederationStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationSpec,
        )
    @spec.setter
    def spec(self, value: "FederationSpec|federation_pb2.FederationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FederationStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FederationStatus,
        )
    @status.setter
    def status(self, value: "FederationStatus|federation_pb2.FederationStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ActivateFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.ActivateFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ActivateFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "federation_id",
        ]
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "federation_id":"federation_id",
    }
    
class DeactivateFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.DeactivateFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeactivateFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "federation_id",
        ]
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "federation_id":"federation_id",
    }
    
class DeleteFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.DeleteFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class FederationServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.FederationService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.FederationService",federation_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.FederationService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateFederationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateFederationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateFederationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetFederationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetFederationRequest","Federation"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetFederationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Federation`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=federation_pb2.Federation,
            result_wrapper=pb_classes.simple_wrapper(Federation),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["v1_1.GetByNameRequest","Federation"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Federation`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=federation_pb2.Federation,
            result_wrapper=pb_classes.simple_wrapper(Federation),
            **kwargs,
        )
    
    def list(self,
        request: "ListFederationsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListFederationsRequest","ListFederationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListFederationsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListFederationsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=federation_service_pb2.ListFederationsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListFederationsResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateFederationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateFederationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateFederationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def activate(self,
        request: "ActivateFederationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ActivateFederationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        *
        Activates an existing federation.
        By default, a newly created federation is in the active state.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ActivateFederationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Activate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def deactivate(self,
        request: "DeactivateFederationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeactivateFederationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        *
        Deactivates an existing federation.
        When a federation is inactive, all users under it will be unable to authenticate.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeactivateFederationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Deactivate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteFederationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteFederationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteFederationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/group.proto
class Group(pb_classes.Message):
    __PB2_CLASS__ = group_pb2.Group
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Group",group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupSpec|group_pb2.GroupSpec|None|unset.UnsetType" = unset.Unset,
        status: "GroupStatus|group_pb2.GroupStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupSpec,
        )
    @spec.setter
    def spec(self, value: "GroupSpec|group_pb2.GroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "GroupStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=GroupStatus,
        )
    @status.setter
    def status(self, value: "GroupStatus|group_pb2.GroupStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class GroupSpec(pb_classes.Message):
    __PB2_CLASS__ = group_pb2.GroupSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupSpec",group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class GroupStatus(pb_classes.Message):
    __PB2_CLASS__ = group_pb2.GroupStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupStatus",group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.GroupStatus.State",group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        ACTIVE = 1
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "GroupStatus.State|group_pb2.GroupStatus.State|None|unset.UnsetType" = unset.Unset,
        members_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        service_accounts_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        tenant_user_accounts_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(members_count, unset.UnsetType):
            self.members_count = members_count
        if not isinstance(service_accounts_count, unset.UnsetType):
            self.service_accounts_count = service_accounts_count
        if not isinstance(tenant_user_accounts_count, unset.UnsetType):
            self.tenant_user_accounts_count = tenant_user_accounts_count
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "members_count",
            "service_accounts_count",
            "tenant_user_accounts_count",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "GroupStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=GroupStatus.State,
        )
    @state.setter
    def state(self, value: "GroupStatus.State|group_pb2.GroupStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def members_count(self) -> "builtins.int":
        return super()._get_field("members_count", explicit_presence=False,
        )
    @members_count.setter
    def members_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("members_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def service_accounts_count(self) -> "builtins.int":
        return super()._get_field("service_accounts_count", explicit_presence=False,
        )
    @service_accounts_count.setter
    def service_accounts_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("service_accounts_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def tenant_user_accounts_count(self) -> "builtins.int":
        return super()._get_field("tenant_user_accounts_count", explicit_presence=False,
        )
    @tenant_user_accounts_count.setter
    def tenant_user_accounts_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("tenant_user_accounts_count",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "members_count":"members_count",
        "service_accounts_count":"service_accounts_count",
        "tenant_user_accounts_count":"tenant_user_accounts_count",
        "State":"State",
    }
    
# file: nebius/iam/v1/service_account.proto
class ServiceAccount(pb_classes.Message):
    __PB2_CLASS__ = service_account_pb2.ServiceAccount
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccount",service_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None|unset.UnsetType" = unset.Unset,
        status: "ServiceAccountStatus|service_account_pb2.ServiceAccountStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ServiceAccountSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ServiceAccountSpec,
        )
    @spec.setter
    def spec(self, value: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ServiceAccountStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ServiceAccountStatus,
        )
    @status.setter
    def status(self, value: "ServiceAccountStatus|service_account_pb2.ServiceAccountStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ServiceAccountSpec(pb_classes.Message):
    __PB2_CLASS__ = service_account_pb2.ServiceAccountSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccountSpec",service_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
    }
    
class ServiceAccountStatus(pb_classes.Message):
    __PB2_CLASS__ = service_account_pb2.ServiceAccountStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccountStatus",service_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        active: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(active, unset.UnsetType):
            self.active = active
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "active",
        ]
    
    @builtins.property
    def active(self) -> "builtins.bool":
        return super()._get_field("active", explicit_presence=False,
        )
    @active.setter
    def active(self, value: "builtins.bool|None") -> None:
        return super()._set_field("active",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "active":"active",
    }
    
class ServiceAccountAttributes(pb_classes.Message):
    """
    see also nebius/iam/v1/tenant_user_account.proto/UserAttributes
    """
    
    __PB2_CLASS__ = service_account_pb2.ServiceAccountAttributes
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccountAttributes",service_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(description, unset.UnsetType):
            self.description = description
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
            "description",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
        "description":"description",
    }
    
# file: nebius/iam/v1/user_account.proto
class UserAccountExternalId(pb_classes.Message):
    __PB2_CLASS__ = user_account_pb2.UserAccountExternalId
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserAccountExternalId",user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        federation_user_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(federation_user_account_id, unset.UnsetType):
            self.federation_user_account_id = federation_user_account_id
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "federation_user_account_id",
            "federation_id",
        ]
    
    @builtins.property
    def federation_user_account_id(self) -> "builtins.str":
        return super()._get_field("federation_user_account_id", explicit_presence=False,
        )
    @federation_user_account_id.setter
    def federation_user_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_user_account_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "federation_user_account_id":"federation_user_account_id",
        "federation_id":"federation_id",
    }
    
class UserAccountStatus(pb_classes.Message):
    __PB2_CLASS__ = user_account_pb2.UserAccountStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserAccountStatus",user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.UserAccountStatus.State",user_account_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        """
        usual state when federated user can log into the system and view/manage granted resources in one or more tenants
        """
        
        INACTIVE = 2
        """
        federated user can be blocked (manually or by any specific automated process), in this state user cannot log into the system
        """
        
        DELETING = 3
        """
        federated user can be deleted/forgot, in this state user cannot log into the system and various internal removal interactions are in progress
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "UserAccountStatus.State|user_account_pb2.UserAccountStatus.State|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "UserAccountStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=UserAccountStatus.State,
        )
    @state.setter
    def state(self, value: "UserAccountStatus.State|user_account_pb2.UserAccountStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "State":"State",
    }
    
# file: nebius/iam/v1/tenant_user_account.proto
class TenantUserAccount(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccount
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccount",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "TenantUserAccountSpec|tenant_user_account_pb2.TenantUserAccountSpec|None|unset.UnsetType" = unset.Unset,
        status: "TenantUserAccountStatus|tenant_user_account_pb2.TenantUserAccountStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "TenantUserAccountSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=TenantUserAccountSpec,
        )
    @spec.setter
    def spec(self, value: "TenantUserAccountSpec|tenant_user_account_pb2.TenantUserAccountSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "TenantUserAccountStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=TenantUserAccountStatus,
        )
    @status.setter
    def status(self, value: "TenantUserAccountStatus|tenant_user_account_pb2.TenantUserAccountStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class TenantUserAccountWithAttributes(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccountWithAttributes
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccountWithAttributes",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_attributesOptional__(pb_classes.OneOf):
        name: builtins.str= "attributesOptional"
        
        def __init__(self, msg: "TenantUserAccountWithAttributes") -> None:
            super().__init__()
            self._message: "TenantUserAccountWithAttributes" = msg
    
    class __OneOfClass_attributesOptional_attributes__(__OneOfClass_attributesOptional__):
        field: typing.Literal["attributes"] = "attributes"
        
        def __init__(self, msg: "TenantUserAccountWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "UserAttributes":
            return self._message.attributes
    
    class __OneOfClass_attributesOptional_error__(__OneOfClass_attributesOptional__):
        field: typing.Literal["error"] = "error"
        
        def __init__(self, msg: "TenantUserAccountWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Error":
            return self._message.error
    
    @builtins.property
    def attributesOptional(self) -> __OneOfClass_attributesOptional_attributes__|__OneOfClass_attributesOptional_error__|None:
        field_name_1: str|None = super().which_field_in_oneof("attributesOptional")
        match field_name_1:
            case "attributes":
                return self.__OneOfClass_attributesOptional_attributes__(self)
            case "error":
                return self.__OneOfClass_attributesOptional_error__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_user_account: "TenantUserAccount|tenant_user_account_pb2.TenantUserAccount|None|unset.UnsetType" = unset.Unset,
        attributes: "UserAttributes|tenant_user_account_pb2.UserAttributes|None|unset.UnsetType" = unset.Unset,
        error: "Error|tenant_user_account_pb2.Error|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_user_account, unset.UnsetType):
            self.tenant_user_account = tenant_user_account
        if not isinstance(attributes, unset.UnsetType):
            self.attributes = attributes
        if not isinstance(error, unset.UnsetType):
            self.error = error
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_user_account",
            "attributes",
            "error",
            "attributesOptional",
        ]
    
    @builtins.property
    def tenant_user_account(self) -> "TenantUserAccount":
        return super()._get_field("tenant_user_account", explicit_presence=False,
        wrap=TenantUserAccount,
        )
    @tenant_user_account.setter
    def tenant_user_account(self, value: "TenantUserAccount|tenant_user_account_pb2.TenantUserAccount|None") -> None:
        return super()._set_field("tenant_user_account",value,explicit_presence=False,
        )
    
    @builtins.property
    def attributes(self) -> "UserAttributes|None":
        return super()._get_field("attributes", explicit_presence=True,
        wrap=UserAttributes,
        )
    @attributes.setter
    def attributes(self, value: "UserAttributes|tenant_user_account_pb2.UserAttributes|None") -> None:
        return super()._set_field("attributes",value,explicit_presence=True,
        )
    
    @builtins.property
    def error(self) -> "Error|None":
        """
        in a case of issues of getting attributes from pds service, we can still return some data from cpl
        """
        
        return super()._get_field("error", explicit_presence=True,
        wrap=Error,
        )
    @error.setter
    def error(self, value: "Error|tenant_user_account_pb2.Error|None") -> None:
        return super()._set_field("error",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_user_account":"tenant_user_account",
        "attributes":"attributes",
        "error":"error",
        "attributesOptional":"attributesOptional",
    }
    
class UserAttributes(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.UserAttributes
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserAttributes",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__sub__(pb_classes.OneOf):
        name: builtins.str= "_sub"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__sub_sub__(__OneOfClass__sub__):
        field: typing.Literal["sub"] = "sub"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.sub
    
    @builtins.property
    def _sub(self) -> __OneOfClass__sub_sub__|None:
        field_name_1: str|None = super().which_field_in_oneof("_sub")
        match field_name_1:
            case "sub":
                return self.__OneOfClass__sub_sub__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__name__(pb_classes.OneOf):
        name: builtins.str= "_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__name_name__(__OneOfClass__name__):
        field: typing.Literal["name"] = "name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.name
    
    @builtins.property
    def _name(self) -> __OneOfClass__name_name__|None:
        field_name_1: str|None = super().which_field_in_oneof("_name")
        match field_name_1:
            case "name":
                return self.__OneOfClass__name_name__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__given_name__(pb_classes.OneOf):
        name: builtins.str= "_given_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__given_name_given_name__(__OneOfClass__given_name__):
        field: typing.Literal["given_name"] = "given_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.given_name
    
    @builtins.property
    def _given_name(self) -> __OneOfClass__given_name_given_name__|None:
        field_name_1: str|None = super().which_field_in_oneof("_given_name")
        match field_name_1:
            case "given_name":
                return self.__OneOfClass__given_name_given_name__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__family_name__(pb_classes.OneOf):
        name: builtins.str= "_family_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__family_name_family_name__(__OneOfClass__family_name__):
        field: typing.Literal["family_name"] = "family_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.family_name
    
    @builtins.property
    def _family_name(self) -> __OneOfClass__family_name_family_name__|None:
        field_name_1: str|None = super().which_field_in_oneof("_family_name")
        match field_name_1:
            case "family_name":
                return self.__OneOfClass__family_name_family_name__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__preferred_username__(pb_classes.OneOf):
        name: builtins.str= "_preferred_username"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__preferred_username_preferred_username__(__OneOfClass__preferred_username__):
        field: typing.Literal["preferred_username"] = "preferred_username"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.preferred_username
    
    @builtins.property
    def _preferred_username(self) -> __OneOfClass__preferred_username_preferred_username__|None:
        field_name_1: str|None = super().which_field_in_oneof("_preferred_username")
        match field_name_1:
            case "preferred_username":
                return self.__OneOfClass__preferred_username_preferred_username__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__picture__(pb_classes.OneOf):
        name: builtins.str= "_picture"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__picture_picture__(__OneOfClass__picture__):
        field: typing.Literal["picture"] = "picture"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.picture
    
    @builtins.property
    def _picture(self) -> __OneOfClass__picture_picture__|None:
        field_name_1: str|None = super().which_field_in_oneof("_picture")
        match field_name_1:
            case "picture":
                return self.__OneOfClass__picture_picture__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__email__(pb_classes.OneOf):
        name: builtins.str= "_email"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__email_email__(__OneOfClass__email__):
        field: typing.Literal["email"] = "email"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.email
    
    @builtins.property
    def _email(self) -> __OneOfClass__email_email__|None:
        field_name_1: str|None = super().which_field_in_oneof("_email")
        match field_name_1:
            case "email":
                return self.__OneOfClass__email_email__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__email_verified__(pb_classes.OneOf):
        name: builtins.str= "_email_verified"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__email_verified_email_verified__(__OneOfClass__email_verified__):
        field: typing.Literal["email_verified"] = "email_verified"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.bool":
            return self._message.email_verified
    
    @builtins.property
    def _email_verified(self) -> __OneOfClass__email_verified_email_verified__|None:
        field_name_1: str|None = super().which_field_in_oneof("_email_verified")
        match field_name_1:
            case "email_verified":
                return self.__OneOfClass__email_verified_email_verified__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__zoneinfo__(pb_classes.OneOf):
        name: builtins.str= "_zoneinfo"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__zoneinfo_zoneinfo__(__OneOfClass__zoneinfo__):
        field: typing.Literal["zoneinfo"] = "zoneinfo"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.zoneinfo
    
    @builtins.property
    def _zoneinfo(self) -> __OneOfClass__zoneinfo_zoneinfo__|None:
        field_name_1: str|None = super().which_field_in_oneof("_zoneinfo")
        match field_name_1:
            case "zoneinfo":
                return self.__OneOfClass__zoneinfo_zoneinfo__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__locale__(pb_classes.OneOf):
        name: builtins.str= "_locale"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__locale_locale__(__OneOfClass__locale__):
        field: typing.Literal["locale"] = "locale"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.locale
    
    @builtins.property
    def _locale(self) -> __OneOfClass__locale_locale__|None:
        field_name_1: str|None = super().which_field_in_oneof("_locale")
        match field_name_1:
            case "locale":
                return self.__OneOfClass__locale_locale__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__phone_number__(pb_classes.OneOf):
        name: builtins.str= "_phone_number"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__phone_number_phone_number__(__OneOfClass__phone_number__):
        field: typing.Literal["phone_number"] = "phone_number"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.phone_number
    
    @builtins.property
    def _phone_number(self) -> __OneOfClass__phone_number_phone_number__|None:
        field_name_1: str|None = super().which_field_in_oneof("_phone_number")
        match field_name_1:
            case "phone_number":
                return self.__OneOfClass__phone_number_phone_number__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__phone_number_verified__(pb_classes.OneOf):
        name: builtins.str= "_phone_number_verified"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__phone_number_verified_phone_number_verified__(__OneOfClass__phone_number_verified__):
        field: typing.Literal["phone_number_verified"] = "phone_number_verified"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.bool":
            return self._message.phone_number_verified
    
    @builtins.property
    def _phone_number_verified(self) -> __OneOfClass__phone_number_verified_phone_number_verified__|None:
        field_name_1: str|None = super().which_field_in_oneof("_phone_number_verified")
        match field_name_1:
            case "phone_number_verified":
                return self.__OneOfClass__phone_number_verified_phone_number_verified__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        sub: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        given_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        family_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preferred_username: "builtins.str|None|unset.UnsetType" = unset.Unset,
        picture: "builtins.str|None|unset.UnsetType" = unset.Unset,
        email: "builtins.str|None|unset.UnsetType" = unset.Unset,
        email_verified: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        zoneinfo: "builtins.str|None|unset.UnsetType" = unset.Unset,
        locale: "builtins.str|None|unset.UnsetType" = unset.Unset,
        phone_number: "builtins.str|None|unset.UnsetType" = unset.Unset,
        phone_number_verified: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(sub, unset.UnsetType):
            self.sub = sub
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(given_name, unset.UnsetType):
            self.given_name = given_name
        if not isinstance(family_name, unset.UnsetType):
            self.family_name = family_name
        if not isinstance(preferred_username, unset.UnsetType):
            self.preferred_username = preferred_username
        if not isinstance(picture, unset.UnsetType):
            self.picture = picture
        if not isinstance(email, unset.UnsetType):
            self.email = email
        if not isinstance(email_verified, unset.UnsetType):
            self.email_verified = email_verified
        if not isinstance(zoneinfo, unset.UnsetType):
            self.zoneinfo = zoneinfo
        if not isinstance(locale, unset.UnsetType):
            self.locale = locale
        if not isinstance(phone_number, unset.UnsetType):
            self.phone_number = phone_number
        if not isinstance(phone_number_verified, unset.UnsetType):
            self.phone_number_verified = phone_number_verified
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "sub",
            "name",
            "given_name",
            "family_name",
            "preferred_username",
            "picture",
            "email",
            "email_verified",
            "zoneinfo",
            "locale",
            "phone_number",
            "phone_number_verified",
            "_sub",
            "_name",
            "_given_name",
            "_family_name",
            "_preferred_username",
            "_picture",
            "_email",
            "_email_verified",
            "_zoneinfo",
            "_locale",
            "_phone_number",
            "_phone_number_verified",
        ]
    
    @builtins.property
    def sub(self) -> "builtins.str|None":
        return super()._get_field("sub", explicit_presence=True,
        )
    @sub.setter
    def sub(self, value: "builtins.str|None") -> None:
        return super()._set_field("sub",value,explicit_presence=True,
        )
    
    @builtins.property
    def name(self) -> "builtins.str|None":
        return super()._get_field("name", explicit_presence=True,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=True,
        )
    
    @builtins.property
    def given_name(self) -> "builtins.str|None":
        return super()._get_field("given_name", explicit_presence=True,
        )
    @given_name.setter
    def given_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("given_name",value,explicit_presence=True,
        )
    
    @builtins.property
    def family_name(self) -> "builtins.str|None":
        return super()._get_field("family_name", explicit_presence=True,
        )
    @family_name.setter
    def family_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("family_name",value,explicit_presence=True,
        )
    
    @builtins.property
    def preferred_username(self) -> "builtins.str|None":
        return super()._get_field("preferred_username", explicit_presence=True,
        )
    @preferred_username.setter
    def preferred_username(self, value: "builtins.str|None") -> None:
        return super()._set_field("preferred_username",value,explicit_presence=True,
        )
    
    @builtins.property
    def picture(self) -> "builtins.str|None":
        return super()._get_field("picture", explicit_presence=True,
        )
    @picture.setter
    def picture(self, value: "builtins.str|None") -> None:
        return super()._set_field("picture",value,explicit_presence=True,
        )
    
    @builtins.property
    def email(self) -> "builtins.str|None":
        return super()._get_field("email", explicit_presence=True,
        )
    @email.setter
    def email(self, value: "builtins.str|None") -> None:
        return super()._set_field("email",value,explicit_presence=True,
        )
    
    @builtins.property
    def email_verified(self) -> "builtins.bool|None":
        return super()._get_field("email_verified", explicit_presence=True,
        )
    @email_verified.setter
    def email_verified(self, value: "builtins.bool|None") -> None:
        return super()._set_field("email_verified",value,explicit_presence=True,
        )
    
    @builtins.property
    def zoneinfo(self) -> "builtins.str|None":
        return super()._get_field("zoneinfo", explicit_presence=True,
        )
    @zoneinfo.setter
    def zoneinfo(self, value: "builtins.str|None") -> None:
        return super()._set_field("zoneinfo",value,explicit_presence=True,
        )
    
    @builtins.property
    def locale(self) -> "builtins.str|None":
        return super()._get_field("locale", explicit_presence=True,
        )
    @locale.setter
    def locale(self, value: "builtins.str|None") -> None:
        return super()._set_field("locale",value,explicit_presence=True,
        )
    
    @builtins.property
    def phone_number(self) -> "builtins.str|None":
        return super()._get_field("phone_number", explicit_presence=True,
        )
    @phone_number.setter
    def phone_number(self, value: "builtins.str|None") -> None:
        return super()._set_field("phone_number",value,explicit_presence=True,
        )
    
    @builtins.property
    def phone_number_verified(self) -> "builtins.bool|None":
        return super()._get_field("phone_number_verified", explicit_presence=True,
        )
    @phone_number_verified.setter
    def phone_number_verified(self, value: "builtins.bool|None") -> None:
        return super()._set_field("phone_number_verified",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "sub":"sub",
        "name":"name",
        "given_name":"given_name",
        "family_name":"family_name",
        "preferred_username":"preferred_username",
        "picture":"picture",
        "email":"email",
        "email_verified":"email_verified",
        "zoneinfo":"zoneinfo",
        "locale":"locale",
        "phone_number":"phone_number",
        "phone_number_verified":"phone_number_verified",
        "_sub":"_sub",
        "_name":"_name",
        "_given_name":"_given_name",
        "_family_name":"_family_name",
        "_preferred_username":"_preferred_username",
        "_picture":"_picture",
        "_email":"_email",
        "_email_verified":"_email_verified",
        "_zoneinfo":"_zoneinfo",
        "_locale":"_locale",
        "_phone_number":"_phone_number",
        "_phone_number_verified":"_phone_number_verified",
    }
    
class Error(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.Error
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Error",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(message, unset.UnsetType):
            self.message = message
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "message",
        ]
    
    @builtins.property
    def message(self) -> "builtins.str":
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "message":"message",
    }
    
class TenantUserAccountSpec(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccountSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccountSpec",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class VisibleAttributes(pb_classes.Message):
        """
        when a global user account is projected to a specific tenant
        they can give consent for that tenant's owner to view specific personal data
        by listing explicitly visible PDS attributes
        complete list of PDS attributes is described in ../../pds/inner/v1alpha1/iam_identifier.proto
        """
        
        __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccountSpec.VisibleAttributes
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccountSpec.VisibleAttributes",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            attribute: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(attribute, unset.UnsetType):
                self.attribute = attribute
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "attribute",
            ]
        
        @builtins.property
        def attribute(self) -> "abc.MutableSequence[builtins.str]":
            return super()._get_field("attribute", explicit_presence=False,
            wrap=pb_classes.Repeated,
            )
        @attribute.setter
        def attribute(self, value: "abc.Iterable[builtins.str]|None") -> None:
            return super()._set_field("attribute",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "attribute":"attribute",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        visible_attributes: "TenantUserAccountSpec.VisibleAttributes|tenant_user_account_pb2.TenantUserAccountSpec.VisibleAttributes|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(visible_attributes, unset.UnsetType):
            self.visible_attributes = visible_attributes
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "visible_attributes",
            "VisibleAttributes",
        ]
    
    @builtins.property
    def visible_attributes(self) -> "TenantUserAccountSpec.VisibleAttributes":
        return super()._get_field("visible_attributes", explicit_presence=False,
        wrap=TenantUserAccountSpec.VisibleAttributes,
        )
    @visible_attributes.setter
    def visible_attributes(self, value: "TenantUserAccountSpec.VisibleAttributes|tenant_user_account_pb2.TenantUserAccountSpec.VisibleAttributes|None") -> None:
        return super()._set_field("visible_attributes",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "visible_attributes":"visible_attributes",
        "VisibleAttributes":"VisibleAttributes",
    }
    
class TenantUserAccountStatus(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccountStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccountStatus",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.TenantUserAccountStatus.State",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        """
        in case of ordinary tenant user account a corresponding user can log into the system and use granted tenant resources
        in case of invited tenant user account once the invitation is accepted a corresponding user can start using granted resources immediately
        """
        
        INACTIVE = 2
        """
        unused
        """
        
        BLOCKED = 3
        """
        in case of ordinary tenant user account a corresponding user can log into the system but cannot be authorized to use tenant resources
        in case of invited tenant user account once the invitation is accepted a corresponding user cannot start using granted resources until is unblocked
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "TenantUserAccountStatus.State|tenant_user_account_pb2.TenantUserAccountStatus.State|None|unset.UnsetType" = unset.Unset,
        invitation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        user_account_state: "UserAccountStatus.State|user_account_pb2.UserAccountStatus.State|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(invitation_id, unset.UnsetType):
            self.invitation_id = invitation_id
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
        if not isinstance(user_account_state, unset.UnsetType):
            self.user_account_state = user_account_state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "invitation_id",
            "federation_id",
            "user_account_state",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "TenantUserAccountStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=TenantUserAccountStatus.State,
        )
    @state.setter
    def state(self, value: "TenantUserAccountStatus.State|tenant_user_account_pb2.TenantUserAccountStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def invitation_id(self) -> "builtins.str":
        """
        if a tenant user account is created during invitation it gets a reference to the invitation resource
        once invitation is accepted it looses this reference (and internally gets a reference to their global federated user account)
        """
        
        return super()._get_field("invitation_id", explicit_presence=False,
        )
    @invitation_id.setter
    def invitation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("invitation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        """
        the federation id of the linked user account. Could be empty in a case of a tenant user account belongs to an invitation which wasn't accepted.
        """
        
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def user_account_state(self) -> "UserAccountStatus.State":
        """
        user account state can help distinguish case when account is blocked globally
        """
        
        return super()._get_field("user_account_state", explicit_presence=False,
        wrap=UserAccountStatus.State,
        )
    @user_account_state.setter
    def user_account_state(self, value: "UserAccountStatus.State|user_account_pb2.UserAccountStatus.State|None") -> None:
        return super()._set_field("user_account_state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "invitation_id":"invitation_id",
        "federation_id":"federation_id",
        "user_account_state":"user_account_state",
        "State":"State",
    }
    
# file: nebius/iam/v1/group_membership.proto
class GroupMembership(pb_classes.Message):
    __PB2_CLASS__ = group_membership_pb2.GroupMembership
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMembership",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "revoke_at": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupMembershipSpec|group_membership_pb2.GroupMembershipSpec|None|unset.UnsetType" = unset.Unset,
        status: "GroupMembershipStatus|group_membership_pb2.GroupMembershipStatus|None|unset.UnsetType" = unset.Unset,
        revoke_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
        if not isinstance(revoke_at, unset.UnsetType):
            self.revoke_at = revoke_at
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
            "revoke_at",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupMembershipSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupMembershipSpec,
        )
    @spec.setter
    def spec(self, value: "GroupMembershipSpec|group_membership_pb2.GroupMembershipSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "GroupMembershipStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=GroupMembershipStatus,
        )
    @status.setter
    def status(self, value: "GroupMembershipStatus|group_membership_pb2.GroupMembershipStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    @builtins.property
    def revoke_at(self) -> "datetime.datetime":
        return super()._get_field("revoke_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @revoke_at.setter
    def revoke_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("revoke_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
        "revoke_at":"revoke_at",
    }
    
class GroupMembershipSpec(pb_classes.Message):
    __PB2_CLASS__ = group_membership_pb2.GroupMembershipSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMembershipSpec",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        member_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(member_id, unset.UnsetType):
            self.member_id = member_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "member_id",
        ]
    
    @builtins.property
    def member_id(self) -> "builtins.str":
        """
        Member of the group. Can be tenant user account id or service account id.
        """
        
        return super()._get_field("member_id", explicit_presence=False,
        )
    @member_id.setter
    def member_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("member_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "member_id":"member_id",
    }
    
class GroupMembershipStatus(pb_classes.Message):
    __PB2_CLASS__ = group_membership_pb2.GroupMembershipStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMembershipStatus",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_group_member_status__(pb_classes.OneOf):
        name: builtins.str= "group_member_status"
        
        def __init__(self, msg: "GroupMembershipStatus") -> None:
            super().__init__()
            self._message: "GroupMembershipStatus" = msg
    
    class __OneOfClass_group_member_status_tenant_user_account_status__(__OneOfClass_group_member_status__):
        field: typing.Literal["tenant_user_account_status"] = "tenant_user_account_status"
        
        def __init__(self, msg: "GroupMembershipStatus") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "TenantUserAccountStatus":
            return self._message.tenant_user_account_status
    
    class __OneOfClass_group_member_status_service_account_status__(__OneOfClass_group_member_status__):
        field: typing.Literal["service_account_status"] = "service_account_status"
        
        def __init__(self, msg: "GroupMembershipStatus") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ServiceAccountStatus":
            return self._message.service_account_status
    
    @builtins.property
    def group_member_status(self) -> __OneOfClass_group_member_status_tenant_user_account_status__|__OneOfClass_group_member_status_service_account_status__|None:
        field_name_1: str|None = super().which_field_in_oneof("group_member_status")
        match field_name_1:
            case "tenant_user_account_status":
                return self.__OneOfClass_group_member_status_tenant_user_account_status__(self)
            case "service_account_status":
                return self.__OneOfClass_group_member_status_service_account_status__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_user_account_status: "TenantUserAccountStatus|tenant_user_account_pb2.TenantUserAccountStatus|None|unset.UnsetType" = unset.Unset,
        service_account_status: "ServiceAccountStatus|service_account_pb2.ServiceAccountStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_user_account_status, unset.UnsetType):
            self.tenant_user_account_status = tenant_user_account_status
        if not isinstance(service_account_status, unset.UnsetType):
            self.service_account_status = service_account_status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_user_account_status",
            "service_account_status",
            "group_member_status",
        ]
    
    @builtins.property
    def tenant_user_account_status(self) -> "TenantUserAccountStatus|None":
        return super()._get_field("tenant_user_account_status", explicit_presence=True,
        wrap=TenantUserAccountStatus,
        )
    @tenant_user_account_status.setter
    def tenant_user_account_status(self, value: "TenantUserAccountStatus|tenant_user_account_pb2.TenantUserAccountStatus|None") -> None:
        return super()._set_field("tenant_user_account_status",value,explicit_presence=True,
        )
    
    @builtins.property
    def service_account_status(self) -> "ServiceAccountStatus|None":
        return super()._get_field("service_account_status", explicit_presence=True,
        wrap=ServiceAccountStatus,
        )
    @service_account_status.setter
    def service_account_status(self, value: "ServiceAccountStatus|service_account_pb2.ServiceAccountStatus|None") -> None:
        return super()._set_field("service_account_status",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_user_account_status":"tenant_user_account_status",
        "service_account_status":"service_account_status",
        "group_member_status":"group_member_status",
    }
    
class GroupMemberKind(pb_classes.Message):
    __PB2_CLASS__ = group_membership_pb2.GroupMemberKind
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMemberKind",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class Kind(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.GroupMemberKind.Kind",group_membership_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        KIND_UNSPECIFIED = 0
        ORDINARY_TENANT_USER_ACCOUNT = 1
        INVITED_TENANT_USER_ACCOUNT = 2
        SERVICE_ACCOUNT = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        kind: "GroupMemberKind.Kind|group_membership_pb2.GroupMemberKind.Kind|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(kind, unset.UnsetType):
            self.kind = kind
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "kind",
            "Kind",
        ]
    
    @builtins.property
    def kind(self) -> "GroupMemberKind.Kind":
        return super()._get_field("kind", explicit_presence=False,
        wrap=GroupMemberKind.Kind,
        )
    @kind.setter
    def kind(self, value: "GroupMemberKind.Kind|group_membership_pb2.GroupMemberKind.Kind|None") -> None:
        return super()._set_field("kind",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "kind":"kind",
        "Kind":"Kind",
    }
    
class GroupMembershipWithAttributes(pb_classes.Message):
    """
    see also nebius/iam/v1/tenant_user_account.proto/TenantUserAccountWithAttributes
    """
    
    __PB2_CLASS__ = group_membership_pb2.GroupMembershipWithAttributes
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMembershipWithAttributes",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_attributesOptional__(pb_classes.OneOf):
        name: builtins.str= "attributesOptional"
        
        def __init__(self, msg: "GroupMembershipWithAttributes") -> None:
            super().__init__()
            self._message: "GroupMembershipWithAttributes" = msg
    
    class __OneOfClass_attributesOptional_user_attributes__(__OneOfClass_attributesOptional__):
        field: typing.Literal["user_attributes"] = "user_attributes"
        
        def __init__(self, msg: "GroupMembershipWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "UserAttributes":
            return self._message.user_attributes
    
    class __OneOfClass_attributesOptional_service_account_attributes__(__OneOfClass_attributesOptional__):
        field: typing.Literal["service_account_attributes"] = "service_account_attributes"
        
        def __init__(self, msg: "GroupMembershipWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ServiceAccountAttributes":
            return self._message.service_account_attributes
    
    class __OneOfClass_attributesOptional_error__(__OneOfClass_attributesOptional__):
        field: typing.Literal["error"] = "error"
        
        def __init__(self, msg: "GroupMembershipWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Error":
            return self._message.error
    
    @builtins.property
    def attributesOptional(self) -> __OneOfClass_attributesOptional_user_attributes__|__OneOfClass_attributesOptional_service_account_attributes__|__OneOfClass_attributesOptional_error__|None:
        field_name_1: str|None = super().which_field_in_oneof("attributesOptional")
        match field_name_1:
            case "user_attributes":
                return self.__OneOfClass_attributesOptional_user_attributes__(self)
            case "service_account_attributes":
                return self.__OneOfClass_attributesOptional_service_account_attributes__(self)
            case "error":
                return self.__OneOfClass_attributesOptional_error__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        group_membership: "GroupMembership|group_membership_pb2.GroupMembership|None|unset.UnsetType" = unset.Unset,
        group_member_kind: "GroupMemberKind|group_membership_pb2.GroupMemberKind|None|unset.UnsetType" = unset.Unset,
        user_attributes: "UserAttributes|tenant_user_account_pb2.UserAttributes|None|unset.UnsetType" = unset.Unset,
        service_account_attributes: "ServiceAccountAttributes|service_account_pb2.ServiceAccountAttributes|None|unset.UnsetType" = unset.Unset,
        error: "Error|tenant_user_account_pb2.Error|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(group_membership, unset.UnsetType):
            self.group_membership = group_membership
        if not isinstance(group_member_kind, unset.UnsetType):
            self.group_member_kind = group_member_kind
        if not isinstance(user_attributes, unset.UnsetType):
            self.user_attributes = user_attributes
        if not isinstance(service_account_attributes, unset.UnsetType):
            self.service_account_attributes = service_account_attributes
        if not isinstance(error, unset.UnsetType):
            self.error = error
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "group_membership",
            "group_member_kind",
            "user_attributes",
            "service_account_attributes",
            "error",
            "attributesOptional",
        ]
    
    @builtins.property
    def group_membership(self) -> "GroupMembership":
        return super()._get_field("group_membership", explicit_presence=False,
        wrap=GroupMembership,
        )
    @group_membership.setter
    def group_membership(self, value: "GroupMembership|group_membership_pb2.GroupMembership|None") -> None:
        return super()._set_field("group_membership",value,explicit_presence=False,
        )
    
    @builtins.property
    def group_member_kind(self) -> "GroupMemberKind":
        return super()._get_field("group_member_kind", explicit_presence=False,
        wrap=GroupMemberKind,
        )
    @group_member_kind.setter
    def group_member_kind(self, value: "GroupMemberKind|group_membership_pb2.GroupMemberKind|None") -> None:
        return super()._set_field("group_member_kind",value,explicit_presence=False,
        )
    
    @builtins.property
    def user_attributes(self) -> "UserAttributes|None":
        """
        filled with known data for members corresponding to tenant user accounts and provisional tenant user accounts (invitees)
        left unset for service accounts
        """
        
        return super()._get_field("user_attributes", explicit_presence=True,
        wrap=UserAttributes,
        )
    @user_attributes.setter
    def user_attributes(self, value: "UserAttributes|tenant_user_account_pb2.UserAttributes|None") -> None:
        return super()._set_field("user_attributes",value,explicit_presence=True,
        )
    
    @builtins.property
    def service_account_attributes(self) -> "ServiceAccountAttributes|None":
        """
        filled with known data for members corresponding to service accounts
        left unset for any kind of tenant user accounts
        """
        
        return super()._get_field("service_account_attributes", explicit_presence=True,
        wrap=ServiceAccountAttributes,
        )
    @service_account_attributes.setter
    def service_account_attributes(self, value: "ServiceAccountAttributes|service_account_pb2.ServiceAccountAttributes|None") -> None:
        return super()._set_field("service_account_attributes",value,explicit_presence=True,
        )
    
    @builtins.property
    def error(self) -> "Error|None":
        """
        in a case of issues of getting attributes from pds service, we can still return some data from cpl
        """
        
        return super()._get_field("error", explicit_presence=True,
        wrap=Error,
        )
    @error.setter
    def error(self, value: "Error|tenant_user_account_pb2.Error|None") -> None:
        return super()._set_field("error",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "group_membership":"group_membership",
        "group_member_kind":"group_member_kind",
        "user_attributes":"user_attributes",
        "service_account_attributes":"service_account_attributes",
        "error":"error",
        "attributesOptional":"attributesOptional",
    }
    
# file: nebius/iam/v1/group_membership_service.proto
class CreateGroupMembershipRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.CreateGroupMembershipRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateGroupMembershipRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupMembershipSpec|group_membership_pb2.GroupMembershipSpec|None|unset.UnsetType" = unset.Unset,
        revoke_after_hours: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(revoke_after_hours, unset.UnsetType):
            self.revoke_after_hours = revoke_after_hours
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "revoke_after_hours",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupMembershipSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupMembershipSpec,
        )
    @spec.setter
    def spec(self, value: "GroupMembershipSpec|group_membership_pb2.GroupMembershipSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def revoke_after_hours(self) -> "builtins.int":
        return super()._get_field("revoke_after_hours", explicit_presence=False,
        )
    @revoke_after_hours.setter
    def revoke_after_hours(self, value: "builtins.int|None") -> None:
        return super()._set_field("revoke_after_hours",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "revoke_after_hours":"revoke_after_hours",
    }
    
class DeleteGroupMembershipRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.DeleteGroupMembershipRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteGroupMembershipRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetGroupMembershipRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.GetGroupMembershipRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetGroupMembershipRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListGroupMembershipsRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListGroupMembershipsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupMembershipsRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListMemberOfRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListMemberOfRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListMemberOfRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        subject_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(subject_id, unset.UnsetType):
            self.subject_id = subject_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "subject_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def subject_id(self) -> "builtins.str":
        """
        Requested subject id. Can be tenant user account id or service account id.
        """
        
        return super()._get_field("subject_id", explicit_presence=False,
        )
    @subject_id.setter
    def subject_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subject_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "subject_id":"subject_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListGroupMembershipsResponse(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListGroupMembershipsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupMembershipsResponse",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        memberships: "abc.Iterable[GroupMembership]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(memberships, unset.UnsetType):
            self.memberships = memberships
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "memberships",
            "next_page_token",
        ]
    
    @builtins.property
    def memberships(self) -> "abc.MutableSequence[GroupMembership]":
        """
        Members of the group. Can be tenant user account ids or service account ids.
        """
        
        return super()._get_field("memberships", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(GroupMembership,None,None),
        )
    @memberships.setter
    def memberships(self, value: "abc.Iterable[GroupMembership]|None") -> None:
        return super()._set_field("memberships",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "memberships":"memberships",
        "next_page_token":"next_page_token",
    }
    
class ListGroupMembershipsWithAttributesResponse(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListGroupMembershipsWithAttributesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupMembershipsWithAttributesResponse",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        memberships: "abc.Iterable[GroupMembershipWithAttributes]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(memberships, unset.UnsetType):
            self.memberships = memberships
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "memberships",
            "next_page_token",
        ]
    
    @builtins.property
    def memberships(self) -> "abc.MutableSequence[GroupMembershipWithAttributes]":
        """
        Members of the group with their attributes if supported by member type.
        Can be tenant user accounts (regular or provisional/invited) or service accounts.
        Regular tenant user accounts may have a full set of attributes, provisional may have contacts only,
        service accounts
        """
        
        return super()._get_field("memberships", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(GroupMembershipWithAttributes,None,None),
        )
    @memberships.setter
    def memberships(self, value: "abc.Iterable[GroupMembershipWithAttributes]|None") -> None:
        return super()._set_field("memberships",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "memberships":"memberships",
        "next_page_token":"next_page_token",
    }
    
class ListMemberOfResponse(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListMemberOfResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListMemberOfResponse",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Group]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Group]":
        """
        Groups that requested entity is a member of
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Group,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Group]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class GroupMembershipServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.GroupMembershipService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.GroupMembershipService",group_membership_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.GroupMembershipService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateGroupMembershipRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateGroupMembershipRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateGroupMembershipRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetGroupMembershipRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetGroupMembershipRequest","GroupMembership"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetGroupMembershipRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.GroupMembership`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=group_membership_pb2.GroupMembership,
            result_wrapper=pb_classes.simple_wrapper(GroupMembership),
            **kwargs,
        )
    
    def get_with_attributes(self,
        request: "GetGroupMembershipRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetGroupMembershipRequest","GroupMembershipWithAttributes"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetGroupMembershipRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.GroupMembershipWithAttributes`.
        """
        
        return super().request(
            method="GetWithAttributes",
            request=request,
            result_pb2_class=group_membership_pb2.GroupMembershipWithAttributes,
            result_wrapper=pb_classes.simple_wrapper(GroupMembershipWithAttributes),
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteGroupMembershipRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteGroupMembershipRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteGroupMembershipRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def list_members(self,
        request: "ListGroupMembershipsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListGroupMembershipsRequest","ListGroupMembershipsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListGroupMembershipsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListGroupMembershipsResponse`.
        """
        
        return super().request(
            method="ListMembers",
            request=request,
            result_pb2_class=group_membership_service_pb2.ListGroupMembershipsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListGroupMembershipsResponse),
            **kwargs,
        )
    
    def list_members_with_attributes(self,
        request: "ListGroupMembershipsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListGroupMembershipsRequest","ListGroupMembershipsWithAttributesResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListGroupMembershipsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListGroupMembershipsWithAttributesResponse`.
        """
        
        return super().request(
            method="ListMembersWithAttributes",
            request=request,
            result_pb2_class=group_membership_service_pb2.ListGroupMembershipsWithAttributesResponse,
            result_wrapper=pb_classes.simple_wrapper(ListGroupMembershipsWithAttributesResponse),
            **kwargs,
        )
    
    def list_member_of(self,
        request: "ListMemberOfRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListMemberOfRequest","ListMemberOfResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListMemberOfRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListMemberOfResponse`.
        """
        
        return super().request(
            method="ListMemberOf",
            request=request,
            result_pb2_class=group_membership_service_pb2.ListMemberOfResponse,
            result_wrapper=pb_classes.simple_wrapper(ListMemberOfResponse),
            **kwargs,
        )
    

# file: nebius/iam/v1/group_service.proto
class CreateGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.CreateGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateGroupRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupSpec|group_pb2.GroupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupSpec,
        )
    @spec.setter
    def spec(self, value: "GroupSpec|group_pb2.GroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.GetGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetGroupRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetGroupByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.GetGroupByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetGroupByNameRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListGroupsRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.ListGroupsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupsRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListGroupsResponse(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.ListGroupsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupsResponse",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Group]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Group]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Group,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Group]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class DeleteGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.DeleteGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteGroupRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UpdateGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.UpdateGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateGroupRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupSpec|group_pb2.GroupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupSpec,
        )
    @spec.setter
    def spec(self, value: "GroupSpec|group_pb2.GroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    

class GroupServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.GroupService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.GroupService",group_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.GroupService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateGroupRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetGroupRequest","Group"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Group`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=group_pb2.Group,
            result_wrapper=pb_classes.simple_wrapper(Group),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetGroupByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetGroupByNameRequest","Group"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetGroupByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Group`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=group_pb2.Group,
            result_wrapper=pb_classes.simple_wrapper(Group),
            **kwargs,
        )
    
    def list(self,
        request: "ListGroupsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListGroupsRequest","ListGroupsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListGroupsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListGroupsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=group_service_pb2.ListGroupsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListGroupsResponse),
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteGroupRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def update(self,
        request: "UpdateGroupRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateGroupRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateGroupRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/invitation.proto
class Invitation(pb_classes.Message):
    __PB2_CLASS__ = invitation_pb2.Invitation
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Invitation",invitation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InvitationSpec|invitation_pb2.InvitationSpec|None|unset.UnsetType" = unset.Unset,
        status: "InvitationStatus|invitation_pb2.InvitationStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InvitationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InvitationSpec,
        )
    @spec.setter
    def spec(self, value: "InvitationSpec|invitation_pb2.InvitationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "InvitationStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=InvitationStatus,
        )
    @status.setter
    def status(self, value: "InvitationStatus|invitation_pb2.InvitationStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class InvitationSpec(pb_classes.Message):
    __PB2_CLASS__ = invitation_pb2.InvitationSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.InvitationSpec",invitation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_contact__(pb_classes.OneOf):
        name: builtins.str= "contact"
        
        def __init__(self, msg: "InvitationSpec") -> None:
            super().__init__()
            self._message: "InvitationSpec" = msg
    
    class __OneOfClass_contact_email__(__OneOfClass_contact__):
        field: typing.Literal["email"] = "email"
        
        def __init__(self, msg: "InvitationSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.email
    
    @builtins.property
    def contact(self) -> __OneOfClass_contact_email__|None:
        field_name_1: str|None = super().which_field_in_oneof("contact")
        match field_name_1:
            case "email":
                return self.__OneOfClass_contact_email__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        email: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(email, unset.UnsetType):
            self.email = email
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
            "email",
            "contact",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def email(self) -> "builtins.str|None":
        return super()._get_field("email", explicit_presence=True,
        )
    @email.setter
    def email(self, value: "builtins.str|None") -> None:
        return super()._set_field("email",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
        "email":"email",
        "contact":"contact",
    }
    
class InvitationStatus(pb_classes.Message):
    __PB2_CLASS__ = invitation_pb2.InvitationStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.InvitationStatus",invitation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expires_at": well_known_1.ts_mask,
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.InvitationStatus.State",invitation_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 4
        """
        contacts data is not stored in pds yet. probably will GC it later
        """
        
        CREATED = 5
        """
        notification is not sent yet
        """
        
        PENDING = 1
        """
        notification is sent, we are waiting for the user to approve the notification
        """
        
        EXPIRED = 2
        """
        notification is expired, accept is no longer possible
        """
        
        ACCEPTED = 3
        """
        notification is accepted
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_user_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        expires_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        state: "InvitationStatus.State|invitation_pb2.InvitationStatus.State|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_user_account_id, unset.UnsetType):
            self.tenant_user_account_id = tenant_user_account_id
        if not isinstance(expires_at, unset.UnsetType):
            self.expires_at = expires_at
        if not isinstance(state, unset.UnsetType):
            self.state = state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_user_account_id",
            "expires_at",
            "state",
            "State",
        ]
    
    @builtins.property
    def tenant_user_account_id(self) -> "builtins.str":
        return super()._get_field("tenant_user_account_id", explicit_presence=False,
        )
    @tenant_user_account_id.setter
    def tenant_user_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_user_account_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_at(self) -> "datetime.datetime":
        return super()._get_field("expires_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expires_at.setter
    def expires_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expires_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def state(self) -> "InvitationStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=InvitationStatus.State,
        )
    @state.setter
    def state(self, value: "InvitationStatus.State|invitation_pb2.InvitationStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_user_account_id":"tenant_user_account_id",
        "expires_at":"expires_at",
        "state":"state",
        "State":"State",
    }
    
# file: nebius/iam/v1/invitation_service.proto
class CreateInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.CreateInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InvitationSpec|invitation_pb2.InvitationSpec|None|unset.UnsetType" = unset.Unset,
        no_send: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(no_send, unset.UnsetType):
            self.no_send = no_send
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "no_send",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InvitationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InvitationSpec,
        )
    @spec.setter
    def spec(self, value: "InvitationSpec|invitation_pb2.InvitationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def no_send(self) -> "builtins.bool":
        """
        if set, no sending is attempted (it's supposed that later a Resend method is called)
        """
        
        return super()._get_field("no_send", explicit_presence=False,
        )
    @no_send.setter
    def no_send(self, value: "builtins.bool|None") -> None:
        return super()._set_field("no_send",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "no_send":"no_send",
    }
    
class GetInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.GetInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListInvitationsRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.ListInvitationsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListInvitationsRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListInvitationsResponse(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.ListInvitationsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListInvitationsResponse",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Invitation]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Invitation]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Invitation,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Invitation]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class DeleteInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.DeleteInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UpdateInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.UpdateInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InvitationSpec|invitation_pb2.InvitationSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InvitationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InvitationSpec,
        )
    @spec.setter
    def spec(self, value: "InvitationSpec|invitation_pb2.InvitationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ResendInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.ResendInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ResendInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class InvitationServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.InvitationService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.InvitationService",invitation_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.InvitationService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateInvitationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateInvitationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateInvitationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetInvitationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetInvitationRequest","Invitation"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetInvitationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Invitation`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=invitation_pb2.Invitation,
            result_wrapper=pb_classes.simple_wrapper(Invitation),
            **kwargs,
        )
    
    def list(self,
        request: "ListInvitationsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListInvitationsRequest","ListInvitationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListInvitationsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListInvitationsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=invitation_service_pb2.ListInvitationsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListInvitationsResponse),
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteInvitationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteInvitationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteInvitationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def update(self,
        request: "UpdateInvitationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateInvitationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateInvitationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def resend(self,
        request: "ResendInvitationRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ResendInvitationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ResendInvitationRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Resend",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/profile_service.proto
class GetProfileRequest(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.GetProfileRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetProfileRequest",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class GetProfileResponse(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.GetProfileResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetProfileResponse",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_profile__(pb_classes.OneOf):
        name: builtins.str= "profile"
        
        def __init__(self, msg: "GetProfileResponse") -> None:
            super().__init__()
            self._message: "GetProfileResponse" = msg
    
    class __OneOfClass_profile_user_profile__(__OneOfClass_profile__):
        field: typing.Literal["user_profile"] = "user_profile"
        
        def __init__(self, msg: "GetProfileResponse") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "UserProfile":
            return self._message.user_profile
    
    class __OneOfClass_profile_service_account_profile__(__OneOfClass_profile__):
        field: typing.Literal["service_account_profile"] = "service_account_profile"
        
        def __init__(self, msg: "GetProfileResponse") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ServiceAccountProfile":
            return self._message.service_account_profile
    
    class __OneOfClass_profile_anonymous_profile__(__OneOfClass_profile__):
        field: typing.Literal["anonymous_profile"] = "anonymous_profile"
        
        def __init__(self, msg: "GetProfileResponse") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "AnonymousAccount":
            return self._message.anonymous_profile
    
    @builtins.property
    def profile(self) -> __OneOfClass_profile_user_profile__|__OneOfClass_profile_service_account_profile__|__OneOfClass_profile_anonymous_profile__|None:
        field_name_1: str|None = super().which_field_in_oneof("profile")
        match field_name_1:
            case "user_profile":
                return self.__OneOfClass_profile_user_profile__(self)
            case "service_account_profile":
                return self.__OneOfClass_profile_service_account_profile__(self)
            case "anonymous_profile":
                return self.__OneOfClass_profile_anonymous_profile__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        user_profile: "UserProfile|profile_service_pb2.UserProfile|None|unset.UnsetType" = unset.Unset,
        service_account_profile: "ServiceAccountProfile|profile_service_pb2.ServiceAccountProfile|None|unset.UnsetType" = unset.Unset,
        anonymous_profile: "AnonymousAccount|profile_service_pb2.AnonymousAccount|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(user_profile, unset.UnsetType):
            self.user_profile = user_profile
        if not isinstance(service_account_profile, unset.UnsetType):
            self.service_account_profile = service_account_profile
        if not isinstance(anonymous_profile, unset.UnsetType):
            self.anonymous_profile = anonymous_profile
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "user_profile",
            "service_account_profile",
            "anonymous_profile",
            "profile",
        ]
    
    @builtins.property
    def user_profile(self) -> "UserProfile|None":
        return super()._get_field("user_profile", explicit_presence=True,
        wrap=UserProfile,
        )
    @user_profile.setter
    def user_profile(self, value: "UserProfile|profile_service_pb2.UserProfile|None") -> None:
        return super()._set_field("user_profile",value,explicit_presence=True,
        )
    
    @builtins.property
    def service_account_profile(self) -> "ServiceAccountProfile|None":
        return super()._get_field("service_account_profile", explicit_presence=True,
        wrap=ServiceAccountProfile,
        )
    @service_account_profile.setter
    def service_account_profile(self, value: "ServiceAccountProfile|profile_service_pb2.ServiceAccountProfile|None") -> None:
        return super()._set_field("service_account_profile",value,explicit_presence=True,
        )
    
    @builtins.property
    def anonymous_profile(self) -> "AnonymousAccount|None":
        return super()._get_field("anonymous_profile", explicit_presence=True,
        wrap=AnonymousAccount,
        )
    @anonymous_profile.setter
    def anonymous_profile(self, value: "AnonymousAccount|profile_service_pb2.AnonymousAccount|None") -> None:
        return super()._set_field("anonymous_profile",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "user_profile":"user_profile",
        "service_account_profile":"service_account_profile",
        "anonymous_profile":"anonymous_profile",
        "profile":"profile",
    }
    
class UserProfile(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.UserProfile
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserProfile",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_attributes_optional__(pb_classes.OneOf):
        name: builtins.str= "attributes_optional"
        
        def __init__(self, msg: "UserProfile") -> None:
            super().__init__()
            self._message: "UserProfile" = msg
    
    class __OneOfClass_attributes_optional_attributes__(__OneOfClass_attributes_optional__):
        field: typing.Literal["attributes"] = "attributes"
        
        def __init__(self, msg: "UserProfile") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "UserAttributes":
            return self._message.attributes
    
    class __OneOfClass_attributes_optional_retrieving_error__(__OneOfClass_attributes_optional__):
        field: typing.Literal["retrieving_error"] = "retrieving_error"
        
        def __init__(self, msg: "UserProfile") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Error":
            return self._message.retrieving_error
    
    @builtins.property
    def attributes_optional(self) -> __OneOfClass_attributes_optional_attributes__|__OneOfClass_attributes_optional_retrieving_error__|None:
        field_name_1: str|None = super().which_field_in_oneof("attributes_optional")
        match field_name_1:
            case "attributes":
                return self.__OneOfClass_attributes_optional_attributes__(self)
            case "retrieving_error":
                return self.__OneOfClass_attributes_optional_retrieving_error__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        federation_info: "UserAccountExternalId|user_account_pb2.UserAccountExternalId|None|unset.UnsetType" = unset.Unset,
        attributes: "UserAttributes|tenant_user_account_pb2.UserAttributes|None|unset.UnsetType" = unset.Unset,
        retrieving_error: "Error|tenant_user_account_pb2.Error|None|unset.UnsetType" = unset.Unset,
        tenants: "abc.Iterable[UserTenantInfo]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(federation_info, unset.UnsetType):
            self.federation_info = federation_info
        if not isinstance(attributes, unset.UnsetType):
            self.attributes = attributes
        if not isinstance(retrieving_error, unset.UnsetType):
            self.retrieving_error = retrieving_error
        if not isinstance(tenants, unset.UnsetType):
            self.tenants = tenants
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "federation_info",
            "attributes",
            "retrieving_error",
            "tenants",
            "attributes_optional",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def federation_info(self) -> "UserAccountExternalId":
        return super()._get_field("federation_info", explicit_presence=False,
        wrap=UserAccountExternalId,
        )
    @federation_info.setter
    def federation_info(self, value: "UserAccountExternalId|user_account_pb2.UserAccountExternalId|None") -> None:
        return super()._set_field("federation_info",value,explicit_presence=False,
        )
    
    @builtins.property
    def attributes(self) -> "UserAttributes|None":
        return super()._get_field("attributes", explicit_presence=True,
        wrap=UserAttributes,
        )
    @attributes.setter
    def attributes(self, value: "UserAttributes|tenant_user_account_pb2.UserAttributes|None") -> None:
        return super()._set_field("attributes",value,explicit_presence=True,
        )
    
    @builtins.property
    def retrieving_error(self) -> "Error|None":
        return super()._get_field("retrieving_error", explicit_presence=True,
        wrap=Error,
        )
    @retrieving_error.setter
    def retrieving_error(self, value: "Error|tenant_user_account_pb2.Error|None") -> None:
        return super()._set_field("retrieving_error",value,explicit_presence=True,
        )
    
    @builtins.property
    def tenants(self) -> "abc.MutableSequence[UserTenantInfo]":
        return super()._get_field("tenants", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(UserTenantInfo,None,None),
        )
    @tenants.setter
    def tenants(self, value: "abc.Iterable[UserTenantInfo]|None") -> None:
        return super()._set_field("tenants",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "federation_info":"federation_info",
        "attributes":"attributes",
        "retrieving_error":"retrieving_error",
        "tenants":"tenants",
        "attributes_optional":"attributes_optional",
    }
    
class UserTenantInfo(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.UserTenantInfo
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserTenantInfo",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        tenant_user_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_id, unset.UnsetType):
            self.tenant_id = tenant_id
        if not isinstance(tenant_user_account_id, unset.UnsetType):
            self.tenant_user_account_id = tenant_user_account_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_id",
            "tenant_user_account_id",
        ]
    
    @builtins.property
    def tenant_id(self) -> "builtins.str":
        return super()._get_field("tenant_id", explicit_presence=False,
        )
    @tenant_id.setter
    def tenant_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def tenant_user_account_id(self) -> "builtins.str":
        return super()._get_field("tenant_user_account_id", explicit_presence=False,
        )
    @tenant_user_account_id.setter
    def tenant_user_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_user_account_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_id":"tenant_id",
        "tenant_user_account_id":"tenant_user_account_id",
    }
    
class ServiceAccountProfile(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.ServiceAccountProfile
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccountProfile",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        info: "ServiceAccount|service_account_pb2.ServiceAccount|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(info, unset.UnsetType):
            self.info = info
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "info",
        ]
    
    @builtins.property
    def info(self) -> "ServiceAccount":
        return super()._get_field("info", explicit_presence=False,
        wrap=ServiceAccount,
        )
    @info.setter
    def info(self, value: "ServiceAccount|service_account_pb2.ServiceAccount|None") -> None:
        return super()._set_field("info",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "info":"info",
    }
    
class AnonymousAccount(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.AnonymousAccount
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AnonymousAccount",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    

class ProfileServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.ProfileService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.ProfileService",profile_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.ProfileService"
    
    def get(self,
        request: "GetProfileRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetProfileRequest","GetProfileResponse"]:
        """
        Returns the current user's profile.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetProfileRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.GetProfileResponse`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=profile_service_pb2.GetProfileResponse,
            result_wrapper=pb_classes.simple_wrapper(GetProfileResponse),
            **kwargs,
        )
    

# file: nebius/iam/v1/project_service.proto
class CreateProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.CreateProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ContainerSpec|container_pb2.ContainerSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ContainerSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ContainerSpec,
        )
    @spec.setter
    def spec(self, value: "ContainerSpec|container_pb2.ContainerSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.GetProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetProjectByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.GetProjectByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetProjectByNameRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListProjectsRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.ListProjectsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListProjectsRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class UpdateProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.UpdateProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ContainerSpec|container_pb2.ContainerSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ContainerSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ContainerSpec,
        )
    @spec.setter
    def spec(self, value: "ContainerSpec|container_pb2.ContainerSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ListProjectsResponse(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.ListProjectsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListProjectsResponse",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Container]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Container]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Container,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Container]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class ProjectServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.ProjectService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.ProjectService",project_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.ProjectService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateProjectRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateProjectRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateProjectRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetProjectRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetProjectRequest","Container"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetProjectRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Container`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=container_pb2.Container,
            result_wrapper=pb_classes.simple_wrapper(Container),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetProjectByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetProjectByNameRequest","Container"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetProjectByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Container`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=container_pb2.Container,
            result_wrapper=pb_classes.simple_wrapper(Container),
            **kwargs,
        )
    
    def list(self,
        request: "ListProjectsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListProjectsRequest","ListProjectsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListProjectsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListProjectsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=project_service_pb2.ListProjectsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListProjectsResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateProjectRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateProjectRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateProjectRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/service_account_service.proto
class CreateServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.CreateServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ServiceAccountSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ServiceAccountSpec,
        )
    @spec.setter
    def spec(self, value: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.GetServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetServiceAccountByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.GetServiceAccountByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetServiceAccountByNameRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.ListServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class UpdateServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.UpdateServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ServiceAccountSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ServiceAccountSpec,
        )
    @spec.setter
    def spec(self, value: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.DeleteServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListServiceAccountResponse(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.ListServiceAccountResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListServiceAccountResponse",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[ServiceAccount]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[ServiceAccount]":
        """
        List of service accounts returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(ServiceAccount,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[ServiceAccount]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class ServiceAccountServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.ServiceAccountService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.ServiceAccountService",service_account_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.ServiceAccountService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateServiceAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateServiceAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateServiceAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetServiceAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetServiceAccountRequest","ServiceAccount"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetServiceAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ServiceAccount`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=service_account_pb2.ServiceAccount,
            result_wrapper=pb_classes.simple_wrapper(ServiceAccount),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetServiceAccountByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetServiceAccountByNameRequest","ServiceAccount"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetServiceAccountByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ServiceAccount`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=service_account_pb2.ServiceAccount,
            result_wrapper=pb_classes.simple_wrapper(ServiceAccount),
            **kwargs,
        )
    
    def list(self,
        request: "ListServiceAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListServiceAccountRequest","ListServiceAccountResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListServiceAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListServiceAccountResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=service_account_service_pb2.ListServiceAccountResponse,
            result_wrapper=pb_classes.simple_wrapper(ListServiceAccountResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateServiceAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateServiceAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateServiceAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteServiceAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteServiceAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteServiceAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/session_management_service.proto
class RevokeSessionRequest(pb_classes.Message):
    __PB2_CLASS__ = session_management_service_pb2.RevokeSessionRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.RevokeSessionRequest",session_management_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_revoke__(pb_classes.OneOf):
        name: builtins.str= "revoke"
        
        def __init__(self, msg: "RevokeSessionRequest") -> None:
            super().__init__()
            self._message: "RevokeSessionRequest" = msg
    
    class __OneOfClass_revoke_service_account_id__(__OneOfClass_revoke__):
        field: typing.Literal["service_account_id"] = "service_account_id"
        
        def __init__(self, msg: "RevokeSessionRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.service_account_id
    
    class __OneOfClass_revoke_all_my_active__(__OneOfClass_revoke__):
        field: typing.Literal["all_my_active"] = "all_my_active"
        
        def __init__(self, msg: "RevokeSessionRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.bool":
            return self._message.all_my_active
    
    class __OneOfClass_revoke_tenant_user_account_id__(__OneOfClass_revoke__):
        field: typing.Literal["tenant_user_account_id"] = "tenant_user_account_id"
        
        def __init__(self, msg: "RevokeSessionRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.tenant_user_account_id
    
    @builtins.property
    def revoke(self) -> __OneOfClass_revoke_service_account_id__|__OneOfClass_revoke_all_my_active__|__OneOfClass_revoke_tenant_user_account_id__|None:
        field_name_1: str|None = super().which_field_in_oneof("revoke")
        match field_name_1:
            case "service_account_id":
                return self.__OneOfClass_revoke_service_account_id__(self)
            case "all_my_active":
                return self.__OneOfClass_revoke_all_my_active__(self)
            case "tenant_user_account_id":
                return self.__OneOfClass_revoke_tenant_user_account_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        service_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        all_my_active: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        tenant_user_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(service_account_id, unset.UnsetType):
            self.service_account_id = service_account_id
        if not isinstance(all_my_active, unset.UnsetType):
            self.all_my_active = all_my_active
        if not isinstance(tenant_user_account_id, unset.UnsetType):
            self.tenant_user_account_id = tenant_user_account_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "service_account_id",
            "all_my_active",
            "tenant_user_account_id",
            "revoke",
        ]
    
    @builtins.property
    def service_account_id(self) -> "builtins.str|None":
        """
        revoke all for specific service account - to revoke logout from all sessions for user
        """
        
        return super()._get_field("service_account_id", explicit_presence=True,
        )
    @service_account_id.setter
    def service_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("service_account_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def all_my_active(self) -> "builtins.bool|None":
        """
        revoke all active session of current user
        """
        
        return super()._get_field("all_my_active", explicit_presence=True,
        )
    @all_my_active.setter
    def all_my_active(self, value: "builtins.bool|None") -> None:
        return super()._set_field("all_my_active",value,explicit_presence=True,
        )
    
    @builtins.property
    def tenant_user_account_id(self) -> "builtins.str|None":
        """
        revoke all for specific tenant user - to revoke logout from all sessions for user
        """
        
        return super()._get_field("tenant_user_account_id", explicit_presence=True,
        )
    @tenant_user_account_id.setter
    def tenant_user_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_user_account_id",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "service_account_id":"service_account_id",
        "all_my_active":"all_my_active",
        "tenant_user_account_id":"tenant_user_account_id",
        "revoke":"revoke",
    }
    
class RevokeSessionResponse(pb_classes.Message):
    __PB2_CLASS__ = session_management_service_pb2.RevokeSessionResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.RevokeSessionResponse",session_management_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    

class SessionManagementServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.SessionManagementService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.SessionManagementService",session_management_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.SessionManagementService"
    
    def revoke(self,
        request: "RevokeSessionRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["RevokeSessionRequest","RevokeSessionResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.RevokeSessionRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.RevokeSessionResponse`.
        """
        
        return super().request(
            method="Revoke",
            request=request,
            result_pb2_class=session_management_service_pb2.RevokeSessionResponse,
            result_wrapper=pb_classes.simple_wrapper(RevokeSessionResponse),
            **kwargs,
        )
    

# file: nebius/iam/v1/static_key.proto
class StaticKey(pb_classes.Message):
    __PB2_CLASS__ = static_key_pb2.StaticKey
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.StaticKey",static_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "StaticKeySpec|static_key_pb2.StaticKeySpec|None|unset.UnsetType" = unset.Unset,
        status: "StaticKeyStatus|static_key_pb2.StaticKeyStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "StaticKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=StaticKeySpec,
        )
    @spec.setter
    def spec(self, value: "StaticKeySpec|static_key_pb2.StaticKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "StaticKeyStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=StaticKeyStatus,
        )
    @status.setter
    def status(self, value: "StaticKeyStatus|static_key_pb2.StaticKeyStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class StaticKeySpec(pb_classes.Message):
    __PB2_CLASS__ = static_key_pb2.StaticKeySpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.StaticKeySpec",static_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expiresAt": well_known_1.ts_mask,
    }
    
    class ClientService(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.StaticKeySpec.ClientService",static_key_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        CLIENT_SERVICE_UNSPECIFIED = 0
        OBSERVABILITY = 1
        CONTAINER_REGISTRY = 2
        AI_STUDIO = 3
        TRACTO = 4
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        service: "StaticKeySpec.ClientService|static_key_pb2.StaticKeySpec.ClientService|None|unset.UnsetType" = unset.Unset,
        expiresAt: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(service, unset.UnsetType):
            self.service = service
        if not isinstance(expiresAt, unset.UnsetType):
            self.expiresAt = expiresAt
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "service",
            "expiresAt",
            "ClientService",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        """
        account of the static key. only service accounts are supported for now
        """
        
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def service(self) -> "StaticKeySpec.ClientService":
        """
        service static key is to be used for
        """
        
        return super()._get_field("service", explicit_presence=False,
        wrap=StaticKeySpec.ClientService,
        )
    @service.setter
    def service(self, value: "StaticKeySpec.ClientService|static_key_pb2.StaticKeySpec.ClientService|None") -> None:
        return super()._set_field("service",value,explicit_presence=False,
        )
    
    @builtins.property
    def expiresAt(self) -> "datetime.datetime":
        """
        when will the static key expire
        """
        
        return super()._get_field("expiresAt", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expiresAt.setter
    def expiresAt(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expiresAt",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "service":"service",
        "expiresAt":"expiresAt",
        "ClientService":"ClientService",
    }
    
class StaticKeyStatus(pb_classes.Message):
    __PB2_CLASS__ = static_key_pb2.StaticKeyStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.StaticKeyStatus",static_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        active: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(active, unset.UnsetType):
            self.active = active
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "active",
        ]
    
    @builtins.property
    def active(self) -> "builtins.bool":
        return super()._get_field("active", explicit_presence=False,
        )
    @active.setter
    def active(self, value: "builtins.bool|None") -> None:
        return super()._set_field("active",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "active":"active",
    }
    
# file: nebius/iam/v1/static_key_service.proto
class GetStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.GetStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        id of the static key
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetStaticKeyByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.GetStaticKeyByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetStaticKeyByNameRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        id of the parent container (service account)
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        name of the static key
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class DeleteStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.DeleteStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        id of the static key to delete
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListStaticKeysRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.ListStaticKeysRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListStaticKeysRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListStaticKeysResponse(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.ListStaticKeysResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListStaticKeysResponse",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[StaticKey]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[StaticKey]":
        """
        List of static keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(StaticKey,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[StaticKey]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class IssueStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.IssueStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.IssueStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "StaticKeySpec|static_key_pb2.StaticKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "StaticKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=StaticKeySpec,
        )
    @spec.setter
    def spec(self, value: "StaticKeySpec|static_key_pb2.StaticKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class IssueStaticKeyResponse(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.IssueStaticKeyResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.IssueStaticKeyResponse",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        operation: "v1_1.Operation|operation_pb2.Operation|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(token, unset.UnsetType):
            self.token = token
        if not isinstance(operation, unset.UnsetType):
            self.operation = operation
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "token",
            "operation",
        ]
    
    @builtins.property
    def token(self) -> "builtins.str":
        return super()._get_field("token", explicit_presence=False,
        )
    @token.setter
    def token(self, value: "builtins.str|None") -> None:
        return super()._set_field("token",value,explicit_presence=False,
        )
    
    @builtins.property
    def operation(self) -> "v1_1.Operation":
        return super()._get_field("operation", explicit_presence=False,
        wrap=v1_1.Operation,
        )
    @operation.setter
    def operation(self, value: "v1_1.Operation|operation_pb2.Operation|None") -> None:
        return super()._set_field("operation",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "token":"token",
        "operation":"operation",
    }
    
class FindStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.FindStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FindStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(token, unset.UnsetType):
            self.token = token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "token",
        ]
    
    @builtins.property
    def token(self) -> "builtins.str":
        """
        the method accepts a static key token with and without signature as an input
        """
        
        return super()._get_field("token", explicit_presence=False,
        )
    @token.setter
    def token(self, value: "builtins.str|None") -> None:
        return super()._set_field("token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "token":"token",
    }
    
class FindStaticKeyResponse(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.FindStaticKeyResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FindStaticKeyResponse",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        static_key: "StaticKey|static_key_pb2.StaticKey|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(static_key, unset.UnsetType):
            self.static_key = static_key
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "static_key",
        ]
    
    @builtins.property
    def static_key(self) -> "StaticKey":
        return super()._get_field("static_key", explicit_presence=False,
        wrap=StaticKey,
        )
    @static_key.setter
    def static_key(self, value: "StaticKey|static_key_pb2.StaticKey|None") -> None:
        return super()._set_field("static_key",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "static_key":"static_key",
    }
    
class RevokeStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.RevokeStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.RevokeStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(token, unset.UnsetType):
            self.token = token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "token",
        ]
    
    @builtins.property
    def token(self) -> "builtins.str":
        """
        the method accepts a static key token with and without signature as an input
        """
        
        return super()._get_field("token", explicit_presence=False,
        )
    @token.setter
    def token(self, value: "builtins.str|None") -> None:
        return super()._set_field("token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "token":"token",
    }
    

class StaticKeyServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.StaticKeyService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.StaticKeyService",static_key_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.StaticKeyService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Delete"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def issue(self,
        request: "IssueStaticKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["IssueStaticKeyRequest","IssueStaticKeyResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.IssueStaticKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.IssueStaticKeyResponse`.
        """
        
        return super().request(
            method="Issue",
            request=request,
            result_pb2_class=static_key_service_pb2.IssueStaticKeyResponse,
            result_wrapper=pb_classes.simple_wrapper(IssueStaticKeyResponse),
            **kwargs,
        )
    
    def list(self,
        request: "ListStaticKeysRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListStaticKeysRequest","ListStaticKeysResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListStaticKeysRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListStaticKeysResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=static_key_service_pb2.ListStaticKeysResponse,
            result_wrapper=pb_classes.simple_wrapper(ListStaticKeysResponse),
            **kwargs,
        )
    
    def get(self,
        request: "GetStaticKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetStaticKeyRequest","StaticKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetStaticKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.StaticKey`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=static_key_pb2.StaticKey,
            result_wrapper=pb_classes.simple_wrapper(StaticKey),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetStaticKeyByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetStaticKeyByNameRequest","StaticKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetStaticKeyByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.StaticKey`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=static_key_pb2.StaticKey,
            result_wrapper=pb_classes.simple_wrapper(StaticKey),
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteStaticKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteStaticKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteStaticKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def find(self,
        request: "FindStaticKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["FindStaticKeyRequest","FindStaticKeyResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.FindStaticKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.FindStaticKeyResponse`.
        """
        
        return super().request(
            method="Find",
            request=request,
            result_pb2_class=static_key_service_pb2.FindStaticKeyResponse,
            result_wrapper=pb_classes.simple_wrapper(FindStaticKeyResponse),
            **kwargs,
        )
    
    def revoke(self,
        request: "RevokeStaticKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["RevokeStaticKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.RevokeStaticKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Revoke",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/tenant_service.proto
class GetTenantRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.GetTenantRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetTenantRequest",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListTenantsRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.ListTenantsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantsRequest",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListTenantsResponse(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.ListTenantsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantsResponse",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Container]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Container]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Container,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Container]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class TenantServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.TenantService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.TenantService",tenant_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.TenantService"
    
    def get(self,
        request: "GetTenantRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetTenantRequest","Container"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetTenantRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Container`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=container_pb2.Container,
            result_wrapper=pb_classes.simple_wrapper(Container),
            **kwargs,
        )
    
    def list(self,
        request: "ListTenantsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListTenantsRequest","ListTenantsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListTenantsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListTenantsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=tenant_service_pb2.ListTenantsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListTenantsResponse),
            **kwargs,
        )
    

# file: nebius/iam/v1/tenant_user_account_service.proto
class GetTenantUserAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.GetTenantUserAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetTenantUserAccountRequest",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        tenant user account id like 'tenantuseraccount-{region}someuniquesuffix'
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListTenantUserAccountsRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.ListTenantUserAccountsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantUserAccountsRequest",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the tenant ID like 'tenant-someuniqueprefix'
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListTenantUserAccountsResponse(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.ListTenantUserAccountsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantUserAccountsResponse",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[TenantUserAccount]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[TenantUserAccount]":
        """
        List of service accounts returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(TenantUserAccount,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[TenantUserAccount]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class BlockTenantUserAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.BlockTenantUserAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.BlockTenantUserAccountRequest",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UnblockTenantUserAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.UnblockTenantUserAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UnblockTenantUserAccountRequest",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class TenantUserAccountServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.TenantUserAccountService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.TenantUserAccountService",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.TenantUserAccountService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Block"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetTenantUserAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetTenantUserAccountRequest","TenantUserAccount"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetTenantUserAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.TenantUserAccount`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=tenant_user_account_pb2.TenantUserAccount,
            result_wrapper=pb_classes.simple_wrapper(TenantUserAccount),
            **kwargs,
        )
    
    def list(self,
        request: "ListTenantUserAccountsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListTenantUserAccountsRequest","ListTenantUserAccountsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListTenantUserAccountsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListTenantUserAccountsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=tenant_user_account_service_pb2.ListTenantUserAccountsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListTenantUserAccountsResponse),
            **kwargs,
        )
    
    def block(self,
        request: "BlockTenantUserAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["BlockTenantUserAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.BlockTenantUserAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Block",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    
    def unblock(self,
        request: "UnblockTenantUserAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UnblockTenantUserAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UnblockTenantUserAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Unblock",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation_1.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v1/tenant_user_account_with_attributes_service.proto
class GetTenantUserAccountWithAttributesRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_with_attributes_service_pb2.GetTenantUserAccountWithAttributesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetTenantUserAccountWithAttributesRequest",tenant_user_account_with_attributes_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        tenant user account id like 'tenantuseraccount-{region}someuniquesuffix'
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListTenantUserAccountsWithAttributesRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_with_attributes_service_pb2.ListTenantUserAccountsWithAttributesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantUserAccountsWithAttributesRequest",tenant_user_account_with_attributes_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the tenant ID like 'tenant-{region}someuniquesuffix'
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListTenantUserAccountsWithAttributesResponse(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_with_attributes_service_pb2.ListTenantUserAccountsWithAttributesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantUserAccountsWithAttributesResponse",tenant_user_account_with_attributes_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[TenantUserAccountWithAttributes]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[TenantUserAccountWithAttributes]":
        """
        List of user accounts returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(TenantUserAccountWithAttributes,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[TenantUserAccountWithAttributes]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class TenantUserAccountWithAttributesServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.TenantUserAccountWithAttributesService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.TenantUserAccountWithAttributesService",tenant_user_account_with_attributes_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.TenantUserAccountWithAttributesService"
    
    def get(self,
        request: "GetTenantUserAccountWithAttributesRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetTenantUserAccountWithAttributesRequest","TenantUserAccountWithAttributes"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetTenantUserAccountWithAttributesRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.TenantUserAccountWithAttributes`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=tenant_user_account_pb2.TenantUserAccountWithAttributes,
            result_wrapper=pb_classes.simple_wrapper(TenantUserAccountWithAttributes),
            **kwargs,
        )
    
    def list(self,
        request: "ListTenantUserAccountsWithAttributesRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListTenantUserAccountsWithAttributesRequest","ListTenantUserAccountsWithAttributesResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListTenantUserAccountsWithAttributesRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListTenantUserAccountsWithAttributesResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=tenant_user_account_with_attributes_service_pb2.ListTenantUserAccountsWithAttributesResponse,
            result_wrapper=pb_classes.simple_wrapper(ListTenantUserAccountsWithAttributesResponse),
            **kwargs,
        )
    

# file: nebius/iam/v1/token_service.proto
class ExchangeTokenRequest(pb_classes.Message):
    """
    https://www.rfc-editor.org/rfc/rfc8693.html
    """
    
    __PB2_CLASS__ = token_service_pb2.ExchangeTokenRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ExchangeTokenRequest",token_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        grant_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        requested_token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subject_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subject_token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        scopes: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        audience: "builtins.str|None|unset.UnsetType" = unset.Unset,
        actor_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        actor_token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(grant_type, unset.UnsetType):
            self.grant_type = grant_type
        if not isinstance(requested_token_type, unset.UnsetType):
            self.requested_token_type = requested_token_type
        if not isinstance(subject_token, unset.UnsetType):
            self.subject_token = subject_token
        if not isinstance(subject_token_type, unset.UnsetType):
            self.subject_token_type = subject_token_type
        if not isinstance(scopes, unset.UnsetType):
            self.scopes = scopes
        if not isinstance(audience, unset.UnsetType):
            self.audience = audience
        if not isinstance(actor_token, unset.UnsetType):
            self.actor_token = actor_token
        if not isinstance(actor_token_type, unset.UnsetType):
            self.actor_token_type = actor_token_type
        if not isinstance(resource, unset.UnsetType):
            self.resource = resource
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "grant_type",
            "requested_token_type",
            "subject_token",
            "subject_token_type",
            "scopes",
            "audience",
            "actor_token",
            "actor_token_type",
            "resource",
        ]
    
    @builtins.property
    def grant_type(self) -> "builtins.str":
        """
        required - urn:ietf:params:oauth:grant-type:token-exchange
        """
        
        return super()._get_field("grant_type", explicit_presence=False,
        )
    @grant_type.setter
    def grant_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("grant_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def requested_token_type(self) -> "builtins.str":
        """
        optional type of requested token, default is urn:ietf:params:oauth:token-type:access_token
        """
        
        return super()._get_field("requested_token_type", explicit_presence=False,
        )
    @requested_token_type.setter
    def requested_token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("requested_token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def subject_token(self) -> "builtins.str":
        """
        required - could be self signed JWT token
        """
        
        return super()._get_field("subject_token", explicit_presence=False,
        )
    @subject_token.setter
    def subject_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("subject_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def subject_token_type(self) -> "builtins.str":
        """
        required, in case of jwt - urn:ietf:params:oauth:token-type:jwt
        """
        
        return super()._get_field("subject_token_type", explicit_presence=False,
        )
    @subject_token_type.setter
    def subject_token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("subject_token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def scopes(self) -> "abc.MutableSequence[builtins.str]":
        """
        optional (scopes of the token)
        """
        
        return super()._get_field("scopes", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @scopes.setter
    def scopes(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("scopes",value,explicit_presence=False,
        )
    
    @builtins.property
    def audience(self) -> "builtins.str":
        """
        optional, name of the oauth client id on which this token will be used
        """
        
        return super()._get_field("audience", explicit_presence=False,
        )
    @audience.setter
    def audience(self, value: "builtins.str|None") -> None:
        return super()._set_field("audience",value,explicit_presence=False,
        )
    
    @builtins.property
    def actor_token(self) -> "builtins.str":
        """
        optional, subject token for impersonation/delegation (who want to impersonate/delegate) in subject_token.
        """
        
        return super()._get_field("actor_token", explicit_presence=False,
        )
    @actor_token.setter
    def actor_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("actor_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def actor_token_type(self) -> "builtins.str":
        """
        optional, token type for the impersonation/delegation (who want to impersonate/delegate). Usually it's urn:ietf:params:oauth:token-type:access_token
        """
        
        return super()._get_field("actor_token_type", explicit_presence=False,
        )
    @actor_token_type.setter
    def actor_token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("actor_token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource(self) -> "abc.MutableSequence[builtins.str]":
        """
        optional, list of resources approved to use by token, if applicable
        """
        
        return super()._get_field("resource", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @resource.setter
    def resource(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("resource",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "grant_type":"grant_type",
        "requested_token_type":"requested_token_type",
        "subject_token":"subject_token",
        "subject_token_type":"subject_token_type",
        "scopes":"scopes",
        "audience":"audience",
        "actor_token":"actor_token",
        "actor_token_type":"actor_token_type",
        "resource":"resource",
    }
    
class CreateTokenResponse(pb_classes.Message):
    __PB2_CLASS__ = token_service_pb2.CreateTokenResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateTokenResponse",token_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        access_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        issued_token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        expires_in: "builtins.int|None|unset.UnsetType" = unset.Unset,
        scopes: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(access_token, unset.UnsetType):
            self.access_token = access_token
        if not isinstance(issued_token_type, unset.UnsetType):
            self.issued_token_type = issued_token_type
        if not isinstance(token_type, unset.UnsetType):
            self.token_type = token_type
        if not isinstance(expires_in, unset.UnsetType):
            self.expires_in = expires_in
        if not isinstance(scopes, unset.UnsetType):
            self.scopes = scopes
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "access_token",
            "issued_token_type",
            "token_type",
            "expires_in",
            "scopes",
        ]
    
    @builtins.property
    def access_token(self) -> "builtins.str":
        """
        required
        """
        
        return super()._get_field("access_token", explicit_presence=False,
        )
    @access_token.setter
    def access_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("access_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def issued_token_type(self) -> "builtins.str":
        """
        required
        """
        
        return super()._get_field("issued_token_type", explicit_presence=False,
        )
    @issued_token_type.setter
    def issued_token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("issued_token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def token_type(self) -> "builtins.str":
        """
        required - Bearer
        """
        
        return super()._get_field("token_type", explicit_presence=False,
        )
    @token_type.setter
    def token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_in(self) -> "builtins.int":
        return super()._get_field("expires_in", explicit_presence=False,
        )
    @expires_in.setter
    def expires_in(self, value: "builtins.int|None") -> None:
        return super()._set_field("expires_in",value,explicit_presence=False,
        )
    
    @builtins.property
    def scopes(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("scopes", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @scopes.setter
    def scopes(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("scopes",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "access_token":"access_token",
        "issued_token_type":"issued_token_type",
        "token_type":"token_type",
        "expires_in":"expires_in",
        "scopes":"scopes",
    }
    
# file: nebius/iam/v1/token_exchange_service.proto

class TokenExchangeServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.TokenExchangeService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.TokenExchangeService",token_exchange_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.TokenExchangeService"
    
    def exchange(self,
        request: "ExchangeTokenRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ExchangeTokenRequest","CreateTokenResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ExchangeTokenRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.CreateTokenResponse`.
        """
        
        return super().request(
            method="Exchange",
            request=request,
            result_pb2_class=token_service_pb2.CreateTokenResponse,
            result_wrapper=pb_classes.simple_wrapper(CreateTokenResponse),
            **kwargs,
        )
    

__all__ = [
    #@ local import names here @#
    "Account",
    "AccessKey",
    "AccessKeySpec",
    "AccessKeyStatus",
    "CreateAccessKeyRequest",
    "KeyIdentity",
    "GetAccessKeySecretOnceRequest",
    "GetAccessKeyByIdRequest",
    "GetAccessKeyByAwsIdRequest",
    "ListAccessKeysRequest",
    "ListAccessKeysByAccountRequest",
    "UpdateAccessKeyRequest",
    "ActivateAccessKeyRequest",
    "DeactivateAccessKeyRequest",
    "DeleteAccessKeyRequest",
    "GetAccessKeySecretOnceResponse",
    "ListAccessKeysResponse",
    "AccessKeyServiceClient",
    "AccessPermit",
    "AccessPermitSpec",
    "AccessPermitStatus",
    "CreateAccessPermitRequest",
    "ListAccessPermitRequest",
    "DeleteAccessPermitRequest",
    "GetAccessPermitRequest",
    "ListAccessPermitResponse",
    "AccessPermitServiceClient",
    "AuthPublicKey",
    "AuthPublicKeySpec",
    "AuthPublicKeyStatus",
    "CreateAuthPublicKeyRequest",
    "GetAuthPublicKeyRequest",
    "ListAuthPublicKeyRequest",
    "ListAuthPublicKeyByAccountRequest",
    "UpdateAuthPublicKeyRequest",
    "ActivateAuthPublicKeyRequest",
    "DeactivateAuthPublicKeyRequest",
    "DeleteAuthPublicKeyRequest",
    "ListAuthPublicKeyResponse",
    "AuthPublicKeyServiceClient",
    "State",
    "SuspensionState",
    "Container",
    "ContainerSpec",
    "ContainerStatus",
    "FederatedCredentials",
    "FederatedCredentialsSpec",
    "OidcCredentialsProvider",
    "FederatedCredentialsStatus",
    "GetFederatedCredentialsRequest",
    "GetByNameFederatedCredentialsRequest",
    "CreateFederatedCredentialsRequest",
    "UpdateFederatedCredentialsRequest",
    "ListFederatedCredentialsRequest",
    "ListFederatedCredentialsResponse",
    "DeleteFederatedCredentialsRequest",
    "FederatedCredentialsServiceClient",
    "Federation",
    "FederationSpec",
    "SamlSettings",
    "FederationStatus",
    "FederationCertificate",
    "FederationCertificateSpec",
    "FederationCertificateStatus",
    "CreateFederationCertificateRequest",
    "GetFederationCertificateRequest",
    "ListFederationCertificateByFederationRequest",
    "UpdateFederationCertificateRequest",
    "UpdateBulkFederationCertificateRequest",
    "DeleteFederationCertificateRequest",
    "ListFederationCertificateResponse",
    "FederationCertificateServiceClient",
    "CreateFederationRequest",
    "GetFederationRequest",
    "ListFederationsRequest",
    "ListFederationsResponse",
    "UpdateFederationRequest",
    "ActivateFederationRequest",
    "DeactivateFederationRequest",
    "DeleteFederationRequest",
    "FederationServiceClient",
    "Group",
    "GroupSpec",
    "GroupStatus",
    "ServiceAccount",
    "ServiceAccountSpec",
    "ServiceAccountStatus",
    "ServiceAccountAttributes",
    "UserAccountExternalId",
    "UserAccountStatus",
    "TenantUserAccount",
    "TenantUserAccountWithAttributes",
    "UserAttributes",
    "Error",
    "TenantUserAccountSpec",
    "TenantUserAccountStatus",
    "GroupMembership",
    "GroupMembershipSpec",
    "GroupMembershipStatus",
    "GroupMemberKind",
    "GroupMembershipWithAttributes",
    "CreateGroupMembershipRequest",
    "DeleteGroupMembershipRequest",
    "GetGroupMembershipRequest",
    "ListGroupMembershipsRequest",
    "ListMemberOfRequest",
    "ListGroupMembershipsResponse",
    "ListGroupMembershipsWithAttributesResponse",
    "ListMemberOfResponse",
    "GroupMembershipServiceClient",
    "CreateGroupRequest",
    "GetGroupRequest",
    "GetGroupByNameRequest",
    "ListGroupsRequest",
    "ListGroupsResponse",
    "DeleteGroupRequest",
    "UpdateGroupRequest",
    "GroupServiceClient",
    "Invitation",
    "InvitationSpec",
    "InvitationStatus",
    "CreateInvitationRequest",
    "GetInvitationRequest",
    "ListInvitationsRequest",
    "ListInvitationsResponse",
    "DeleteInvitationRequest",
    "UpdateInvitationRequest",
    "ResendInvitationRequest",
    "InvitationServiceClient",
    "GetProfileRequest",
    "GetProfileResponse",
    "UserProfile",
    "UserTenantInfo",
    "ServiceAccountProfile",
    "AnonymousAccount",
    "ProfileServiceClient",
    "CreateProjectRequest",
    "GetProjectRequest",
    "GetProjectByNameRequest",
    "ListProjectsRequest",
    "UpdateProjectRequest",
    "ListProjectsResponse",
    "ProjectServiceClient",
    "CreateServiceAccountRequest",
    "GetServiceAccountRequest",
    "GetServiceAccountByNameRequest",
    "ListServiceAccountRequest",
    "UpdateServiceAccountRequest",
    "DeleteServiceAccountRequest",
    "ListServiceAccountResponse",
    "ServiceAccountServiceClient",
    "RevokeSessionRequest",
    "RevokeSessionResponse",
    "SessionManagementServiceClient",
    "StaticKey",
    "StaticKeySpec",
    "StaticKeyStatus",
    "GetStaticKeyRequest",
    "GetStaticKeyByNameRequest",
    "DeleteStaticKeyRequest",
    "ListStaticKeysRequest",
    "ListStaticKeysResponse",
    "IssueStaticKeyRequest",
    "IssueStaticKeyResponse",
    "FindStaticKeyRequest",
    "FindStaticKeyResponse",
    "RevokeStaticKeyRequest",
    "StaticKeyServiceClient",
    "GetTenantRequest",
    "ListTenantsRequest",
    "ListTenantsResponse",
    "TenantServiceClient",
    "GetTenantUserAccountRequest",
    "ListTenantUserAccountsRequest",
    "ListTenantUserAccountsResponse",
    "BlockTenantUserAccountRequest",
    "UnblockTenantUserAccountRequest",
    "TenantUserAccountServiceClient",
    "GetTenantUserAccountWithAttributesRequest",
    "ListTenantUserAccountsWithAttributesRequest",
    "ListTenantUserAccountsWithAttributesResponse",
    "TenantUserAccountWithAttributesServiceClient",
    "ExchangeTokenRequest",
    "CreateTokenResponse",
    "TokenExchangeServiceClient",
]
