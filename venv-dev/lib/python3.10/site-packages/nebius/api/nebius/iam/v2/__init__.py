# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.iam.v2``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.aio.request_kwargs as request_kwargs
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1.operation_pb2 as operation_pb2
import nebius.api.nebius.iam.v1 as v1_2
import nebius.api.nebius.iam.v1.access_pb2 as access_pb2
import nebius.api.nebius.iam.v2.access_key_pb2 as access_key_pb2
import nebius.api.nebius.iam.v2.access_key_service_pb2 as access_key_service_pb2
import nebius.api.nebius.iam.v2.project_pb2 as project_pb2
import nebius.api.nebius.iam.v2.project_service_pb2 as project_service_pb2
import nebius.api.nebius.iam.v2.tenant_pb2 as tenant_pb2
import nebius.api.nebius.iam.v2.tenant_service_pb2 as tenant_service_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing_extensions as typing_extensions
#@ local imports here @#

# file: nebius/iam/v2/access_key.proto
class SecretDeliveryMode(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v2.SecretDeliveryMode",access_key_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    UNSPECIFIED = 0
    """
    If not specified, the default behaviour will be applied. Currently it's INLINE, later will be EXPLICIT.
    """
    
    INLINE = 1
    """
    The secret value will be returned directly in the API response
    """
    
    MYSTERY_BOX = 2
    """
    The secret will be delivered via a MysteryBox secret, in case of terraform it is recommended to use that enum
    """
    
    EXPLICIT = 3
    """
    The secret value will be accessible via a separate method GetSecret
    """
    

class AccessKey(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKey
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.AccessKey",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
        status: "AccessKeyStatus|access_key_pb2.AccessKeyStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "AccessKeyStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=AccessKeyStatus,
        )
    @status.setter
    def status(self, value: "AccessKeyStatus|access_key_pb2.AccessKeyStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class AccessKeySpec(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKeySpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.AccessKeySpec",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expires_at": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "v1_2.Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        expires_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        secret_delivery_mode: "SecretDeliveryMode|access_key_pb2.SecretDeliveryMode|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(expires_at, unset.UnsetType):
            self.expires_at = expires_at
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(secret_delivery_mode, unset.UnsetType):
            self.secret_delivery_mode = secret_delivery_mode
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "expires_at",
            "description",
            "secret_delivery_mode",
        ]
    
    @builtins.property
    def account(self) -> "v1_2.Account":
        return super()._get_field("account", explicit_presence=False,
        wrap=v1_2.Account,
        )
    @account.setter
    def account(self, value: "v1_2.Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_at(self) -> "datetime.datetime":
        return super()._get_field("expires_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expires_at.setter
    def expires_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expires_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def secret_delivery_mode(self) -> "SecretDeliveryMode":
        """
        Specifies how the secret will be delivered upon creation. This field is immutable â€” it cannot be changed after the resource is created.
        """
        
        return super()._get_field("secret_delivery_mode", explicit_presence=False,
        wrap=SecretDeliveryMode,
        )
    @secret_delivery_mode.setter
    def secret_delivery_mode(self, value: "SecretDeliveryMode|access_key_pb2.SecretDeliveryMode|None") -> None:
        return super()._set_field("secret_delivery_mode",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "expires_at":"expires_at",
        "description":"description",
        "secret_delivery_mode":"secret_delivery_mode",
    }
    
class AccessKeyStatus(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKeyStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.AccessKeyStatus",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v2.AccessKeyStatus.State",access_key_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        INACTIVE = 2
        EXPIRED = 3
        DELETING = 4
        DELETED = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "AccessKeyStatus.State|access_key_pb2.AccessKeyStatus.State|None|unset.UnsetType" = unset.Unset,
        fingerprint: "builtins.str|None|unset.UnsetType" = unset.Unset,
        algorithm: "builtins.str|None|unset.UnsetType" = unset.Unset,
        key_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        secret: "builtins.str|None|unset.UnsetType" = unset.Unset,
        secret_reference_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(fingerprint, unset.UnsetType):
            self.fingerprint = fingerprint
        if not isinstance(algorithm, unset.UnsetType):
            self.algorithm = algorithm
        if not isinstance(key_size, unset.UnsetType):
            self.key_size = key_size
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
        if not isinstance(secret, unset.UnsetType):
            self.secret = secret
        if not isinstance(secret_reference_id, unset.UnsetType):
            self.secret_reference_id = secret_reference_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "fingerprint",
            "algorithm",
            "key_size",
            "aws_access_key_id",
            "secret",
            "secret_reference_id",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "AccessKeyStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=AccessKeyStatus.State,
        )
    @state.setter
    def state(self, value: "AccessKeyStatus.State|access_key_pb2.AccessKeyStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def fingerprint(self) -> "builtins.str":
        return super()._get_field("fingerprint", explicit_presence=False,
        )
    @fingerprint.setter
    def fingerprint(self, value: "builtins.str|None") -> None:
        return super()._set_field("fingerprint",value,explicit_presence=False,
        )
    
    @builtins.property
    def algorithm(self) -> "builtins.str":
        return super()._get_field("algorithm", explicit_presence=False,
        )
    @algorithm.setter
    def algorithm(self, value: "builtins.str|None") -> None:
        return super()._set_field("algorithm",value,explicit_presence=False,
        )
    
    @builtins.property
    def key_size(self) -> "builtins.int":
        return super()._get_field("key_size", explicit_presence=False,
        )
    @key_size.setter
    def key_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("key_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def secret(self) -> "builtins.str":
        return super()._get_field("secret", explicit_presence=False,
        )
    @secret.setter
    def secret(self, value: "builtins.str|None") -> None:
        return super()._set_field("secret",value,explicit_presence=False,
        )
    
    @builtins.property
    def secret_reference_id(self) -> "builtins.str":
        return super()._get_field("secret_reference_id", explicit_presence=False,
        )
    @secret_reference_id.setter
    def secret_reference_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("secret_reference_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "fingerprint":"fingerprint",
        "algorithm":"algorithm",
        "key_size":"key_size",
        "aws_access_key_id":"aws_access_key_id",
        "secret":"secret",
        "secret_reference_id":"secret_reference_id",
        "State":"State",
    }
    
# file: nebius/iam/v2/access_key_service.proto
class CreateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.CreateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.CreateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.GetAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessKeySecretRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeySecretRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.GetAccessKeySecretRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessKeyByAwsIdRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeyByAwsIdRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.GetAccessKeyByAwsIdRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "aws_access_key_id",
        ]
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "aws_access_key_id":"aws_access_key_id",
    }
    
class ListAccessKeysRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ListAccessKeysRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListAccessKeysByAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysByAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ListAccessKeysByAccountRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "v1_2.Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def account(self) -> "v1_2.Account":
        """
        Represents the parent account ID.
        """
        
        return super()._get_field("account", explicit_presence=False,
        wrap=v1_2.Account,
        )
    @account.setter
    def account(self, value: "v1_2.Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class UpdateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.UpdateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.UpdateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ActivateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ActivateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ActivateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeactivateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.DeactivateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.DeactivateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ActivateAccessKeyByAwsIdRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ActivateAccessKeyByAwsIdRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ActivateAccessKeyByAwsIdRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "aws_access_key_id",
        ]
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "aws_access_key_id":"aws_access_key_id",
    }
    
class DeactivateAccessKeyByAwsIdRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.DeactivateAccessKeyByAwsIdRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.DeactivateAccessKeyByAwsIdRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "aws_access_key_id",
        ]
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "aws_access_key_id":"aws_access_key_id",
    }
    
class DeleteAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.DeleteAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.DeleteAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeleteAccessKeyByAwsIdRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.DeleteAccessKeyByAwsIdRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.DeleteAccessKeyByAwsIdRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "aws_access_key_id",
        ]
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "aws_access_key_id":"aws_access_key_id",
    }
    
class GetAccessKeySecretResponse(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeySecretResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.GetAccessKeySecretResponse",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        secret: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
        if not isinstance(secret, unset.UnsetType):
            self.secret = secret
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "aws_access_key_id",
            "secret",
        ]
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def secret(self) -> "builtins.str":
        return super()._get_field("secret", explicit_presence=False,
        )
    @secret.setter
    def secret(self, value: "builtins.str|None") -> None:
        return super()._set_field("secret",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "aws_access_key_id":"aws_access_key_id",
        "secret":"secret",
    }
    
class ListAccessKeysResponse(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ListAccessKeysResponse",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[AccessKey]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[AccessKey]":
        """
        List of access keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AccessKey,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[AccessKey]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class AccessKeyServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v2.AccessKeyService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v2.AccessKeyService",access_key_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v2.AccessKeyService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateAccessKeyRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.CreateAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetAccessKeyRequest","AccessKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.GetAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.AccessKey`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=access_key_pb2.AccessKey,
            result_wrapper=pb_classes.simple_wrapper(AccessKey),
            **kwargs,
        )
    
    def get_secret(self,
        request: "GetAccessKeySecretRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetAccessKeySecretRequest","GetAccessKeySecretResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.GetAccessKeySecretRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.GetAccessKeySecretResponse`.
        """
        
        return super().request(
            method="GetSecret",
            request=request,
            result_pb2_class=access_key_service_pb2.GetAccessKeySecretResponse,
            result_wrapper=pb_classes.simple_wrapper(GetAccessKeySecretResponse),
            **kwargs,
        )
    
    def list(self,
        request: "ListAccessKeysRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListAccessKeysRequest","ListAccessKeysResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.ListAccessKeysRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.ListAccessKeysResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=access_key_service_pb2.ListAccessKeysResponse,
            result_wrapper=pb_classes.simple_wrapper(ListAccessKeysResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateAccessKeyRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.UpdateAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteAccessKeyRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.DeleteAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def activate(self,
        request: "ActivateAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ActivateAccessKeyRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.ActivateAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Activate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def deactivate(self,
        request: "DeactivateAccessKeyRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeactivateAccessKeyRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.DeactivateAccessKeyRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Deactivate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def list_by_account(self,
        request: "ListAccessKeysByAccountRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListAccessKeysByAccountRequest","ListAccessKeysResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.ListAccessKeysByAccountRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.ListAccessKeysResponse`.
        """
        
        return super().request(
            method="ListByAccount",
            request=request,
            result_pb2_class=access_key_service_pb2.ListAccessKeysResponse,
            result_wrapper=pb_classes.simple_wrapper(ListAccessKeysResponse),
            **kwargs,
        )
    
    def get_by_aws_id(self,
        request: "GetAccessKeyByAwsIdRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetAccessKeyByAwsIdRequest","AccessKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.GetAccessKeyByAwsIdRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.AccessKey`.
        """
        
        return super().request(
            method="GetByAwsId",
            request=request,
            result_pb2_class=access_key_pb2.AccessKey,
            result_wrapper=pb_classes.simple_wrapper(AccessKey),
            **kwargs,
        )
    
    def delete_by_aws_id(self,
        request: "DeleteAccessKeyByAwsIdRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteAccessKeyByAwsIdRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.DeleteAccessKeyByAwsIdRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="DeleteByAwsId",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def activate_by_aws_id(self,
        request: "ActivateAccessKeyByAwsIdRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ActivateAccessKeyByAwsIdRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.ActivateAccessKeyByAwsIdRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="ActivateByAwsId",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def deactivate_by_aws_id(self,
        request: "DeactivateAccessKeyByAwsIdRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeactivateAccessKeyByAwsIdRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.DeactivateAccessKeyByAwsIdRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="DeactivateByAwsId",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v2/project.proto
class Project(pb_classes.Message):
    __PB2_CLASS__ = project_pb2.Project
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.Project",project_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ProjectSpec|project_pb2.ProjectSpec|None|unset.UnsetType" = unset.Unset,
        status: "ProjectStatus|project_pb2.ProjectStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ProjectSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ProjectSpec,
        )
    @spec.setter
    def spec(self, value: "ProjectSpec|project_pb2.ProjectSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ProjectStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ProjectStatus,
        )
    @status.setter
    def status(self, value: "ProjectStatus|project_pb2.ProjectStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ProjectSpec(pb_classes.Message):
    __PB2_CLASS__ = project_pb2.ProjectSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ProjectSpec",project_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        region: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(region, unset.UnsetType):
            self.region = region
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "region",
        ]
    
    @builtins.property
    def region(self) -> "builtins.str":
        """
        Name of the region where project resources will be created.
        Example: "eu-north1".
        """
        
        return super()._get_field("region", explicit_presence=False,
        )
    @region.setter
    def region(self, value: "builtins.str|None") -> None:
        return super()._set_field("region",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "region":"region",
    }
    
class ProjectStatus(pb_classes.Message):
    __PB2_CLASS__ = project_pb2.ProjectStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ProjectStatus",project_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class ProjectState(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v2.ProjectStatus.ProjectState",project_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        CREATING = 1
        ACTIVE = 2
        PURGING = 3
        CREATED = 4
        ACTIVATING = 5
        PARKING = 6
        PARKED = 7
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        project_state: "ProjectStatus.ProjectState|project_pb2.ProjectStatus.ProjectState|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(project_state, unset.UnsetType):
            self.project_state = project_state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "project_state",
            "ProjectState",
        ]
    
    @builtins.property
    def project_state(self) -> "ProjectStatus.ProjectState":
        """
        Current state of the project.
        """
        
        return super()._get_field("project_state", explicit_presence=False,
        wrap=ProjectStatus.ProjectState,
        )
    @project_state.setter
    def project_state(self, value: "ProjectStatus.ProjectState|project_pb2.ProjectStatus.ProjectState|None") -> None:
        return super()._set_field("project_state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "project_state":"project_state",
        "ProjectState":"ProjectState",
    }
    
# file: nebius/iam/v2/project_service.proto
class CreateProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.CreateProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.CreateProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ProjectSpec|project_pb2.ProjectSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ProjectSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ProjectSpec,
        )
    @spec.setter
    def spec(self, value: "ProjectSpec|project_pb2.ProjectSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.GetProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.GetProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Identifier of project to retrieve.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetProjectByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.GetProjectByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.GetProjectByNameRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Identifier of the project parent container.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Name of the project to retrieve.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListProjectsRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.ListProjectsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ListProjectsRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Identifier of container to list projects from.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class UpdateProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.UpdateProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.UpdateProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ProjectSpec|project_pb2.ProjectSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ProjectSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ProjectSpec,
        )
    @spec.setter
    def spec(self, value: "ProjectSpec|project_pb2.ProjectSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.DeleteProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.DeleteProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Identifier of project to delete.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListProjectsResponse(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.ListProjectsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ListProjectsResponse",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Project]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Project]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Project,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Project]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class ProjectServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v2.ProjectService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v2.ProjectService",project_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v2.ProjectService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateProjectRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["CreateProjectRequest","operation.Operation[v1_1.Operation]"]:
        """
        Creates a new project.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.CreateProjectRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def get(self,
        request: "GetProjectRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetProjectRequest","Project"]:
        """
        Retrieves a project by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.GetProjectRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.Project`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=project_pb2.Project,
            result_wrapper=pb_classes.simple_wrapper(Project),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetProjectByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetProjectByNameRequest","Project"]:
        """
        Retrieves a project by its name within a specified parent.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.GetProjectByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.Project`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=project_pb2.Project,
            result_wrapper=pb_classes.simple_wrapper(Project),
            **kwargs,
        )
    
    def list(self,
        request: "ListProjectsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListProjectsRequest","ListProjectsResponse"]:
        """
        Lists projects under a specified parent.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.ListProjectsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.ListProjectsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=project_service_pb2.ListProjectsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListProjectsResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateProjectRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateProjectRequest","operation.Operation[v1_1.Operation]"]:
        """
        Updates an existing project.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.UpdateProjectRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    
    def delete(self,
        request: "DeleteProjectRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["DeleteProjectRequest","operation.Operation[v1_1.Operation]"]:
        """
        Deletes a project by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.DeleteProjectRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    

# file: nebius/iam/v2/tenant.proto
class Tenant(pb_classes.Message):
    __PB2_CLASS__ = tenant_pb2.Tenant
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.Tenant",tenant_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "TenantSpec|tenant_pb2.TenantSpec|None|unset.UnsetType" = unset.Unset,
        status: "TenantStatus|tenant_pb2.TenantStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "TenantSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=TenantSpec,
        )
    @spec.setter
    def spec(self, value: "TenantSpec|tenant_pb2.TenantSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "TenantStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=TenantStatus,
        )
    @status.setter
    def status(self, value: "TenantStatus|tenant_pb2.TenantStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class TenantSpec(pb_classes.Message):
    __PB2_CLASS__ = tenant_pb2.TenantSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.TenantSpec",tenant_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class TenantStatus(pb_classes.Message):
    __PB2_CLASS__ = tenant_pb2.TenantStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.TenantStatus",tenant_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class TenantState(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v2.TenantStatus.TenantState",tenant_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        CREATING = 1
        ACTIVE = 2
        CREATED = 3
        ACTIVATING = 4
        PARKING = 5
        PARKED = 6
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_state: "TenantStatus.TenantState|tenant_pb2.TenantStatus.TenantState|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_state, unset.UnsetType):
            self.tenant_state = tenant_state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_state",
            "TenantState",
        ]
    
    @builtins.property
    def tenant_state(self) -> "TenantStatus.TenantState":
        return super()._get_field("tenant_state", explicit_presence=False,
        wrap=TenantStatus.TenantState,
        )
    @tenant_state.setter
    def tenant_state(self, value: "TenantStatus.TenantState|tenant_pb2.TenantStatus.TenantState|None") -> None:
        return super()._set_field("tenant_state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_state":"tenant_state",
        "TenantState":"TenantState",
    }
    
# file: nebius/iam/v2/tenant_service.proto
class GetTenantRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.GetTenantRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.GetTenantRequest",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetTenantByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.GetTenantByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.GetTenantByNameRequest",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Only empty value is allowed. Field is needed for compatibility.
        parent_id parameter for tenants doesn't make real sense, because tenants are top-level objects.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class UpdateTenantRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.UpdateTenantRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.UpdateTenantRequest",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "TenantSpec|tenant_pb2.TenantSpec|None|unset.UnsetType" = unset.Unset,
        name_prefix: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(name_prefix, unset.UnsetType):
            self.name_prefix = name_prefix
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "name_prefix",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "TenantSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=TenantSpec,
        )
    @spec.setter
    def spec(self, value: "TenantSpec|tenant_pb2.TenantSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def name_prefix(self) -> "builtins.str":
        """
        Tenant name prefix. A few random characters will be added to this prefix.
        """
        
        return super()._get_field("name_prefix", explicit_presence=False,
        )
    @name_prefix.setter
    def name_prefix(self, value: "builtins.str|None") -> None:
        return super()._set_field("name_prefix",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "name_prefix":"name_prefix",
    }
    
class ListTenantsRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.ListTenantsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ListTenantsRequest",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListTenantsResponse(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.ListTenantsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v2.ListTenantsResponse",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Tenant]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Tenant]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Tenant,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Tenant]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class TenantServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v2.TenantService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v2.TenantService",tenant_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v2.TenantService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Update"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetTenantRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetTenantRequest","Tenant"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.GetTenantRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.Tenant`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=tenant_pb2.Tenant,
            result_wrapper=pb_classes.simple_wrapper(Tenant),
            **kwargs,
        )
    
    def get_by_name(self,
        request: "GetTenantByNameRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["GetTenantByNameRequest","Tenant"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.GetTenantByNameRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.Tenant`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=tenant_pb2.Tenant,
            result_wrapper=pb_classes.simple_wrapper(Tenant),
            **kwargs,
        )
    
    def list(self,
        request: "ListTenantsRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["ListTenantsRequest","ListTenantsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.ListTenantsRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v2.ListTenantsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=tenant_service_pb2.ListTenantsResponse,
            result_wrapper=pb_classes.simple_wrapper(ListTenantsResponse),
            **kwargs,
        )
    
    def update(self,
        request: "UpdateTenantRequest",
        **kwargs: typing_extensions.Unpack[request_kwargs.RequestKwargs]
    ) -> request_1.Request["UpdateTenantRequest","operation.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v2.UpdateTenantRequest`
        
        Other parameters can be provided as keyword arguments in the
        ``**kwargs`` dictionary, including metadata, timeouts, and retries.
        See :class:`nebius.aio.request_kwargs.RequestKwargs` for details.
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        kwargs['metadata'] = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, kwargs.get('metadata', None))
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            result_wrapper=operation.Operation,
            **kwargs,
        )
    

__all__ = [
    #@ local import names here @#
    "SecretDeliveryMode",
    "AccessKey",
    "AccessKeySpec",
    "AccessKeyStatus",
    "CreateAccessKeyRequest",
    "GetAccessKeyRequest",
    "GetAccessKeySecretRequest",
    "GetAccessKeyByAwsIdRequest",
    "ListAccessKeysRequest",
    "ListAccessKeysByAccountRequest",
    "UpdateAccessKeyRequest",
    "ActivateAccessKeyRequest",
    "DeactivateAccessKeyRequest",
    "ActivateAccessKeyByAwsIdRequest",
    "DeactivateAccessKeyByAwsIdRequest",
    "DeleteAccessKeyRequest",
    "DeleteAccessKeyByAwsIdRequest",
    "GetAccessKeySecretResponse",
    "ListAccessKeysResponse",
    "AccessKeyServiceClient",
    "Project",
    "ProjectSpec",
    "ProjectStatus",
    "CreateProjectRequest",
    "GetProjectRequest",
    "GetProjectByNameRequest",
    "ListProjectsRequest",
    "UpdateProjectRequest",
    "DeleteProjectRequest",
    "ListProjectsResponse",
    "ProjectServiceClient",
    "Tenant",
    "TenantSpec",
    "TenantStatus",
    "GetTenantRequest",
    "GetTenantByNameRequest",
    "UpdateTenantRequest",
    "ListTenantsRequest",
    "ListTenantsResponse",
    "TenantServiceClient",
]
