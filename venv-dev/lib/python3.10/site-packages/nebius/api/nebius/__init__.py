# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius``"""

import builtins as builtins
import collections.abc as abc
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message
import nebius.api.nebius.annotations_pb2 as annotations_pb2
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
#@ local imports here @#

# file: nebius/annotations.proto
class ResourceBehavior(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.ResourceBehavior",annotations_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    RESOURCE_BEHAVIOR_UNSPECIFIED = 0
    """
    The behavior of the resource is unspecified.
    Avoid using this default value.
    """
    
    MOVABLE = 1
    """
    Indicates that the resource can be moved to another parent, typically an
    IAM container, though not necessarily limited to this.
    This behavior suggests that the ``metadata.parent_id`` attribute could be modified.
    """
    
    UNNAMED = 2
    """
    Indicates that the resource name can be unspecified or does not follow
    uniqueness requirement within parent_id and resource type.
    """
    
    IMMUTABLE_NAME = 3
    """
    Indicates that the resource is named, and the name cannot be changed after
    it is created. It is strongly recommended to do srvices with renaming
    capability, as the guidelines suggest.
    """
    

class FieldBehavior(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.FieldBehavior",annotations_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    FIELD_BEHAVIOR_UNSPECIFIED = 0
    IMMUTABLE = 2
    """
    This indicates that the field can't be changed during a resource update.
    Changing the field value will cause an ``INVALID_ARGUMENT`` error.
    Resource recreate requires a change of the field value.
    """
    
    IDENTIFIER = 3
    """
    Indicates field is a resource ID, so it MUST be present on a resource
    update, but MUST NOT be set on create.
    Otherwise, RPC will fail with the ``INVALID_ARGUMENT`` error
    """
    
    INPUT_ONLY = 4
    """
    Indicates field is not present in output.
    """
    
    OUTPUT_ONLY = 5
    """
    Indicates field can't be set on create or changed on update.
    Otherwise, RPC will fail with the ``INVALID_ARGUMENT`` error
    """
    
    MEANINGFUL_EMPTY_VALUE = 6
    """
    Indicates that an empty message and a null have different semantics.
    Usually, that field is a feature spec message: its empty message enables
    that feature, and null disables it. Such a message is different from ``bool``
    because it already has some feature parameters, or they can be added later
    in a backward-compatible way.
    IMPORTANT: if the message itself is recursive, this behavior is forced.
    """
    
    NON_EMPTY_DEFAULT = 7
    """
    Indicates that an empty (default) value will be filled by the server.
    Usually, that field is a feature spec value, which by default is computed.
    Values marked with this annotation won't raise error if they are not set
    and the returned value is not equal to protobuf default.
    
    IMPORTANT:
    Updating this value from explicit to default may not lead to Update call in
    some tools (eg Terraform).
    Compound values (messages, lists and maps) may result in unpredictable
    updates (see examples in guidelines).
    """
    

class ServicePySDKSettings(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.ServicePySDKSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.ServicePySDKSettings",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
class MethodPySDKSettings(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.MethodPySDKSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.MethodPySDKSettings",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
class FieldPySDKSettings(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.FieldPySDKSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.FieldPySDKSettings",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
class MessagePySDKSettings(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.MessagePySDKSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.MessagePySDKSettings",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
class OneofPySDKSettings(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.OneofPySDKSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.OneofPySDKSettings",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
class EnumPySDKSettings(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.EnumPySDKSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.EnumPySDKSettings",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
class EnumValuePySDKSettings(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.EnumValuePySDKSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.EnumValuePySDKSettings",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
class DeprecationDetails(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.DeprecationDetails
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.DeprecationDetails",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        effective_at: "builtins.str|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        description_cli: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(effective_at, unset.UnsetType):
            self.effective_at = effective_at
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(description_cli, unset.UnsetType):
            self.description_cli = description_cli
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "effective_at",
            "description",
            "description_cli",
        ]
    
    @builtins.property
    def effective_at(self) -> "builtins.str":
        """
        The date when this method, service, message or field will stop working (format: YYYY-MM-DD)
        """
        
        return super()._get_field("effective_at", explicit_presence=False,
        )
    @effective_at.setter
    def effective_at(self, value: "builtins.str|None") -> None:
        return super()._set_field("effective_at",value,explicit_presence=False,
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        """
        A description to help users understand the reason for deprecation and suggest alternatives.
        By default, this message will be shown in the CLI, Terraform, and SDKs as is.
        """
        
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def description_cli(self) -> "builtins.str":
        """
        Override base description for CLI, specify possible alternative method
        Example: "Please use the 'iam v2 access-key' command instead. All existing keys remain accessible through the new command."
        """
        
        return super()._get_field("description_cli", explicit_presence=False,
        )
    @description_cli.setter
    def description_cli(self, value: "builtins.str|None") -> None:
        return super()._set_field("description_cli",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "effective_at":"effective_at",
        "description":"description",
        "description_cli":"description_cli",
    }
    
class NIDFieldSettings(pb_classes.Message):
    __PB2_CLASS__ = annotations_pb2.NIDFieldSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.NIDFieldSettings",annotations_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message.Message|None = None,
        *,
        resource: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        parent_resource: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource, unset.UnsetType):
            self.resource = resource
        if not isinstance(parent_resource, unset.UnsetType):
            self.parent_resource = parent_resource
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource",
            "parent_resource",
        ]
    
    @builtins.property
    def resource(self) -> "abc.MutableSequence[builtins.str]":
        """
        Fields annotated with this option are treated as NIDs.
        ``resource`` lists allowed NID resource types (prefixes). Leave empty to accept any type.
        Validation only produces warnings.
        """
        
        return super()._get_field("resource", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @resource.setter
    def resource(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("resource",value,explicit_presence=False,
        )
    
    @builtins.property
    def parent_resource(self) -> "abc.MutableSequence[builtins.str]":
        """
        For metadata fields, ``parent_resource`` lists allowed parent resource types for ``metadata.parent_id``.
        Leave empty to allow any type. Validation only produces warnings.
        Typically set on the resource message; request-level overrides are supported.
        """
        
        return super()._get_field("parent_resource", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @parent_resource.setter
    def parent_resource(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("parent_resource",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource":"resource",
        "parent_resource":"parent_resource",
    }
    
file_deprecation_details = annotations_pb2.file_deprecation_details
api_service_name = annotations_pb2.api_service_name
service_deprecation_details = annotations_pb2.service_deprecation_details
service_py_sdk = annotations_pb2.service_py_sdk
method_deprecation_details = annotations_pb2.method_deprecation_details
method_py_sdk = annotations_pb2.method_py_sdk
send_reset_mask = annotations_pb2.send_reset_mask
resource_behavior = annotations_pb2.resource_behavior
message_deprecation_details = annotations_pb2.message_deprecation_details
message_py_sdk = annotations_pb2.message_py_sdk
field_behavior = annotations_pb2.field_behavior
sensitive = annotations_pb2.sensitive
credentials = annotations_pb2.credentials
field_deprecation_details = annotations_pb2.field_deprecation_details
field_py_sdk = annotations_pb2.field_py_sdk
nid = annotations_pb2.nid
oneof_behavior = annotations_pb2.oneof_behavior
oneof_py_sdk = annotations_pb2.oneof_py_sdk
enum_py_sdk = annotations_pb2.enum_py_sdk
enum_deprecation_details = annotations_pb2.enum_deprecation_details
enum_value_deprecation_details = annotations_pb2.enum_value_deprecation_details
enum_value_py_sdk = annotations_pb2.enum_value_py_sdk
__all__ = [
    #@ local import names here @#
    "ResourceBehavior",
    "FieldBehavior",
    "file_deprecation_details",
    "api_service_name",
    "service_deprecation_details",
    "service_py_sdk",
    "method_deprecation_details",
    "method_py_sdk",
    "send_reset_mask",
    "resource_behavior",
    "message_deprecation_details",
    "message_py_sdk",
    "field_behavior",
    "sensitive",
    "credentials",
    "field_deprecation_details",
    "field_py_sdk",
    "nid",
    "oneof_behavior",
    "oneof_py_sdk",
    "enum_py_sdk",
    "enum_deprecation_details",
    "enum_value_deprecation_details",
    "enum_value_py_sdk",
    "ServicePySDKSettings",
    "MethodPySDKSettings",
    "FieldPySDKSettings",
    "MessagePySDKSettings",
    "OneofPySDKSettings",
    "EnumPySDKSettings",
    "EnumValuePySDKSettings",
    "DeprecationDetails",
    "NIDFieldSettings",
]
