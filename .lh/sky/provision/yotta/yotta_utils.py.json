{
    "sourceFile": "sky/provision/yotta/yotta_utils.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1768466444820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1768546001185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n ENDPOINT = 'https://api.dev.yottalabs.ai/sdk/api'\n API_KEY_HEADER = 'X-API-KEY'\n \n GPU_NAME_MAP = {\n-    '8x_RTX5090_32G': 'NVIDIA_GeForce_RTX_5090_32G',\n+    '8x_RTX5090_SECURE': 'NVIDIA_GeForce_RTX_5090_32G',\n }\n \n \n class PodStatusEnum(enum.Enum):\n"
                },
                {
                    "date": 1768560279193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,52 @@\n # ENDPOINT = \"https://api.yottalabs.ai/sdk/api\"\n ENDPOINT = 'https://api.dev.yottalabs.ai/sdk/api'\n API_KEY_HEADER = 'X-API-KEY'\n \n+# ============= MOCK MODE FOR TESTING =============\n+# Set to True to use hardcoded pod data instead of calling Yotta API\n+MOCK_MODE = True\n+\n+# Hardcoded pod data for testing (from actual Yotta pod)\n+MOCK_POD_DATA = {\n+    'id': 402872365298094821,\n+    'name': 'sky-test-mock-head',  # Will be overwritten by actual cluster name\n+    'status': 20,  # Maps to PodStatusEnum.RUNNING (status / 10 = 2, but API returns 20)\n+    'image': 'yotta-btc-dev-harbor-58.com:8089/dockerhub-public-cache/yottalabsai/pytorch:2.9.0-py3.11-cuda12.8.1-cudnn-devel-ubuntu22.04',\n+    'gpuType': 'NVIDIA_GeForce_RTX_5090_32G',\n+    'gpuCount': 1,\n+    'region': 'us-central-3',\n+    'sshUser': 'user',\n+    'sshHost': '8hddab3v.ant3.dev.yottalabs.ai',\n+    'sshPort': '22',\n+    'expose': [\n+        {\n+            'protocol': 'SSH',\n+            'port': 22,\n+            'ingressEnabled': False,\n+            'host': '8hddab3v.ant3.dev.yottalabs.ai',\n+            'proxyPort': 30010,\n+            'privateHost': '172.20.71.176',\n+            'ingressUrl': '',\n+            'healthy': True\n+        },\n+        {\n+            'protocol': 'HTTP',\n+            'port': 8888,\n+            'ingressEnabled': False,\n+            'host': '8hddab3v.ant3.dev.yottalabs.ai',\n+            'proxyPort': 30011,\n+            'privateHost': '172.20.71.176',\n+            'ingressUrl': '',\n+            'healthy': True\n+        }\n+    ],\n+    'podInternalIp': '172.20.71.176',\n+}\n+# ============= END MOCK MODE =============\n+\n GPU_NAME_MAP = {\n+    '1x_RTX5090_SECURE': 'NVIDIA_GeForce_RTX_5090_32G',\n     '8x_RTX5090_SECURE': 'NVIDIA_GeForce_RTX_5090_32G',\n }\n \n \n@@ -33,9 +76,34 @@\n     TERMINATING = 4\n     TERMINATED = 5\n     FAILED = 6\n \n+    @classmethod\n+    def from_api_status(cls, api_status: int) -> 'PodStatusEnum':\n+        \"\"\"Convert API status (0, 10, 20, ...) to PodStatusEnum.\n+        \n+        Yotta API returns status as multiples of 10 (0, 10, 20, 30, ...)\n+        but PodStatusEnum uses 0, 1, 2, 3, ...\n+        \"\"\"\n+        # Check if it's already in the correct range\n+        if api_status <= 6:\n+            return cls(api_status)\n+        # Convert from API format (0, 10, 20...) to enum format (0, 1, 2...)\n+        # Note: API status 20 -> RUNNING (1), etc.\n+        # Based on the pod data, status=20 means running\n+        status_map = {\n+            0: cls.INITIALIZE,\n+            10: cls.INITIALIZE,  # Creating\n+            20: cls.RUNNING,\n+            30: cls.PAUSING,\n+            40: cls.PAUSED,\n+            50: cls.TERMINATING,\n+            60: cls.TERMINATED,\n+            70: cls.FAILED,\n+        }\n+        return status_map.get(api_status, cls.FAILED)\n \n+\n class CloudType(enum.Enum):\n     \"\"\"cloud type.\"\"\"\n     SECURE = 1\n     COMMUNITY = 2\n@@ -120,10 +188,15 @@\n     \"\"\"Yotta API Client\"\"\"\n \n     def __init__(self):\n         self.user_id, self.api_key = _load_credentials()\n+        # Track mock instances by cluster name\n+        self._mock_instances: Dict[str, Dict[str, Any]] = {}\n \n     def check_api_key(self) -> bool:\n+        if MOCK_MODE:\n+            logger.info('[MOCK] Skipping API key check, returning True')\n+            return True\n         url = f'{ENDPOINT}/key/check?userId={self.user_id}'\n         logger.debug(f'Checking api key for user {self.user_id}')\n         response = requests.get(url, headers={API_KEY_HEADER: self.api_key})\n         raise_yotta_error(response)\n@@ -133,8 +206,19 @@\n         return check_result['data']\n \n     def list_instances(self,\n                        cluster_name_on_cloud: str) -> Dict[str, Dict[str, Any]]:\n+        if MOCK_MODE:\n+            logger.info(f'[MOCK] list_instances for cluster: '\n+                        f'{cluster_name_on_cloud}')\n+            # Return mock instances if they exist for this cluster\n+            result = {}\n+            for inst_id, inst in self._mock_instances.items():\n+                if inst.get('name', '').startswith(cluster_name_on_cloud):\n+                    result[inst_id] = inst\n+            logger.info(f'[MOCK] Found {len(result)} instances')\n+            return result\n+\n         url = f'{ENDPOINT}/compute/list'\n         all_records: List[Dict[str, Any]] = []\n         request_data = {'name': cluster_name_on_cloud}\n \n@@ -152,17 +236,21 @@\n \n         unique_records = {}\n         for record in all_records:\n             unique_records[record['id']] = record\n-            status = PodStatusEnum(record.get('status'))\n+            # Convert API status to PodStatusEnum\n+            api_status = record.get('status', 0)\n+            status = PodStatusEnum.from_api_status(api_status)\n+            # Store the converted status for internal use\n+            record['_internal_status'] = status\n             if status == PodStatusEnum.RUNNING:\n                 ports = record.get('expose', [])\n                 record['port2endpoint'] = {}\n                 for port in ports:\n                     # container private port mapping to host public port\n                     record['port2endpoint'][port['port']] = {\n                         'host': port['host'],\n-                        'privateHost': port['privateHost'],\n+                        'privateHost': port.get('privateHost', port['host']),\n                         'port': port['proxyPort']\n                     }\n         return unique_records\n \n@@ -180,8 +268,34 @@\n             instance_id: The instance ID.\n         \"\"\"\n         _ = region  # Explicitly mark as unused but keep for API compatibility\n         name = f'{cluster_name}-{node_type}'\n+\n+        if MOCK_MODE:\n+            # In mock mode, return the hardcoded pod data\n+            logger.info(f'[MOCK] launch called for {name}')\n+            mock_instance = MOCK_POD_DATA.copy()\n+            mock_instance['name'] = name\n+            instance_id = str(mock_instance['id'])\n+            # Convert status to internal format\n+            mock_instance['_internal_status'] = PodStatusEnum.RUNNING\n+            # Build port2endpoint mapping\n+            mock_instance['port2endpoint'] = {}\n+            for port in mock_instance.get('expose', []):\n+                mock_instance['port2endpoint'][port['port']] = {\n+                    'host': port['host'],\n+                    'privateHost': port.get('privateHost', port['host']),\n+                    'port': port['proxyPort']\n+                }\n+            # Store in mock instances\n+            self._mock_instances[instance_id] = mock_instance\n+            logger.info(f'[MOCK] Launched instance {instance_id} with name '\n+                        f'{name}')\n+            logger.info(f'[MOCK] SSH: {mock_instance[\"sshUser\"]}@'\n+                        f'{mock_instance[\"sshHost\"]}:'\n+                        f'{mock_instance[\"expose\"][0][\"proxyPort\"]}')\n+            return instance_id\n+\n         gpu_type = GPU_NAME_MAP[instance_type]\n         gpu_quantity = int(instance_type.split('_')[0].replace('x', ''))\n         cloud_type = instance_type.split('_')[2]\n         cloud_type = getattr(CloudType, cloud_type, None)\n@@ -262,8 +376,16 @@\n     def terminate_instances(self, instance_id: int):\n         \"\"\"Terminate instances.\"\"\"\n         if not instance_id:\n             return\n+        if MOCK_MODE:\n+            logger.info(f'[MOCK] terminate_instances called for {instance_id}')\n+            # Remove from mock instances\n+            str_id = str(instance_id)\n+            if str_id in self._mock_instances:\n+                del self._mock_instances[str_id]\n+            return {'code': 10000, 'message': 'success'}\n+\n         url = f'{ENDPOINT}/compute/action'\n         request_data = {'id': instance_id, 'action': 'terminate'}\n         response = requests.post(url=url,\n                                  headers={API_KEY_HEADER: self.api_key},\n@@ -272,16 +394,22 @@\n         return response.json()\n \n     def list_ssh_keys(self):\n         \"\"\"list ssh keys.\"\"\"\n+        if MOCK_MODE:\n+            logger.info('[MOCK] list_ssh_keys called')\n+            return []\n         url = f'{ENDPOINT}/compute/keypair/list'\n         response = requests.get(url=url, headers={API_KEY_HEADER: self.api_key})\n         raise_yotta_error(response)\n         response_json = response.json()\n         return response_json['data']\n \n     def get_or_add_ssh_key(self, public_key: str = '') -> Dict[str, str]:\n         \"\"\"Add ssh key if not already added.\"\"\"\n+        if MOCK_MODE:\n+            logger.info('[MOCK] get_or_add_ssh_key called')\n+            return {'name': 'mock-ssh-key', 'ssh_key': public_key}\n         ssh_keys = self.list_ssh_keys()\n         for key in ssh_keys:\n             if key['publicKey'].strip().split()[:2] == public_key.strip().split(\n             )[:2]:\n"
                },
                {
                    "date": 1768561579848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -209,14 +209,25 @@\n                        cluster_name_on_cloud: str) -> Dict[str, Dict[str, Any]]:\n         if MOCK_MODE:\n             logger.info(f'[MOCK] list_instances for cluster: '\n                         f'{cluster_name_on_cloud}')\n-            # Return mock instances if they exist for this cluster\n-            result = {}\n-            for inst_id, inst in self._mock_instances.items():\n-                if inst.get('name', '').startswith(cluster_name_on_cloud):\n-                    result[inst_id] = inst\n-            logger.info(f'[MOCK] Found {len(result)} instances')\n+            # In mock mode, always return the mock pod as the head instance\n+            # This simulates an existing pod that we want to use\n+            mock_instance = MOCK_POD_DATA.copy()\n+            mock_instance['name'] = f'{cluster_name_on_cloud}-head'\n+            instance_id = str(mock_instance['id'])\n+            # Convert status to internal format\n+            mock_instance['_internal_status'] = PodStatusEnum.RUNNING\n+            # Build port2endpoint mapping\n+            mock_instance['port2endpoint'] = {}\n+            for port in mock_instance.get('expose', []):\n+                mock_instance['port2endpoint'][port['port']] = {\n+                    'host': port['host'],\n+                    'privateHost': port.get('privateHost', port['host']),\n+                    'port': port['proxyPort']\n+                }\n+            result = {instance_id: mock_instance}\n+            logger.info(f'[MOCK] Found {len(result)} instances: {list(result.keys())}')\n             return result\n \n         url = f'{ENDPOINT}/compute/list'\n         all_records: List[Dict[str, Any]] = []\n@@ -271,29 +282,12 @@\n         name = f'{cluster_name}-{node_type}'\n \n         if MOCK_MODE:\n             # In mock mode, return the hardcoded pod data\n-            logger.info(f'[MOCK] launch called for {name}')\n-            mock_instance = MOCK_POD_DATA.copy()\n-            mock_instance['name'] = name\n-            instance_id = str(mock_instance['id'])\n-            # Convert status to internal format\n-            mock_instance['_internal_status'] = PodStatusEnum.RUNNING\n-            # Build port2endpoint mapping\n-            mock_instance['port2endpoint'] = {}\n-            for port in mock_instance.get('expose', []):\n-                mock_instance['port2endpoint'][port['port']] = {\n-                    'host': port['host'],\n-                    'privateHost': port.get('privateHost', port['host']),\n-                    'port': port['proxyPort']\n-                }\n-            # Store in mock instances\n-            self._mock_instances[instance_id] = mock_instance\n-            logger.info(f'[MOCK] Launched instance {instance_id} with name '\n-                        f'{name}')\n-            logger.info(f'[MOCK] SSH: {mock_instance[\"sshUser\"]}@'\n-                        f'{mock_instance[\"sshHost\"]}:'\n-                        f'{mock_instance[\"expose\"][0][\"proxyPort\"]}')\n+            # Since list_instances already returns this pod, we just return the ID\n+            logger.info(f'[MOCK] launch called for {name} - using existing mock pod')\n+            instance_id = str(MOCK_POD_DATA['id'])\n+            logger.info(f'[MOCK] Returning existing instance {instance_id}')\n             return instance_id\n \n         gpu_type = GPU_NAME_MAP[instance_type]\n         gpu_quantity = int(instance_type.split('_')[0].replace('x', ''))\n"
                }
            ],
            "date": 1768466444820,
            "name": "Commit-0",
            "content": "\"\"\"Yotta API client.\"\"\"\n\nimport base64\nimport enum\nimport json\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple\nimport uuid\n\nimport requests\n\nfrom sky import sky_logging\nfrom sky.skylet import constants\n\nlogger = sky_logging.init_logger(__name__)\n\nCREDENTIALS_FILE_PATH = os.path.expanduser('~/.yotta/credentials')\n# ENDPOINT = \"https://api.yottalabs.ai/sdk/api\"\nENDPOINT = 'https://api.dev.yottalabs.ai/sdk/api'\nAPI_KEY_HEADER = 'X-API-KEY'\n\nGPU_NAME_MAP = {\n    '8x_RTX5090_32G': 'NVIDIA_GeForce_RTX_5090_32G',\n}\n\n\nclass PodStatusEnum(enum.Enum):\n    \"\"\"Pod status.\"\"\"\n    INITIALIZE = 0\n    RUNNING = 1\n    PAUSING = 2\n    PAUSED = 3\n    TERMINATING = 4\n    TERMINATED = 5\n    FAILED = 6\n\n\nclass CloudType(enum.Enum):\n    \"\"\"cloud type.\"\"\"\n    SECURE = 1\n    COMMUNITY = 2\n\n\ndef get_key_suffix():\n    return str(uuid.uuid4()).replace('-', '')[:8]\n\n\ndef _load_credentials() -> Tuple[str, str]:\n    \"\"\"Reads the credentials file and returns userId and apikey.\"\"\"\n    if not os.path.isfile(CREDENTIALS_FILE_PATH):\n        raise FileNotFoundError(\n            f'Credentials file not found at {CREDENTIALS_FILE_PATH}')\n\n    try:\n        with open(CREDENTIALS_FILE_PATH, 'r') as f:\n            credentials = {}\n            for line in f:\n                if '=' in line:\n                    key, value = line.strip().split('=', 1)\n                    credentials[key] = value\n\n        user_id: str = credentials.get('userId', '')\n        api_key: str = credentials.get('apikey', '')\n\n        if not user_id or not api_key:\n            raise ValueError(\n                f'Missing userId or apikey in credentials'\n                f' file: {CREDENTIALS_FILE_PATH}. '\n                'Please ensure the file contains \\'userId=<your_user_id>\\' and '\n                '\\'apikey=<your_api_key>\\'.')\n\n        return user_id, api_key\n    except Exception as e:\n        raise ValueError(\n            f'Error reading credentials file: {CREDENTIALS_FILE_PATH}. {e}'\n        ) from e\n\n\ndef get_ssh_port(instance):\n    # get ssh port example:\n    # {\"port\":22,\"proxyPort\":30003,\"protocol\":\"SSH\",\n    # \"host\":\"127.0.0.1\",\"privateHost\":\"127.0.0.1\",\"healthy\":true}\n    expose = instance.get('expose', [])\n    for port in expose:\n        if port.get('protocol') == 'SSH':\n            return port\n    return None\n\n\ndef raise_yotta_error(response: 'requests.Response') -> None:\n    \"\"\"Raise YottaAPIError if appropriate.\"\"\"\n    status_code = response.status_code\n    logger.debug(f'response: {response.status_code} - {response.text}')\n    try:\n        resp_json = response.json()\n    except (KeyError, json.decoder.JSONDecodeError) as e:\n        raise YottaAPIError(\n            f'Unexpected error. Status code: {status_code} \\n {response.text} '\n            f'\\n {str(e)}', status_code) from e\n    if response.ok:\n        if resp_json.get('code') != 10000:\n            raise YottaAPIError(\n                f'Business error: {resp_json.get(\"message\", \"Unknown error\")}',\n                resp_json.get('code', status_code))\n        return\n    else:\n        raise YottaAPIError(\n            f'Unexpected error. Status code: {status_code} \\n {response.text}',\n            status_code)\n\n\nclass YottaAPIError(Exception):\n\n    def __init__(self, message: str, code: int = 400):\n        self.code = code\n        super().__init__(message)\n\n\nclass YottaClient:\n    \"\"\"Yotta API Client\"\"\"\n\n    def __init__(self):\n        self.user_id, self.api_key = _load_credentials()\n\n    def check_api_key(self) -> bool:\n        url = f'{ENDPOINT}/key/check?userId={self.user_id}'\n        logger.debug(f'Checking api key for user {self.user_id}')\n        response = requests.get(url, headers={API_KEY_HEADER: self.api_key})\n        raise_yotta_error(response)\n        check_result = response.json()\n        # True if api key is valid\n        logger.debug(f'Api key check result: {check_result}')\n        return check_result['data']\n\n    def list_instances(self,\n                       cluster_name_on_cloud: str) -> Dict[str, Dict[str, Any]]:\n        url = f'{ENDPOINT}/compute/list'\n        all_records: List[Dict[str, Any]] = []\n        request_data = {'name': cluster_name_on_cloud}\n\n        response = requests.post(url,\n                                 headers={API_KEY_HEADER: self.api_key},\n                                 json=request_data)\n        response.raise_for_status()\n        response_json = response.json()\n        if response_json['code'] != 10000:\n            raise ValueError(\n                f'API returned an error: {response_json[\"message\"]}')\n\n        records = response_json['data']\n        all_records.extend(records)\n\n        unique_records = {}\n        for record in all_records:\n            unique_records[record['id']] = record\n            status = PodStatusEnum(record.get('status'))\n            if status == PodStatusEnum.RUNNING:\n                ports = record.get('expose', [])\n                record['port2endpoint'] = {}\n                for port in ports:\n                    # container private port mapping to host public port\n                    record['port2endpoint'][port['port']] = {\n                        'host': port['host'],\n                        'privateHost': port['privateHost'],\n                        'port': port['proxyPort']\n                    }\n        return unique_records\n\n    def launch(self, cluster_name: str, node_type: str, instance_type: str,\n               region: str, zone: str, image_name: str,\n               ports: Optional[List[int]], public_key: str,\n               ssh_user: str) -> str:\n        \"\"\"Launches an instance with the given parameters.\n\n        Converts the instance_type to the Yotta GPU name,\n        finds the specs for the\n        GPU, and launches the instance.\n\n        Returns:\n            instance_id: The instance ID.\n        \"\"\"\n        _ = region  # Explicitly mark as unused but keep for API compatibility\n        name = f'{cluster_name}-{node_type}'\n        gpu_type = GPU_NAME_MAP[instance_type]\n        gpu_quantity = int(instance_type.split('_')[0].replace('x', ''))\n        cloud_type = instance_type.split('_')[2]\n        cloud_type = getattr(CloudType, cloud_type, None)\n        # TODO : keep this align with setups in\n        # `provision.kuberunetes.instance.py`\n        setup_cmd = (\n            'prefix_cmd() '\n            '{ if [ $(id -u) -ne 0 ]; then echo \"sudo\"; else echo \"\"; fi; }; '\n            '$(prefix_cmd) apt update;'\n            'export DEBIAN_FRONTEND=noninteractive;'\n            '$(prefix_cmd) apt install openssh-server rsync curl patch -y;'\n            '$(prefix_cmd) mkdir -p /var/run/sshd; '\n            '$(prefix_cmd) '\n            'sed -i \"s/PermitRootLogin prohibit-password/PermitRootLogin yes/\" '\n            '/etc/ssh/sshd_config; '\n            '$(prefix_cmd) sed '\n            '\"s@session\\\\s*required\\\\s*pam_loginuid.so@session optional '\n            'pam_loginuid.so@g\" -i /etc/pam.d/sshd; '\n            'cd /etc/ssh/ && $(prefix_cmd) ssh-keygen -A; '\n            '$(prefix_cmd) mkdir -p ~/.ssh; '\n            '$(prefix_cmd) chown -R $(whoami) ~/.ssh;'\n            '$(prefix_cmd) chmod 700 ~/.ssh; '\n            f'$(prefix_cmd) echo \"{public_key}\" >> ~/.ssh/authorized_keys; '\n            '$(prefix_cmd) chmod 644 ~/.ssh/authorized_keys; '\n            '$(prefix_cmd) service ssh restart; '\n            '$(prefix_cmd) export -p > ~/container_env_var.sh && '\n            '$(prefix_cmd) '\n            'mv ~/container_env_var.sh /etc/profile.d/container_env_var.sh; '\n            '[ $(id -u) -eq 0 ] && echo alias sudo=\"\" >> ~/.bashrc;'\n            'sleep infinity')\n        # Use base64 to deal with the tricky quoting\n        # issues caused by runpod API.\n        encoded = base64.b64encode(setup_cmd.encode('utf-8')).decode('utf-8')\n\n        docker_args = (f'bash -c \\'echo {encoded} | base64 --decode > init.sh; '\n                       f'bash init.sh\\'')\n\n        expose = []\n        if ports is not None:\n            custom_ports_str = [{'port': p, 'protocol': 'TCP'} for p in ports]\n            expose.extend(custom_ports_str)\n\n        expose.append({'port': 22, 'protocol': 'SSH'})\n        expose.append({\n            'port': constants.SKY_REMOTE_RAY_DASHBOARD_PORT,\n            'protocol': 'HTTP'\n        })\n        expose.append({\n            'port': constants.SKY_REMOTE_RAY_PORT,\n            'protocol': 'HTTP'\n        })\n\n        request_data = {\n            'name': name,\n            'image': image_name,\n            'gpuType': gpu_type,\n            'gpuCount': gpu_quantity,\n            'cloudType': cloud_type.value\n                         if cloud_type is not None else CloudType.SECURE.value,\n            'region': zone,\n            'expose': expose,\n            'initializationCommand': docker_args,\n            'sshUser': ssh_user,\n            'sshPublicKey': public_key,\n        }\n        url = f'{ENDPOINT}/compute/create'\n\n        response = requests.post(\n            url,\n            headers={API_KEY_HEADER: self.api_key},\n            json=request_data,\n        )\n        logger.debug(f'response: {response.status_code} - {response.text}')\n        raise_yotta_error(response)\n        response_json = response.json()\n        return response_json['data']\n\n    def terminate_instances(self, instance_id: int):\n        \"\"\"Terminate instances.\"\"\"\n        if not instance_id:\n            return\n        url = f'{ENDPOINT}/compute/action'\n        request_data = {'id': instance_id, 'action': 'terminate'}\n        response = requests.post(url=url,\n                                 headers={API_KEY_HEADER: self.api_key},\n                                 json=request_data)\n        raise_yotta_error(response)\n        return response.json()\n\n    def list_ssh_keys(self):\n        \"\"\"list ssh keys.\"\"\"\n        url = f'{ENDPOINT}/compute/keypair/list'\n        response = requests.get(url=url, headers={API_KEY_HEADER: self.api_key})\n        raise_yotta_error(response)\n        response_json = response.json()\n        return response_json['data']\n\n    def get_or_add_ssh_key(self, public_key: str = '') -> Dict[str, str]:\n        \"\"\"Add ssh key if not already added.\"\"\"\n        ssh_keys = self.list_ssh_keys()\n        for key in ssh_keys:\n            if key['publicKey'].strip().split()[:2] == public_key.strip().split(\n            )[:2]:\n                return {'name': key['nickname'], 'ssh_key': public_key}\n        ssh_key_name = 'skypilot-' + get_key_suffix()\n        url = f'{ENDPOINT}/compute/create/publicKey'\n        request_data = {'nickname': ssh_key_name, 'publicKey': public_key}\n        response = requests.post(url=url,\n                                 headers={API_KEY_HEADER: self.api_key},\n                                 json=request_data)\n        raise_yotta_error(response)\n        return {'name': ssh_key_name, 'ssh_key': public_key}\n\n\nyotta_client = YottaClient()\n"
        }
    ]
}