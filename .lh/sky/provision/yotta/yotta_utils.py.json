{
    "sourceFile": "sky/provision/yotta/yotta_utils.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1768466444820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1768466444820,
            "name": "Commit-0",
            "content": "\"\"\"Yotta API client.\"\"\"\n\nimport base64\nimport enum\nimport json\nimport os\nfrom typing import Any, Dict, List, Optional, Tuple\nimport uuid\n\nimport requests\n\nfrom sky import sky_logging\nfrom sky.skylet import constants\n\nlogger = sky_logging.init_logger(__name__)\n\nCREDENTIALS_FILE_PATH = os.path.expanduser('~/.yotta/credentials')\n# ENDPOINT = \"https://api.yottalabs.ai/sdk/api\"\nENDPOINT = 'https://api.dev.yottalabs.ai/sdk/api'\nAPI_KEY_HEADER = 'X-API-KEY'\n\nGPU_NAME_MAP = {\n    '8x_RTX5090_32G': 'NVIDIA_GeForce_RTX_5090_32G',\n}\n\n\nclass PodStatusEnum(enum.Enum):\n    \"\"\"Pod status.\"\"\"\n    INITIALIZE = 0\n    RUNNING = 1\n    PAUSING = 2\n    PAUSED = 3\n    TERMINATING = 4\n    TERMINATED = 5\n    FAILED = 6\n\n\nclass CloudType(enum.Enum):\n    \"\"\"cloud type.\"\"\"\n    SECURE = 1\n    COMMUNITY = 2\n\n\ndef get_key_suffix():\n    return str(uuid.uuid4()).replace('-', '')[:8]\n\n\ndef _load_credentials() -> Tuple[str, str]:\n    \"\"\"Reads the credentials file and returns userId and apikey.\"\"\"\n    if not os.path.isfile(CREDENTIALS_FILE_PATH):\n        raise FileNotFoundError(\n            f'Credentials file not found at {CREDENTIALS_FILE_PATH}')\n\n    try:\n        with open(CREDENTIALS_FILE_PATH, 'r') as f:\n            credentials = {}\n            for line in f:\n                if '=' in line:\n                    key, value = line.strip().split('=', 1)\n                    credentials[key] = value\n\n        user_id: str = credentials.get('userId', '')\n        api_key: str = credentials.get('apikey', '')\n\n        if not user_id or not api_key:\n            raise ValueError(\n                f'Missing userId or apikey in credentials'\n                f' file: {CREDENTIALS_FILE_PATH}. '\n                'Please ensure the file contains \\'userId=<your_user_id>\\' and '\n                '\\'apikey=<your_api_key>\\'.')\n\n        return user_id, api_key\n    except Exception as e:\n        raise ValueError(\n            f'Error reading credentials file: {CREDENTIALS_FILE_PATH}. {e}'\n        ) from e\n\n\ndef get_ssh_port(instance):\n    # get ssh port example:\n    # {\"port\":22,\"proxyPort\":30003,\"protocol\":\"SSH\",\n    # \"host\":\"127.0.0.1\",\"privateHost\":\"127.0.0.1\",\"healthy\":true}\n    expose = instance.get('expose', [])\n    for port in expose:\n        if port.get('protocol') == 'SSH':\n            return port\n    return None\n\n\ndef raise_yotta_error(response: 'requests.Response') -> None:\n    \"\"\"Raise YottaAPIError if appropriate.\"\"\"\n    status_code = response.status_code\n    logger.debug(f'response: {response.status_code} - {response.text}')\n    try:\n        resp_json = response.json()\n    except (KeyError, json.decoder.JSONDecodeError) as e:\n        raise YottaAPIError(\n            f'Unexpected error. Status code: {status_code} \\n {response.text} '\n            f'\\n {str(e)}', status_code) from e\n    if response.ok:\n        if resp_json.get('code') != 10000:\n            raise YottaAPIError(\n                f'Business error: {resp_json.get(\"message\", \"Unknown error\")}',\n                resp_json.get('code', status_code))\n        return\n    else:\n        raise YottaAPIError(\n            f'Unexpected error. Status code: {status_code} \\n {response.text}',\n            status_code)\n\n\nclass YottaAPIError(Exception):\n\n    def __init__(self, message: str, code: int = 400):\n        self.code = code\n        super().__init__(message)\n\n\nclass YottaClient:\n    \"\"\"Yotta API Client\"\"\"\n\n    def __init__(self):\n        self.user_id, self.api_key = _load_credentials()\n\n    def check_api_key(self) -> bool:\n        url = f'{ENDPOINT}/key/check?userId={self.user_id}'\n        logger.debug(f'Checking api key for user {self.user_id}')\n        response = requests.get(url, headers={API_KEY_HEADER: self.api_key})\n        raise_yotta_error(response)\n        check_result = response.json()\n        # True if api key is valid\n        logger.debug(f'Api key check result: {check_result}')\n        return check_result['data']\n\n    def list_instances(self,\n                       cluster_name_on_cloud: str) -> Dict[str, Dict[str, Any]]:\n        url = f'{ENDPOINT}/compute/list'\n        all_records: List[Dict[str, Any]] = []\n        request_data = {'name': cluster_name_on_cloud}\n\n        response = requests.post(url,\n                                 headers={API_KEY_HEADER: self.api_key},\n                                 json=request_data)\n        response.raise_for_status()\n        response_json = response.json()\n        if response_json['code'] != 10000:\n            raise ValueError(\n                f'API returned an error: {response_json[\"message\"]}')\n\n        records = response_json['data']\n        all_records.extend(records)\n\n        unique_records = {}\n        for record in all_records:\n            unique_records[record['id']] = record\n            status = PodStatusEnum(record.get('status'))\n            if status == PodStatusEnum.RUNNING:\n                ports = record.get('expose', [])\n                record['port2endpoint'] = {}\n                for port in ports:\n                    # container private port mapping to host public port\n                    record['port2endpoint'][port['port']] = {\n                        'host': port['host'],\n                        'privateHost': port['privateHost'],\n                        'port': port['proxyPort']\n                    }\n        return unique_records\n\n    def launch(self, cluster_name: str, node_type: str, instance_type: str,\n               region: str, zone: str, image_name: str,\n               ports: Optional[List[int]], public_key: str,\n               ssh_user: str) -> str:\n        \"\"\"Launches an instance with the given parameters.\n\n        Converts the instance_type to the Yotta GPU name,\n        finds the specs for the\n        GPU, and launches the instance.\n\n        Returns:\n            instance_id: The instance ID.\n        \"\"\"\n        _ = region  # Explicitly mark as unused but keep for API compatibility\n        name = f'{cluster_name}-{node_type}'\n        gpu_type = GPU_NAME_MAP[instance_type]\n        gpu_quantity = int(instance_type.split('_')[0].replace('x', ''))\n        cloud_type = instance_type.split('_')[2]\n        cloud_type = getattr(CloudType, cloud_type, None)\n        # TODO : keep this align with setups in\n        # `provision.kuberunetes.instance.py`\n        setup_cmd = (\n            'prefix_cmd() '\n            '{ if [ $(id -u) -ne 0 ]; then echo \"sudo\"; else echo \"\"; fi; }; '\n            '$(prefix_cmd) apt update;'\n            'export DEBIAN_FRONTEND=noninteractive;'\n            '$(prefix_cmd) apt install openssh-server rsync curl patch -y;'\n            '$(prefix_cmd) mkdir -p /var/run/sshd; '\n            '$(prefix_cmd) '\n            'sed -i \"s/PermitRootLogin prohibit-password/PermitRootLogin yes/\" '\n            '/etc/ssh/sshd_config; '\n            '$(prefix_cmd) sed '\n            '\"s@session\\\\s*required\\\\s*pam_loginuid.so@session optional '\n            'pam_loginuid.so@g\" -i /etc/pam.d/sshd; '\n            'cd /etc/ssh/ && $(prefix_cmd) ssh-keygen -A; '\n            '$(prefix_cmd) mkdir -p ~/.ssh; '\n            '$(prefix_cmd) chown -R $(whoami) ~/.ssh;'\n            '$(prefix_cmd) chmod 700 ~/.ssh; '\n            f'$(prefix_cmd) echo \"{public_key}\" >> ~/.ssh/authorized_keys; '\n            '$(prefix_cmd) chmod 644 ~/.ssh/authorized_keys; '\n            '$(prefix_cmd) service ssh restart; '\n            '$(prefix_cmd) export -p > ~/container_env_var.sh && '\n            '$(prefix_cmd) '\n            'mv ~/container_env_var.sh /etc/profile.d/container_env_var.sh; '\n            '[ $(id -u) -eq 0 ] && echo alias sudo=\"\" >> ~/.bashrc;'\n            'sleep infinity')\n        # Use base64 to deal with the tricky quoting\n        # issues caused by runpod API.\n        encoded = base64.b64encode(setup_cmd.encode('utf-8')).decode('utf-8')\n\n        docker_args = (f'bash -c \\'echo {encoded} | base64 --decode > init.sh; '\n                       f'bash init.sh\\'')\n\n        expose = []\n        if ports is not None:\n            custom_ports_str = [{'port': p, 'protocol': 'TCP'} for p in ports]\n            expose.extend(custom_ports_str)\n\n        expose.append({'port': 22, 'protocol': 'SSH'})\n        expose.append({\n            'port': constants.SKY_REMOTE_RAY_DASHBOARD_PORT,\n            'protocol': 'HTTP'\n        })\n        expose.append({\n            'port': constants.SKY_REMOTE_RAY_PORT,\n            'protocol': 'HTTP'\n        })\n\n        request_data = {\n            'name': name,\n            'image': image_name,\n            'gpuType': gpu_type,\n            'gpuCount': gpu_quantity,\n            'cloudType': cloud_type.value\n                         if cloud_type is not None else CloudType.SECURE.value,\n            'region': zone,\n            'expose': expose,\n            'initializationCommand': docker_args,\n            'sshUser': ssh_user,\n            'sshPublicKey': public_key,\n        }\n        url = f'{ENDPOINT}/compute/create'\n\n        response = requests.post(\n            url,\n            headers={API_KEY_HEADER: self.api_key},\n            json=request_data,\n        )\n        logger.debug(f'response: {response.status_code} - {response.text}')\n        raise_yotta_error(response)\n        response_json = response.json()\n        return response_json['data']\n\n    def terminate_instances(self, instance_id: int):\n        \"\"\"Terminate instances.\"\"\"\n        if not instance_id:\n            return\n        url = f'{ENDPOINT}/compute/action'\n        request_data = {'id': instance_id, 'action': 'terminate'}\n        response = requests.post(url=url,\n                                 headers={API_KEY_HEADER: self.api_key},\n                                 json=request_data)\n        raise_yotta_error(response)\n        return response.json()\n\n    def list_ssh_keys(self):\n        \"\"\"list ssh keys.\"\"\"\n        url = f'{ENDPOINT}/compute/keypair/list'\n        response = requests.get(url=url, headers={API_KEY_HEADER: self.api_key})\n        raise_yotta_error(response)\n        response_json = response.json()\n        return response_json['data']\n\n    def get_or_add_ssh_key(self, public_key: str = '') -> Dict[str, str]:\n        \"\"\"Add ssh key if not already added.\"\"\"\n        ssh_keys = self.list_ssh_keys()\n        for key in ssh_keys:\n            if key['publicKey'].strip().split()[:2] == public_key.strip().split(\n            )[:2]:\n                return {'name': key['nickname'], 'ssh_key': public_key}\n        ssh_key_name = 'skypilot-' + get_key_suffix()\n        url = f'{ENDPOINT}/compute/create/publicKey'\n        request_data = {'nickname': ssh_key_name, 'publicKey': public_key}\n        response = requests.post(url=url,\n                                 headers={API_KEY_HEADER: self.api_key},\n                                 json=request_data)\n        raise_yotta_error(response)\n        return {'name': ssh_key_name, 'ssh_key': public_key}\n\n\nyotta_client = YottaClient()\n"
        }
    ]
}